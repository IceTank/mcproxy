() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.u16)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.i32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.i16)(value)
        case "int": return (ctx.i32)(value)
        case "long": return (ctx.i64)(value)
        case "float": return (ctx.f32)(value)
        case "double": return (ctx.f64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.u16)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.i32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.i16)(value, buffer, offset)
        case "int": return (ctx.i32)(value, buffer, offset)
        case "long": return (ctx.i64)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "double": return (ctx.f64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.u16)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.i16)(buffer, offset)
        case "int": return (ctx.i32)(buffer, offset)
        case "long": return (ctx.i64)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "double": return (ctx.f64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.lu16)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.li32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.li16)(value)
        case "int": return (ctx.li32)(value)
        case "long": return (ctx.li64)(value)
        case "float": return (ctx.lf32)(value)
        case "double": return (ctx.lf64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.lu16)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.li32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.li16)(value, buffer, offset)
        case "int": return (ctx.li32)(value, buffer, offset)
        case "long": return (ctx.li64)(value, buffer, offset)
        case "float": return (ctx.lf32)(value, buffer, offset)
        case "double": return (ctx.lf64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.lu16)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.li16)(buffer, offset)
        case "int": return (ctx.li32)(buffer, offset)
        case "long": return (ctx.li64)(buffer, offset)
        case "float": return (ctx.lf32)(buffer, offset)
        case "double": return (ctx.lf64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.zigzag32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.li16)(value)
        case "int": return (ctx.zigzag32)(value)
        case "long": return (ctx.zigzag64)(value)
        case "float": return (ctx.lf32)(value)
        case "double": return (ctx.lf64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.zigzag32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.li16)(value, buffer, offset)
        case "int": return (ctx.zigzag32)(value, buffer, offset)
        case "long": return (ctx.zigzag64)(value, buffer, offset)
        case "float": return (ctx.lf32)(value, buffer, offset)
        case "double": return (ctx.lf64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.li16)(buffer, offset)
        case "int": return (ctx.zigzag32)(buffer, offset)
        case "long": return (ctx.zigzag64)(buffer, offset)
        case "float": return (ctx.lf32)(buffer, offset)
        case "double": return (ctx.lf64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_set_protocol: (value) => {
      let size = 0
      let protocolVersion = value.protocolVersion
      size += (ctx.varint)(protocolVersion)
      let serverHost = value.serverHost
      size += (ctx.string)(serverHost)
      let serverPort = value.serverPort
      size += (ctx.u16)(serverPort)
      let nextState = value.nextState
      size += (ctx.varint)(nextState)
      return size
    },
    packet_legacy_server_list_ping: (value) => {
      let size = 0
      let payload = value.payload
      size += (ctx.u8)(payload)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"set_protocol":0,"legacy_server_list_ping":254}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(value)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_set_protocol: (value, buffer, offset) => {
      let protocolVersion = value.protocolVersion
      offset = (ctx.varint)(protocolVersion, buffer, offset)
      let serverHost = value.serverHost
      offset = (ctx.string)(serverHost, buffer, offset)
      let serverPort = value.serverPort
      offset = (ctx.u16)(serverPort, buffer, offset)
      let nextState = value.nextState
      offset = (ctx.varint)(nextState, buffer, offset)
      return offset
    },
    packet_legacy_server_list_ping: (value, buffer, offset) => {
      let payload = value.payload
      offset = (ctx.u8)(payload, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"set_protocol":0,"legacy_server_list_ping":254}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(value, buffer, offset)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_set_protocol: (buffer, offset) => {
      let { value: protocolVersion, size: protocolVersionSize } = (ctx.varint)(buffer, offset)
      let { value: serverHost, size: serverHostSize } = (ctx.string)(buffer, offset + protocolVersionSize)
      let { value: serverPort, size: serverPortSize } = (ctx.u16)(buffer, offset + protocolVersionSize + serverHostSize)
      let { value: nextState, size: nextStateSize } = (ctx.varint)(buffer, offset + protocolVersionSize + serverHostSize + serverPortSize)
      return { value: { protocolVersion, serverHost, serverPort, nextState }, size: protocolVersionSize + serverHostSize + serverPortSize + nextStateSize}
    },
    packet_legacy_server_list_ping: (buffer, offset) => {
      let { value: payload, size: payloadSize } = (ctx.u8)(buffer, offset)
      return { value: { payload }, size: payloadSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"set_protocol","254":"legacy_server_list_ping"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(buffer, offset)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_spawn_entity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let objectUUID = value.objectUUID
      size += (ctx.UUID)(objectUUID)
      let type = value.type
      size += (ctx.varint)(type)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let headPitch = value.headPitch
      size += (ctx.i8)(headPitch)
      let objectData = value.objectData
      size += (ctx.varint)(objectData)
      let velocityX = value.velocityX
      size += (ctx.i16)(velocityX)
      let velocityY = value.velocityY
      size += (ctx.i16)(velocityY)
      let velocityZ = value.velocityZ
      size += (ctx.i16)(velocityZ)
      return size
    },
    packet_spawn_entity_experience_orb: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let count = value.count
      size += (ctx.i16)(count)
      return size
    },
    packet_named_entity_spawn: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let playerUUID = value.playerUUID
      size += (ctx.UUID)(playerUUID)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      return size
    },
    packet_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let animation = value.animation
      size += (ctx.u8)(animation)
      return size
    },
    packet_statistics: (value) => {
      let size = 0
      let entries = value.entries
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let categoryId = value.categoryId
          size += (ctx.varint)(categoryId)
          let statisticId = value.statisticId
          size += (ctx.varint)(statisticId)
          let value1 = value.value
          size += (ctx.varint)(value1)
          return size
        })(value[i])
        }
        return size
      })(entries)
      return size
    },
    packet_advancements: (value) => {
      let size = 0
      let reset = value.reset
      size += (ctx.bool)(reset)
      let advancementMapping = value.advancementMapping
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += ((value) => {
            let size = 0
            let parentId = value.parentId
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.string)(value)
              }
              return 1
            })(parentId)
            let displayData = value.displayData
            size += ((value) => {
              if (value != null) {
                return 1 + ((value) => {
                let size = 0
                let title = value.title
                size += (ctx.string)(title)
                let description = value.description
                size += (ctx.string)(description)
                let icon = value.icon
                size += (ctx.slot)(icon)
                let frameType = value.frameType
                size += (ctx.varint)(frameType)
                let flags1 = value.flags
                size += 4
                let backgroundTexture = value.backgroundTexture
                size += ((value) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(value)
                    default: return (ctx.void)(value)
                  }
                })(backgroundTexture)
                let xCord = value.xCord
                size += (ctx.f32)(xCord)
                let yCord = value.yCord
                size += (ctx.f32)(yCord)
                return size
              })(value)
              }
              return 1
            })(displayData)
            let criteria = value.criteria
            size += ((value) => {
              let size = (ctx.varint)(value.length)
              for (let i = 0; i < value.length; i++) {
                size += ((value) => {
                let size = 0
                let key1 = value.key
                size += (ctx.string)(key1)
                let value2 = value.value
                size += (ctx.void)(value2)
                return size
              })(value[i])
              }
              return size
            })(criteria)
            let requirements = value.requirements
            size += ((value) => {
              let size = (ctx.varint)(value.length)
              for (let i = 0; i < value.length; i++) {
                size += ((value) => {
                let size = (ctx.varint)(value.length)
                for (let i = 0; i < value.length; i++) {
                  size += (ctx.string)(value[i])
                }
                return size
              })(value[i])
              }
              return size
            })(requirements)
            return size
          })(value1)
          return size
        })(value[i])
        }
        return size
      })(advancementMapping)
      let identifiers = value.identifiers
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(identifiers)
      let progressMapping = value.progressMapping
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += ((value) => {
              let size = 0
              let criterionIdentifier = value.criterionIdentifier
              size += (ctx.string)(criterionIdentifier)
              let criterionProgress = value.criterionProgress
              size += ((value) => {
                if (value != null) {
                  return 1 + (ctx.i64)(value)
                }
                return 1
              })(criterionProgress)
              return size
            })(value[i])
            }
            return size
          })(value1)
          return size
        })(value[i])
        }
        return size
      })(progressMapping)
      return size
    },
    packet_block_break_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let location = value.location
      size += (ctx.position)(location)
      let destroyStage = value.destroyStage
      size += (ctx.i8)(destroyStage)
      return size
    },
    packet_tile_entity_data: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let action = value.action
      size += (ctx.varint)(action)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    packet_block_action: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let byte1 = value.byte1
      size += (ctx.u8)(byte1)
      let byte2 = value.byte2
      size += (ctx.u8)(byte2)
      let blockId = value.blockId
      size += (ctx.varint)(blockId)
      return size
    },
    packet_block_change: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let type = value.type
      size += (ctx.varint)(type)
      return size
    },
    packet_boss_bar: (value) => {
      let size = 0
      let entityUUID = value.entityUUID
      size += (ctx.UUID)(entityUUID)
      let action = value.action
      size += (ctx.varint)(action)
      let title = value.title
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.string)(value)
          case 3: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(title)
      let health = value.health
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.f32)(value)
          case 2: return (ctx.f32)(value)
          default: return (ctx.void)(value)
        }
      })(health)
      let color = value.color
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 4: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(color)
      let dividers = value.dividers
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 4: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(dividers)
      let flags = value.flags
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.u8)(value)
          case 5: return (ctx.u8)(value)
          default: return (ctx.void)(value)
        }
      })(flags)
      return size
    },
    packet_difficulty: (value) => {
      let size = 0
      let difficulty = value.difficulty
      size += (ctx.u8)(difficulty)
      let difficultyLocked = value.difficultyLocked
      size += (ctx.bool)(difficultyLocked)
      return size
    },
    packet_tab_complete: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let start = value.start
      size += (ctx.varint)(start)
      let length = value.length
      size += (ctx.varint)(length)
      let matches = value.matches
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let match = value.match
          size += (ctx.string)(match)
          let tooltip = value.tooltip
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(tooltip)
          return size
        })(value[i])
        }
        return size
      })(matches)
      return size
    },
    packet_declare_commands: (value) => {
      let size = 0
      let nodes = value.nodes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.command_node)(value[i])
        }
        return size
      })(nodes)
      let rootIndex = value.rootIndex
      size += (ctx.varint)(rootIndex)
      return size
    },
    packet_face_player: (value) => {
      let size = 0
      let feet_eyes = value.feet_eyes
      size += (ctx.varint)(feet_eyes)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let isEntity = value.isEntity
      size += (ctx.bool)(isEntity)
      let entityId = value.entityId
      size += ((value) => {
        switch (isEntity) {
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(entityId)
      let entity_feet_eyes = value.entity_feet_eyes
      size += ((value) => {
        switch (isEntity) {
          case true: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(entity_feet_eyes)
      return size
    },
    packet_nbt_query_response: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let nbt = value.nbt
      size += (ctx.optionalNbt)(nbt)
      return size
    },
    packet_multi_block_change: (value) => {
      let size = 0
      let chunkCoordinates = value.chunkCoordinates
      size += 8
      let suppressLightUpdates = value.suppressLightUpdates
      size += (ctx.bool)(suppressLightUpdates)
      let records = value.records
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(records)
      return size
    },
    packet_close_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      return size
    },
    packet_open_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.varint)(windowId)
      let inventoryType = value.inventoryType
      size += (ctx.varint)(inventoryType)
      let windowTitle = value.windowTitle
      size += (ctx.string)(windowTitle)
      return size
    },
    packet_window_items: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let stateId = value.stateId
      size += (ctx.varint)(stateId)
      let items = value.items
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.slot)(value[i])
        }
        return size
      })(items)
      let carriedItem = value.carriedItem
      size += (ctx.slot)(carriedItem)
      return size
    },
    packet_craft_progress_bar: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let property = value.property
      size += (ctx.i16)(property)
      let value1 = value.value
      size += (ctx.i16)(value1)
      return size
    },
    packet_set_slot: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let stateId = value.stateId
      size += (ctx.varint)(stateId)
      let slot = value.slot
      size += (ctx.i16)(slot)
      let item = value.item
      size += (ctx.slot)(item)
      return size
    },
    packet_set_cooldown: (value) => {
      let size = 0
      let itemID = value.itemID
      size += (ctx.varint)(itemID)
      let cooldownTicks = value.cooldownTicks
      size += (ctx.varint)(cooldownTicks)
      return size
    },
    packet_chat_suggestions: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.varint)(action)
      let entries = value.entries
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(entries)
      return size
    },
    packet_custom_payload: (value) => {
      let size = 0
      let channel = value.channel
      size += (ctx.string)(channel)
      let data = value.data
      size += (ctx.restBuffer)(data)
      return size
    },
    packet_hide_message: (value) => {
      let size = 0
      let id = value.id
      size += (ctx.varint)(id)
      let signature = value.signature
      size += ((value) => {
        switch (id) {
          case 0: return ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(signature)
      return size
    },
    packet_kick_disconnect: (value) => {
      let size = 0
      let reason = value.reason
      size += (ctx.string)(reason)
      return size
    },
    packet_profileless_chat: (value) => {
      let size = 0
      let message = value.message
      size += (ctx.string)(message)
      let type = value.type
      size += (ctx.varint)(type)
      let name = value.name
      size += (ctx.string)(name)
      let target = value.target
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(target)
      return size
    },
    packet_entity_status: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let entityStatus = value.entityStatus
      size += (ctx.i8)(entityStatus)
      return size
    },
    packet_explosion: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let radius = value.radius
      size += (ctx.f32)(radius)
      let affectedBlockOffsets = value.affectedBlockOffsets
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let x1 = value.x
          size += (ctx.i8)(x1)
          let y1 = value.y
          size += (ctx.i8)(y1)
          let z1 = value.z
          size += (ctx.i8)(z1)
          return size
        })(value[i])
        }
        return size
      })(affectedBlockOffsets)
      let playerMotionX = value.playerMotionX
      size += (ctx.f32)(playerMotionX)
      let playerMotionY = value.playerMotionY
      size += (ctx.f32)(playerMotionY)
      let playerMotionZ = value.playerMotionZ
      size += (ctx.f32)(playerMotionZ)
      return size
    },
    packet_unload_chunk: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.i32)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.i32)(chunkZ)
      return size
    },
    packet_game_state_change: (value) => {
      let size = 0
      let reason = value.reason
      size += (ctx.u8)(reason)
      let gameMode = value.gameMode
      size += (ctx.f32)(gameMode)
      return size
    },
    packet_open_horse_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let nbSlots = value.nbSlots
      size += (ctx.varint)(nbSlots)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      return size
    },
    packet_keep_alive: (value) => {
      let size = 0
      let keepAliveId = value.keepAliveId
      size += (ctx.i64)(keepAliveId)
      return size
    },
    packet_map_chunk: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.i32)(x)
      let z = value.z
      size += (ctx.i32)(z)
      let heightmaps = value.heightmaps
      size += (ctx.nbt)(heightmaps)
      let chunkData = value.chunkData
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(chunkData)
      let blockEntities = value.blockEntities
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.chunkBlockEntity)(value[i])
        }
        return size
      })(blockEntities)
      let trustEdges = value.trustEdges
      size += (ctx.bool)(trustEdges)
      let skyLightMask = value.skyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(skyLightMask)
      let blockLightMask = value.blockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(blockLightMask)
      let emptySkyLightMask = value.emptySkyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptySkyLightMask)
      let emptyBlockLightMask = value.emptyBlockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptyBlockLightMask)
      let skyLight = value.skyLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(skyLight)
      let blockLight = value.blockLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(blockLight)
      return size
    },
    packet_world_event: (value) => {
      let size = 0
      let effectId = value.effectId
      size += (ctx.i32)(effectId)
      let location = value.location
      size += (ctx.position)(location)
      let data = value.data
      size += (ctx.i32)(data)
      let global = value.global
      size += (ctx.bool)(global)
      return size
    },
    packet_world_particles: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let longDistance = value.longDistance
      size += (ctx.bool)(longDistance)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let offsetX = value.offsetX
      size += (ctx.f32)(offsetX)
      let offsetY = value.offsetY
      size += (ctx.f32)(offsetY)
      let offsetZ = value.offsetZ
      size += (ctx.f32)(offsetZ)
      let particleData = value.particleData
      size += (ctx.f32)(particleData)
      let particles = value.particles
      size += (ctx.i32)(particles)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    packet_update_light: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.varint)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.varint)(chunkZ)
      let trustEdges = value.trustEdges
      size += (ctx.bool)(trustEdges)
      let skyLightMask = value.skyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(skyLightMask)
      let blockLightMask = value.blockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(blockLightMask)
      let emptySkyLightMask = value.emptySkyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptySkyLightMask)
      let emptyBlockLightMask = value.emptyBlockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptyBlockLightMask)
      let skyLight = value.skyLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(skyLight)
      let blockLight = value.blockLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(blockLight)
      return size
    },
    packet_login: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let isHardcore = value.isHardcore
      size += (ctx.bool)(isHardcore)
      let gameMode = value.gameMode
      size += (ctx.u8)(gameMode)
      let previousGameMode = value.previousGameMode
      size += (ctx.i8)(previousGameMode)
      let worldNames = value.worldNames
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(worldNames)
      let dimensionCodec = value.dimensionCodec
      size += (ctx.nbt)(dimensionCodec)
      let worldType = value.worldType
      size += (ctx.string)(worldType)
      let worldName = value.worldName
      size += (ctx.string)(worldName)
      let hashedSeed = value.hashedSeed
      size += (ctx.i64)(hashedSeed)
      let maxPlayers = value.maxPlayers
      size += (ctx.varint)(maxPlayers)
      let viewDistance = value.viewDistance
      size += (ctx.varint)(viewDistance)
      let simulationDistance = value.simulationDistance
      size += (ctx.varint)(simulationDistance)
      let reducedDebugInfo = value.reducedDebugInfo
      size += (ctx.bool)(reducedDebugInfo)
      let enableRespawnScreen = value.enableRespawnScreen
      size += (ctx.bool)(enableRespawnScreen)
      let isDebug = value.isDebug
      size += (ctx.bool)(isDebug)
      let isFlat = value.isFlat
      size += (ctx.bool)(isFlat)
      let death = value.death
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = 0
          let dimensionName = value.dimensionName
          size += (ctx.string)(dimensionName)
          let location1 = value.location
          size += (ctx.position)(location1)
          return size
        })(value)
        }
        return 1
      })(death)
      return size
    },
    packet_map: (value) => {
      let size = 0
      let itemDamage = value.itemDamage
      size += (ctx.varint)(itemDamage)
      let scale = value.scale
      size += (ctx.i8)(scale)
      let locked = value.locked
      size += (ctx.bool)(locked)
      let icons = value.icons
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += ((value) => {
            let size = 0
            let type1 = value.type
            size += (ctx.varint)(type1)
            let x1 = value.x
            size += (ctx.i8)(x1)
            let z1 = value.z
            size += (ctx.i8)(z1)
            let direction = value.direction
            size += (ctx.u8)(direction)
            let displayName = value.displayName
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.string)(value)
              }
              return 1
            })(displayName)
            return size
          })(value[i])
          }
          return size
        })(value)
        }
        return 1
      })(icons)
      let columns = value.columns
      size += (ctx.u8)(columns)
      let rows = value.rows
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(rows)
      let x = value.x
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(x)
      let y = value.y
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(y)
      let data = value.data
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(value)
        }
      })(data)
      return size
    },
    packet_trade_list: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.varint)(windowId)
      let trades = value.trades
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let inputItem1 = value.inputItem1
          size += (ctx.slot)(inputItem1)
          let outputItem = value.outputItem
          size += (ctx.slot)(outputItem)
          let inputItem2 = value.inputItem2
          size += (ctx.slot)(inputItem2)
          let tradeDisabled = value.tradeDisabled
          size += (ctx.bool)(tradeDisabled)
          let nbTradeUses = value.nbTradeUses
          size += (ctx.i32)(nbTradeUses)
          let maximumNbTradeUses = value.maximumNbTradeUses
          size += (ctx.i32)(maximumNbTradeUses)
          let xp = value.xp
          size += (ctx.i32)(xp)
          let specialPrice = value.specialPrice
          size += (ctx.i32)(specialPrice)
          let priceMultiplier = value.priceMultiplier
          size += (ctx.f32)(priceMultiplier)
          let demand = value.demand
          size += (ctx.i32)(demand)
          return size
        })(value[i])
        }
        return size
      })(trades)
      let villagerLevel = value.villagerLevel
      size += (ctx.varint)(villagerLevel)
      let experience = value.experience
      size += (ctx.varint)(experience)
      let isRegularVillager = value.isRegularVillager
      size += (ctx.bool)(isRegularVillager)
      let canRestock = value.canRestock
      size += (ctx.bool)(canRestock)
      return size
    },
    packet_rel_entity_move: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let dX = value.dX
      size += (ctx.i16)(dX)
      let dY = value.dY
      size += (ctx.i16)(dY)
      let dZ = value.dZ
      size += (ctx.i16)(dZ)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_move_look: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let dX = value.dX
      size += (ctx.i16)(dX)
      let dY = value.dY
      size += (ctx.i16)(dY)
      let dZ = value.dZ
      size += (ctx.i16)(dZ)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_look: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_vehicle_move: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      return size
    },
    packet_open_book: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      return size
    },
    packet_open_sign_entity: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      return size
    },
    packet_craft_recipe_response: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let recipe = value.recipe
      size += (ctx.string)(recipe)
      return size
    },
    packet_abilities: (value) => {
      let size = 0
      let flags = value.flags
      size += (ctx.i8)(flags)
      let flyingSpeed = value.flyingSpeed
      size += (ctx.f32)(flyingSpeed)
      let walkingSpeed = value.walkingSpeed
      size += (ctx.f32)(walkingSpeed)
      return size
    },
    packet_player_chat: (value) => {
      let size = 0
      let senderUuid = value.senderUuid
      size += (ctx.UUID)(senderUuid)
      let index = value.index
      size += (ctx.varint)(index)
      let signature = value.signature
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = value instanceof Buffer ? value.length : Buffer.from(value).length
          return size
        })(value)
        }
        return 1
      })(signature)
      let plainMessage = value.plainMessage
      size += (ctx.string)(plainMessage)
      let timestamp = value.timestamp
      size += (ctx.i64)(timestamp)
      let salt = value.salt
      size += (ctx.i64)(salt)
      let previousMessages = value.previousMessages
      size += (ctx.previousMessages)(previousMessages)
      let unsignedChatContent = value.unsignedChatContent
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(unsignedChatContent)
      let filterType = value.filterType
      size += (ctx.varint)(filterType)
      let filterTypeMask = value.filterTypeMask
      size += ((value) => {
        switch (filterType) {
          case 2: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.i64)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(filterTypeMask)
      let type = value.type
      size += (ctx.varint)(type)
      let networkName = value.networkName
      size += (ctx.string)(networkName)
      let networkTargetName = value.networkTargetName
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(networkTargetName)
      return size
    },
    packet_end_combat_event: (value) => {
      let size = 0
      let duration = value.duration
      size += (ctx.varint)(duration)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      return size
    },
    packet_enter_combat_event: (value) => {
      let size = 0
      return size
    },
    packet_death_combat_event: (value) => {
      let size = 0
      let playerId = value.playerId
      size += (ctx.varint)(playerId)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let message = value.message
      size += (ctx.string)(message)
      return size
    },
    packet_player_remove: (value) => {
      let size = 0
      let players = value.players
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.UUID)(value[i])
        }
        return size
      })(players)
      return size
    },
    packet_player_info: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.i8)(action)
      let data = value.data
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let uuid = value.uuid
          size += (ctx.UUID)(uuid)
          let player = value.player
          size += ((value) => {
            switch (action) {
              case 1: return (ctx.game_profile)(value)
              case 3: return (ctx.game_profile)(value)
              case 5: return (ctx.game_profile)(value)
              case 7: return (ctx.game_profile)(value)
              case 9: return (ctx.game_profile)(value)
              case 11: return (ctx.game_profile)(value)
              case 13: return (ctx.game_profile)(value)
              case 15: return (ctx.game_profile)(value)
              case 17: return (ctx.game_profile)(value)
              case 19: return (ctx.game_profile)(value)
              case 21: return (ctx.game_profile)(value)
              case 23: return (ctx.game_profile)(value)
              case 25: return (ctx.game_profile)(value)
              case 27: return (ctx.game_profile)(value)
              case 29: return (ctx.game_profile)(value)
              case 31: return (ctx.game_profile)(value)
              case 33: return (ctx.game_profile)(value)
              case 35: return (ctx.game_profile)(value)
              case 37: return (ctx.game_profile)(value)
              case 39: return (ctx.game_profile)(value)
              case 41: return (ctx.game_profile)(value)
              case 43: return (ctx.game_profile)(value)
              case 45: return (ctx.game_profile)(value)
              case 47: return (ctx.game_profile)(value)
              case 49: return (ctx.game_profile)(value)
              case 51: return (ctx.game_profile)(value)
              case 53: return (ctx.game_profile)(value)
              case 55: return (ctx.game_profile)(value)
              case 57: return (ctx.game_profile)(value)
              case 59: return (ctx.game_profile)(value)
              case 61: return (ctx.game_profile)(value)
              case 63: return (ctx.game_profile)(value)
              default: return (ctx.void)(value)
            }
          })(player)
          let chatSession = value.chatSession
          size += ((value) => {
            switch (action) {
              case 2: return (ctx.chat_session)(value)
              case 3: return (ctx.chat_session)(value)
              case 6: return (ctx.chat_session)(value)
              case 7: return (ctx.chat_session)(value)
              case 10: return (ctx.chat_session)(value)
              case 11: return (ctx.chat_session)(value)
              case 14: return (ctx.chat_session)(value)
              case 15: return (ctx.chat_session)(value)
              case 18: return (ctx.chat_session)(value)
              case 19: return (ctx.chat_session)(value)
              case 22: return (ctx.chat_session)(value)
              case 23: return (ctx.chat_session)(value)
              case 26: return (ctx.chat_session)(value)
              case 27: return (ctx.chat_session)(value)
              case 30: return (ctx.chat_session)(value)
              case 31: return (ctx.chat_session)(value)
              case 34: return (ctx.chat_session)(value)
              case 35: return (ctx.chat_session)(value)
              case 38: return (ctx.chat_session)(value)
              case 39: return (ctx.chat_session)(value)
              case 42: return (ctx.chat_session)(value)
              case 43: return (ctx.chat_session)(value)
              case 46: return (ctx.chat_session)(value)
              case 47: return (ctx.chat_session)(value)
              case 50: return (ctx.chat_session)(value)
              case 51: return (ctx.chat_session)(value)
              case 54: return (ctx.chat_session)(value)
              case 55: return (ctx.chat_session)(value)
              case 58: return (ctx.chat_session)(value)
              case 59: return (ctx.chat_session)(value)
              case 62: return (ctx.chat_session)(value)
              case 63: return (ctx.chat_session)(value)
              default: return (ctx.void)(value)
            }
          })(chatSession)
          let gamemode = value.gamemode
          size += ((value) => {
            switch (action) {
              case 4: return (ctx.varint)(value)
              case 5: return (ctx.varint)(value)
              case 6: return (ctx.varint)(value)
              case 7: return (ctx.varint)(value)
              case 12: return (ctx.varint)(value)
              case 13: return (ctx.varint)(value)
              case 14: return (ctx.varint)(value)
              case 15: return (ctx.varint)(value)
              case 20: return (ctx.varint)(value)
              case 21: return (ctx.varint)(value)
              case 22: return (ctx.varint)(value)
              case 23: return (ctx.varint)(value)
              case 28: return (ctx.varint)(value)
              case 29: return (ctx.varint)(value)
              case 30: return (ctx.varint)(value)
              case 31: return (ctx.varint)(value)
              case 36: return (ctx.varint)(value)
              case 37: return (ctx.varint)(value)
              case 38: return (ctx.varint)(value)
              case 39: return (ctx.varint)(value)
              case 44: return (ctx.varint)(value)
              case 45: return (ctx.varint)(value)
              case 46: return (ctx.varint)(value)
              case 47: return (ctx.varint)(value)
              case 52: return (ctx.varint)(value)
              case 53: return (ctx.varint)(value)
              case 54: return (ctx.varint)(value)
              case 55: return (ctx.varint)(value)
              case 60: return (ctx.varint)(value)
              case 61: return (ctx.varint)(value)
              case 62: return (ctx.varint)(value)
              case 63: return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(gamemode)
          let listed = value.listed
          size += ((value) => {
            switch (action) {
              case 8: return (ctx.bool)(value)
              case 9: return (ctx.bool)(value)
              case 10: return (ctx.bool)(value)
              case 11: return (ctx.bool)(value)
              case 12: return (ctx.bool)(value)
              case 13: return (ctx.bool)(value)
              case 14: return (ctx.bool)(value)
              case 15: return (ctx.bool)(value)
              case 24: return (ctx.bool)(value)
              case 25: return (ctx.bool)(value)
              case 26: return (ctx.bool)(value)
              case 27: return (ctx.bool)(value)
              case 28: return (ctx.bool)(value)
              case 29: return (ctx.bool)(value)
              case 30: return (ctx.bool)(value)
              case 31: return (ctx.bool)(value)
              case 40: return (ctx.bool)(value)
              case 41: return (ctx.bool)(value)
              case 42: return (ctx.bool)(value)
              case 43: return (ctx.bool)(value)
              case 44: return (ctx.bool)(value)
              case 45: return (ctx.bool)(value)
              case 46: return (ctx.bool)(value)
              case 47: return (ctx.bool)(value)
              case 56: return (ctx.bool)(value)
              case 57: return (ctx.bool)(value)
              case 58: return (ctx.bool)(value)
              case 59: return (ctx.bool)(value)
              case 60: return (ctx.bool)(value)
              case 61: return (ctx.bool)(value)
              case 62: return (ctx.bool)(value)
              case 63: return (ctx.bool)(value)
              default: return (ctx.void)(value)
            }
          })(listed)
          let latency = value.latency
          size += ((value) => {
            switch (action) {
              case 16: return (ctx.varint)(value)
              case 17: return (ctx.varint)(value)
              case 18: return (ctx.varint)(value)
              case 19: return (ctx.varint)(value)
              case 20: return (ctx.varint)(value)
              case 21: return (ctx.varint)(value)
              case 22: return (ctx.varint)(value)
              case 23: return (ctx.varint)(value)
              case 24: return (ctx.varint)(value)
              case 25: return (ctx.varint)(value)
              case 26: return (ctx.varint)(value)
              case 27: return (ctx.varint)(value)
              case 28: return (ctx.varint)(value)
              case 29: return (ctx.varint)(value)
              case 30: return (ctx.varint)(value)
              case 31: return (ctx.varint)(value)
              case 48: return (ctx.varint)(value)
              case 49: return (ctx.varint)(value)
              case 50: return (ctx.varint)(value)
              case 51: return (ctx.varint)(value)
              case 52: return (ctx.varint)(value)
              case 53: return (ctx.varint)(value)
              case 54: return (ctx.varint)(value)
              case 55: return (ctx.varint)(value)
              case 56: return (ctx.varint)(value)
              case 57: return (ctx.varint)(value)
              case 58: return (ctx.varint)(value)
              case 59: return (ctx.varint)(value)
              case 60: return (ctx.varint)(value)
              case 61: return (ctx.varint)(value)
              case 62: return (ctx.varint)(value)
              case 63: return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(latency)
          let displayName = value.displayName
          size += ((value) => {
            switch (action) {
              case 32: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 33: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 34: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 35: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 36: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 37: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 38: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 39: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 40: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 41: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 42: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 43: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 44: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 45: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 46: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 47: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 48: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 49: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 50: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 51: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 52: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 53: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 54: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 55: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 56: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 57: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 58: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 59: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 60: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 61: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 62: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 63: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              default: return (ctx.void)(value)
            }
          })(displayName)
          return size
        })(value[i])
        }
        return size
      })(data)
      return size
    },
    packet_position: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let flags = value.flags
      size += (ctx.i8)(flags)
      let teleportId = value.teleportId
      size += (ctx.varint)(teleportId)
      return size
    },
    packet_unlock_recipes: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.varint)(action)
      let craftingBookOpen = value.craftingBookOpen
      size += (ctx.bool)(craftingBookOpen)
      let filteringCraftable = value.filteringCraftable
      size += (ctx.bool)(filteringCraftable)
      let smeltingBookOpen = value.smeltingBookOpen
      size += (ctx.bool)(smeltingBookOpen)
      let filteringSmeltable = value.filteringSmeltable
      size += (ctx.bool)(filteringSmeltable)
      let blastFurnaceOpen = value.blastFurnaceOpen
      size += (ctx.bool)(blastFurnaceOpen)
      let filteringBlastFurnace = value.filteringBlastFurnace
      size += (ctx.bool)(filteringBlastFurnace)
      let smokerBookOpen = value.smokerBookOpen
      size += (ctx.bool)(smokerBookOpen)
      let filteringSmoker = value.filteringSmoker
      size += (ctx.bool)(filteringSmoker)
      let recipes1 = value.recipes1
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(recipes1)
      let recipes2 = value.recipes2
      size += ((value) => {
        switch (action) {
          case 0: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(recipes2)
      return size
    },
    packet_entity_destroy: (value) => {
      let size = 0
      let entityIds = value.entityIds
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(entityIds)
      return size
    },
    packet_remove_entity_effect: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let effectId = value.effectId
      size += (ctx.varint)(effectId)
      return size
    },
    packet_resource_pack_send: (value) => {
      let size = 0
      let url = value.url
      size += (ctx.string)(url)
      let hash = value.hash
      size += (ctx.string)(hash)
      let forced = value.forced
      size += (ctx.bool)(forced)
      let promptMessage = value.promptMessage
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(promptMessage)
      return size
    },
    packet_respawn: (value) => {
      let size = 0
      let dimension = value.dimension
      size += (ctx.string)(dimension)
      let worldName = value.worldName
      size += (ctx.string)(worldName)
      let hashedSeed = value.hashedSeed
      size += (ctx.i64)(hashedSeed)
      let gamemode = value.gamemode
      size += (ctx.i8)(gamemode)
      let previousGamemode = value.previousGamemode
      size += (ctx.u8)(previousGamemode)
      let isDebug = value.isDebug
      size += (ctx.bool)(isDebug)
      let isFlat = value.isFlat
      size += (ctx.bool)(isFlat)
      let copyMetadata = value.copyMetadata
      size += (ctx.bool)(copyMetadata)
      let death = value.death
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = 0
          let dimensionName = value.dimensionName
          size += (ctx.string)(dimensionName)
          let location1 = value.location
          size += (ctx.position)(location1)
          return size
        })(value)
        }
        return 1
      })(death)
      return size
    },
    packet_entity_head_rotation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let headYaw = value.headYaw
      size += (ctx.i8)(headYaw)
      return size
    },
    packet_camera: (value) => {
      let size = 0
      let cameraId = value.cameraId
      size += (ctx.varint)(cameraId)
      return size
    },
    packet_held_item_slot: (value) => {
      let size = 0
      let slot = value.slot
      size += (ctx.i8)(slot)
      return size
    },
    packet_update_view_position: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.varint)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.varint)(chunkZ)
      return size
    },
    packet_update_view_distance: (value) => {
      let size = 0
      let viewDistance = value.viewDistance
      size += (ctx.varint)(viewDistance)
      return size
    },
    packet_scoreboard_display_objective: (value) => {
      let size = 0
      let position = value.position
      size += (ctx.i8)(position)
      let name = value.name
      size += (ctx.string)(name)
      return size
    },
    packet_entity_metadata: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let metadata = value.metadata
      size += (ctx.entityMetadata)(metadata)
      return size
    },
    packet_attach_entity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let vehicleId = value.vehicleId
      size += (ctx.i32)(vehicleId)
      return size
    },
    packet_entity_velocity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let velocityX = value.velocityX
      size += (ctx.i16)(velocityX)
      let velocityY = value.velocityY
      size += (ctx.i16)(velocityY)
      let velocityZ = value.velocityZ
      size += (ctx.i16)(velocityZ)
      return size
    },
    packet_entity_equipment: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let equipments = value.equipments
      size += ((value) => {
        let size = 0
        for (const i in value) {
          size += ((value) => {
          let size = 0
          let slot1 = value.slot
          size += (ctx.i8)(slot1)
          let item1 = value.item
          size += (ctx.slot)(item1)
          return size
        })(value[i])
        }
        return size
      })(equipments)
      return size
    },
    packet_experience: (value) => {
      let size = 0
      let experienceBar = value.experienceBar
      size += (ctx.f32)(experienceBar)
      let totalExperience = value.totalExperience
      size += (ctx.varint)(totalExperience)
      let level = value.level
      size += (ctx.varint)(level)
      return size
    },
    packet_update_health: (value) => {
      let size = 0
      let health = value.health
      size += (ctx.f32)(health)
      let food = value.food
      size += (ctx.varint)(food)
      let foodSaturation = value.foodSaturation
      size += (ctx.f32)(foodSaturation)
      return size
    },
    packet_scoreboard_objective: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let action = value.action
      size += (ctx.i8)(action)
      let displayText = value.displayText
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(displayText)
      let type = value.type
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 2: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(type)
      return size
    },
    packet_set_passengers: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let passengers = value.passengers
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(passengers)
      return size
    },
    packet_teams: (value) => {
      let size = 0
      let team = value.team
      size += (ctx.string)(team)
      let mode = value.mode
      size += (ctx.i8)(mode)
      let name = value.name
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(name)
      let friendlyFire = value.friendlyFire
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.i8)(value)
          case 2: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(friendlyFire)
      let nameTagVisibility = value.nameTagVisibility
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(nameTagVisibility)
      let collisionRule = value.collisionRule
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(collisionRule)
      let formatting = value.formatting
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.varint)(value)
          case 2: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(formatting)
      let prefix = value.prefix
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(prefix)
      let suffix = value.suffix
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(suffix)
      let players = value.players
      size += ((value) => {
        switch (mode) {
          case 0: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          case 3: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          case 4: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(players)
      return size
    },
    packet_scoreboard_score: (value) => {
      let size = 0
      let itemName = value.itemName
      size += (ctx.string)(itemName)
      let action = value.action
      size += (ctx.varint)(action)
      let scoreName = value.scoreName
      size += (ctx.string)(scoreName)
      let value1 = value.value
      size += ((value) => {
        switch (action) {
          case 1: return (ctx.void)(value)
          default: return (ctx.varint)(value)
        }
      })(value1)
      return size
    },
    packet_spawn_position: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let angle = value.angle
      size += (ctx.f32)(angle)
      return size
    },
    packet_update_time: (value) => {
      let size = 0
      let age = value.age
      size += (ctx.i64)(age)
      let time = value.time
      size += (ctx.i64)(time)
      return size
    },
    packet_entity_sound_effect: (value) => {
      let size = 0
      let soundId = value.soundId
      size += (ctx.varint)(soundId)
      let soundEvent = value.soundEvent
      size += ((value) => {
        switch (soundId) {
          case 0: return ((value) => {
            let size = 0
            let resource = value.resource
            size += (ctx.string)(resource)
            let range = value.range
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.f32)(value)
              }
              return 1
            })(range)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(soundEvent)
      let soundCategory = value.soundCategory
      size += (ctx.varint)(soundCategory)
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let volume = value.volume
      size += (ctx.f32)(volume)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let seed = value.seed
      size += (ctx.i64)(seed)
      return size
    },
    packet_stop_sound: (value) => {
      let size = 0
      let flags = value.flags
      size += (ctx.i8)(flags)
      let source = value.source
      size += ((value) => {
        switch (flags) {
          case 1: return (ctx.varint)(value)
          case 3: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(source)
      let sound = value.sound
      size += ((value) => {
        switch (flags) {
          case 2: return (ctx.string)(value)
          case 3: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(sound)
      return size
    },
    packet_sound_effect: (value) => {
      let size = 0
      let soundId = value.soundId
      size += (ctx.varint)(soundId)
      let soundEvent = value.soundEvent
      size += ((value) => {
        switch (soundId) {
          case 0: return ((value) => {
            let size = 0
            let resource = value.resource
            size += (ctx.string)(resource)
            let range = value.range
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.f32)(value)
              }
              return 1
            })(range)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(soundEvent)
      let soundCategory = value.soundCategory
      size += (ctx.varint)(soundCategory)
      let x = value.x
      size += (ctx.i32)(x)
      let y = value.y
      size += (ctx.i32)(y)
      let z = value.z
      size += (ctx.i32)(z)
      let volume = value.volume
      size += (ctx.f32)(volume)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let seed = value.seed
      size += (ctx.i64)(seed)
      return size
    },
    packet_system_chat: (value) => {
      let size = 0
      let content = value.content
      size += (ctx.string)(content)
      let isActionBar = value.isActionBar
      size += (ctx.bool)(isActionBar)
      return size
    },
    packet_playerlist_header: (value) => {
      let size = 0
      let header = value.header
      size += (ctx.string)(header)
      let footer = value.footer
      size += (ctx.string)(footer)
      return size
    },
    packet_collect: (value) => {
      let size = 0
      let collectedEntityId = value.collectedEntityId
      size += (ctx.varint)(collectedEntityId)
      let collectorEntityId = value.collectorEntityId
      size += (ctx.varint)(collectorEntityId)
      let pickupItemCount = value.pickupItemCount
      size += (ctx.varint)(pickupItemCount)
      return size
    },
    packet_entity_teleport: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_update_attributes: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value2 = value.value
          size += (ctx.f64)(value2)
          let modifiers = value.modifiers
          size += ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += ((value) => {
              let size = 0
              let uuid = value.uuid
              size += (ctx.UUID)(uuid)
              let amount = value.amount
              size += (ctx.f64)(amount)
              let operation = value.operation
              size += (ctx.i8)(operation)
              return size
            })(value[i])
            }
            return size
          })(modifiers)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    packet_feature_flags: (value) => {
      let size = 0
      let features = value.features
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(features)
      return size
    },
    packet_entity_effect: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let effectId = value.effectId
      size += (ctx.varint)(effectId)
      let amplifier = value.amplifier
      size += (ctx.i8)(amplifier)
      let duration = value.duration
      size += (ctx.varint)(duration)
      let hideParticles = value.hideParticles
      size += (ctx.i8)(hideParticles)
      let factorCodec = value.factorCodec
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.nbt)(value)
        }
        return 1
      })(factorCodec)
      return size
    },
    packet_select_advancement_tab: (value) => {
      let size = 0
      let id = value.id
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(id)
      return size
    },
    packet_server_data: (value) => {
      let size = 0
      let motd = value.motd
      size += (ctx.string)(motd)
      let iconBytes = value.iconBytes
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = value instanceof Buffer ? value.length : Buffer.from(value).length
          size += (ctx.varint)(size)
          return size
        })(value)
        }
        return 1
      })(iconBytes)
      let enforcesSecureChat = value.enforcesSecureChat
      size += (ctx.bool)(enforcesSecureChat)
      return size
    },
    packet_declare_recipes: (value) => {
      let size = 0
      let recipes = value.recipes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let type1 = value.type
          size += (ctx.string)(type1)
          let recipeId = value.recipeId
          size += (ctx.string)(recipeId)
          let data1 = value.data
          size += ((value) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((value) => {
                let size = 0
                let group1 = value.group
                size += (ctx.string)(group1)
                let category1 = value.category
                size += (ctx.varint)(category1)
                let ingredients = value.ingredients
                size += ((value) => {
                  let size = (ctx.varint)(value.length)
                  for (let i = 0; i < value.length; i++) {
                    size += (ctx.ingredient)(value[i])
                  }
                  return size
                })(ingredients)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:crafting_shaped": return ((value) => {
                let size = 0
                let width = value.width
                size += (ctx.varint)(width)
                let height = value.height
                size += (ctx.varint)(height)
                let group1 = value.group
                size += (ctx.string)(group1)
                let category1 = value.category
                size += (ctx.varint)(category1)
                let ingredients = value.ingredients
                size += ((value) => {
                  let size = 0
                  for (let i = 0; i < value.length; i++) {
                    size += ((value) => {
                    let size = 0
                    for (let i = 0; i < value.length; i++) {
                      size += (ctx.ingredient)(value[i])
                    }
                    return size
                  })(value[i])
                  }
                  return size
                })(ingredients)
                let result1 = value.result
                size += (ctx.slot)(result1)
                let showNotification = value.showNotification
                size += (ctx.bool)(showNotification)
                return size
              })(value)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:stonecutting": return ((value) => {
                let size = 0
                let group1 = value.group
                size += (ctx.string)(group1)
                let ingredient1 = value.ingredient
                size += (ctx.ingredient)(ingredient1)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing": return ((value) => {
                let size = 0
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing_transform": return ((value) => {
                let size = 0
                let template = value.template
                size += (ctx.ingredient)(template)
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing_trim": return ((value) => {
                let size = 0
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(value)
              default: return (ctx.void)(value)
            }
          })(data1)
          return size
        })(value[i])
        }
        return size
      })(recipes)
      return size
    },
    packet_tags: (value) => {
      let size = 0
      let tags = value.tags
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let tagType = value.tagType
          size += (ctx.string)(tagType)
          let tags1 = value.tags
          size += (ctx.tags)(tags1)
          return size
        })(value[i])
        }
        return size
      })(tags)
      return size
    },
    packet_acknowledge_player_digging: (value) => {
      let size = 0
      let sequenceId = value.sequenceId
      size += (ctx.varint)(sequenceId)
      return size
    },
    packet_clear_titles: (value) => {
      let size = 0
      let reset = value.reset
      size += (ctx.bool)(reset)
      return size
    },
    packet_initialize_world_border: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let z = value.z
      size += (ctx.f64)(z)
      let oldDiameter = value.oldDiameter
      size += (ctx.f64)(oldDiameter)
      let newDiameter = value.newDiameter
      size += (ctx.f64)(newDiameter)
      let speed = value.speed
      size += (ctx.varint)(speed)
      let portalTeleportBoundary = value.portalTeleportBoundary
      size += (ctx.varint)(portalTeleportBoundary)
      let warningBlocks = value.warningBlocks
      size += (ctx.varint)(warningBlocks)
      let warningTime = value.warningTime
      size += (ctx.varint)(warningTime)
      return size
    },
    packet_action_bar: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_world_border_center: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    packet_world_border_lerp_size: (value) => {
      let size = 0
      let oldDiameter = value.oldDiameter
      size += (ctx.f64)(oldDiameter)
      let newDiameter = value.newDiameter
      size += (ctx.f64)(newDiameter)
      let speed = value.speed
      size += (ctx.varint)(speed)
      return size
    },
    packet_world_border_size: (value) => {
      let size = 0
      let diameter = value.diameter
      size += (ctx.f64)(diameter)
      return size
    },
    packet_world_border_warning_delay: (value) => {
      let size = 0
      let warningTime = value.warningTime
      size += (ctx.varint)(warningTime)
      return size
    },
    packet_world_border_warning_reach: (value) => {
      let size = 0
      let warningBlocks = value.warningBlocks
      size += (ctx.varint)(warningBlocks)
      return size
    },
    packet_ping: (value) => {
      let size = 0
      let id = value.id
      size += (ctx.i32)(id)
      return size
    },
    packet_set_title_subtitle: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_set_title_text: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_set_title_time: (value) => {
      let size = 0
      let fadeIn = value.fadeIn
      size += (ctx.i32)(fadeIn)
      let stay = value.stay
      size += (ctx.i32)(stay)
      let fadeOut = value.fadeOut
      size += (ctx.i32)(fadeOut)
      return size
    },
    packet_simulation_distance: (value) => {
      let size = 0
      let distance = value.distance
      size += (ctx.varint)(distance)
      return size
    },
    packet_chunk_biomes: (value) => {
      let size = 0
      let biomes = value.biomes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let position1 = value.position
          size += (ctx.position)(position1)
          let data1 = value.data
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(data1)
          return size
        })(value[i])
        }
        return size
      })(biomes)
      return size
    },
    packet_damage_event: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let sourceTypeId = value.sourceTypeId
      size += (ctx.varint)(sourceTypeId)
      let sourceCauseId = value.sourceCauseId
      size += (ctx.varint)(sourceCauseId)
      let sourceDirectId = value.sourceDirectId
      size += (ctx.varint)(sourceDirectId)
      let sourcePosition = value.sourcePosition
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.vec3f64)(value)
        }
        return 1
      })(sourcePosition)
      return size
    },
    packet_hurt_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"bundle_delimiter":0,"spawn_entity":1,"spawn_entity_experience_orb":2,"named_entity_spawn":3,"animation":4,"statistics":5,"acknowledge_player_digging":6,"block_break_animation":7,"tile_entity_data":8,"block_action":9,"block_change":10,"boss_bar":11,"difficulty":12,"chunk_biomes":13,"clear_titles":14,"tab_complete":15,"declare_commands":16,"close_window":17,"window_items":18,"craft_progress_bar":19,"set_slot":20,"set_cooldown":21,"chat_suggestions":22,"custom_payload":23,"damage_event":24,"hide_message":25,"kick_disconnect":26,"profileless_chat":27,"entity_status":28,"explosion":29,"unload_chunk":30,"game_state_change":31,"open_horse_window":32,"hurt_animation":33,"initialize_world_border":34,"keep_alive":35,"map_chunk":36,"world_event":37,"world_particles":38,"update_light":39,"login":40,"map":41,"trade_list":42,"rel_entity_move":43,"entity_move_look":44,"entity_look":45,"vehicle_move":46,"open_book":47,"open_window":48,"open_sign_entity":49,"ping":50,"craft_recipe_response":51,"abilities":52,"player_chat":53,"end_combat_event":54,"enter_combat_event":55,"death_combat_event":56,"player_remove":57,"player_info":58,"face_player":59,"position":60,"unlock_recipes":61,"entity_destroy":62,"remove_entity_effect":63,"resource_pack_send":64,"respawn":65,"entity_head_rotation":66,"multi_block_change":67,"select_advancement_tab":68,"server_data":69,"action_bar":70,"world_border_center":71,"world_border_lerp_size":72,"world_border_size":73,"world_border_warning_delay":74,"world_border_warning_reach":75,"camera":76,"held_item_slot":77,"update_view_position":78,"update_view_distance":79,"spawn_position":80,"scoreboard_display_objective":81,"entity_metadata":82,"attach_entity":83,"entity_velocity":84,"entity_equipment":85,"experience":86,"update_health":87,"scoreboard_objective":88,"set_passengers":89,"teams":90,"scoreboard_score":91,"simulation_distance":92,"set_title_subtitle":93,"update_time":94,"set_title_text":95,"set_title_time":96,"entity_sound_effect":97,"sound_effect":98,"stop_sound":99,"system_chat":100,"playerlist_header":101,"nbt_query_response":102,"collect":103,"entity_teleport":104,"advancements":105,"entity_update_attributes":106,"feature_flags":107,"entity_effect":108,"declare_recipes":109,"tags":110}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(value)
          case "spawn_entity": return (ctx.packet_spawn_entity)(value)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(value)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(value)
          case "animation": return (ctx.packet_animation)(value)
          case "statistics": return (ctx.packet_statistics)(value)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(value)
          case "block_break_animation": return (ctx.packet_block_break_animation)(value)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(value)
          case "block_action": return (ctx.packet_block_action)(value)
          case "block_change": return (ctx.packet_block_change)(value)
          case "boss_bar": return (ctx.packet_boss_bar)(value)
          case "difficulty": return (ctx.packet_difficulty)(value)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(value)
          case "clear_titles": return (ctx.packet_clear_titles)(value)
          case "tab_complete": return (ctx.packet_tab_complete)(value)
          case "declare_commands": return (ctx.packet_declare_commands)(value)
          case "close_window": return (ctx.packet_close_window)(value)
          case "window_items": return (ctx.packet_window_items)(value)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(value)
          case "set_slot": return (ctx.packet_set_slot)(value)
          case "set_cooldown": return (ctx.packet_set_cooldown)(value)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(value)
          case "custom_payload": return (ctx.packet_custom_payload)(value)
          case "damage_event": return (ctx.packet_damage_event)(value)
          case "hide_message": return (ctx.packet_hide_message)(value)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(value)
          case "profileless_chat": return (ctx.packet_profileless_chat)(value)
          case "entity_status": return (ctx.packet_entity_status)(value)
          case "explosion": return (ctx.packet_explosion)(value)
          case "unload_chunk": return (ctx.packet_unload_chunk)(value)
          case "game_state_change": return (ctx.packet_game_state_change)(value)
          case "open_horse_window": return (ctx.packet_open_horse_window)(value)
          case "hurt_animation": return (ctx.packet_hurt_animation)(value)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(value)
          case "keep_alive": return (ctx.packet_keep_alive)(value)
          case "map_chunk": return (ctx.packet_map_chunk)(value)
          case "world_event": return (ctx.packet_world_event)(value)
          case "world_particles": return (ctx.packet_world_particles)(value)
          case "update_light": return (ctx.packet_update_light)(value)
          case "login": return (ctx.packet_login)(value)
          case "map": return (ctx.packet_map)(value)
          case "trade_list": return (ctx.packet_trade_list)(value)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(value)
          case "entity_move_look": return (ctx.packet_entity_move_look)(value)
          case "entity_look": return (ctx.packet_entity_look)(value)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value)
          case "open_book": return (ctx.packet_open_book)(value)
          case "open_window": return (ctx.packet_open_window)(value)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(value)
          case "ping": return (ctx.packet_ping)(value)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(value)
          case "abilities": return (ctx.packet_abilities)(value)
          case "player_chat": return (ctx.packet_player_chat)(value)
          case "end_combat_event": return (ctx.packet_end_combat_event)(value)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(value)
          case "death_combat_event": return (ctx.packet_death_combat_event)(value)
          case "player_remove": return (ctx.packet_player_remove)(value)
          case "player_info": return (ctx.packet_player_info)(value)
          case "face_player": return (ctx.packet_face_player)(value)
          case "position": return (ctx.packet_position)(value)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(value)
          case "entity_destroy": return (ctx.packet_entity_destroy)(value)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(value)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(value)
          case "respawn": return (ctx.packet_respawn)(value)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(value)
          case "multi_block_change": return (ctx.packet_multi_block_change)(value)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(value)
          case "server_data": return (ctx.packet_server_data)(value)
          case "action_bar": return (ctx.packet_action_bar)(value)
          case "world_border_center": return (ctx.packet_world_border_center)(value)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(value)
          case "world_border_size": return (ctx.packet_world_border_size)(value)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(value)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(value)
          case "camera": return (ctx.packet_camera)(value)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value)
          case "update_view_position": return (ctx.packet_update_view_position)(value)
          case "update_view_distance": return (ctx.packet_update_view_distance)(value)
          case "spawn_position": return (ctx.packet_spawn_position)(value)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(value)
          case "entity_metadata": return (ctx.packet_entity_metadata)(value)
          case "attach_entity": return (ctx.packet_attach_entity)(value)
          case "entity_velocity": return (ctx.packet_entity_velocity)(value)
          case "entity_equipment": return (ctx.packet_entity_equipment)(value)
          case "experience": return (ctx.packet_experience)(value)
          case "update_health": return (ctx.packet_update_health)(value)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(value)
          case "set_passengers": return (ctx.packet_set_passengers)(value)
          case "teams": return (ctx.packet_teams)(value)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(value)
          case "simulation_distance": return (ctx.packet_simulation_distance)(value)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(value)
          case "update_time": return (ctx.packet_update_time)(value)
          case "set_title_text": return (ctx.packet_set_title_text)(value)
          case "set_title_time": return (ctx.packet_set_title_time)(value)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(value)
          case "sound_effect": return (ctx.packet_sound_effect)(value)
          case "stop_sound": return (ctx.packet_stop_sound)(value)
          case "system_chat": return (ctx.packet_system_chat)(value)
          case "playerlist_header": return (ctx.packet_playerlist_header)(value)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(value)
          case "collect": return (ctx.packet_collect)(value)
          case "entity_teleport": return (ctx.packet_entity_teleport)(value)
          case "advancements": return (ctx.packet_advancements)(value)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(value)
          case "feature_flags": return (ctx.packet_feature_flags)(value)
          case "entity_effect": return (ctx.packet_entity_effect)(value)
          case "declare_recipes": return (ctx.packet_declare_recipes)(value)
          case "tags": return (ctx.packet_tags)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_spawn_entity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let objectUUID = value.objectUUID
      offset = (ctx.UUID)(objectUUID, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let headPitch = value.headPitch
      offset = (ctx.i8)(headPitch, buffer, offset)
      let objectData = value.objectData
      offset = (ctx.varint)(objectData, buffer, offset)
      let velocityX = value.velocityX
      offset = (ctx.i16)(velocityX, buffer, offset)
      let velocityY = value.velocityY
      offset = (ctx.i16)(velocityY, buffer, offset)
      let velocityZ = value.velocityZ
      offset = (ctx.i16)(velocityZ, buffer, offset)
      return offset
    },
    packet_spawn_entity_experience_orb: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let count = value.count
      offset = (ctx.i16)(count, buffer, offset)
      return offset
    },
    packet_named_entity_spawn: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let playerUUID = value.playerUUID
      offset = (ctx.UUID)(playerUUID, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      return offset
    },
    packet_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let animation = value.animation
      offset = (ctx.u8)(animation, buffer, offset)
      return offset
    },
    packet_statistics: (value, buffer, offset) => {
      let entries = value.entries
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let categoryId = value.categoryId
          offset = (ctx.varint)(categoryId, buffer, offset)
          let statisticId = value.statisticId
          offset = (ctx.varint)(statisticId, buffer, offset)
          let value1 = value.value
          offset = (ctx.varint)(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(entries, buffer, offset)
      return offset
    },
    packet_advancements: (value, buffer, offset) => {
      let reset = value.reset
      offset = (ctx.bool)(reset, buffer, offset)
      let advancementMapping = value.advancementMapping
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = ((value, buffer, offset) => {
            let parentId = value.parentId
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.string)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(parentId, buffer, offset)
            let displayData = value.displayData
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = ((value, buffer, offset) => {
                let title = value.title
                offset = (ctx.string)(title, buffer, offset)
                let description = value.description
                offset = (ctx.string)(description, buffer, offset)
                let icon = value.icon
                offset = (ctx.slot)(icon, buffer, offset)
                let frameType = value.frameType
                offset = (ctx.varint)(frameType, buffer, offset)
                let flags1 = value.flags
                offset = ((value, buffer, offset) => {
                  let _unused = value._unused
                  buffer[offset++] = ((_unused >> 21) & 0xff)
                  buffer[offset++] = ((_unused >> 13) & 0xff)
                  buffer[offset++] = ((_unused >> 5) & 0xff)
                  let hidden = value.hidden
                  let show_toast = value.show_toast
                  let has_background_texture = value.has_background_texture
                  buffer[offset++] = ((((((((_unused >> 0) & 0x1f)) << 1) | ((hidden >> 0) & 0x1)) << 1) | ((show_toast >> 0) & 0x1)) << 1) | ((has_background_texture >> 0) & 0x1)
                  return offset
                })(flags1, buffer, offset)
                let backgroundTexture = value.backgroundTexture
                offset = ((value, buffer, offset) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(value, buffer, offset)
                    default: return (ctx.void)(value, buffer, offset)
                  }
                })(backgroundTexture, buffer, offset)
                let xCord = value.xCord
                offset = (ctx.f32)(xCord, buffer, offset)
                let yCord = value.yCord
                offset = (ctx.f32)(yCord, buffer, offset)
                return offset
              })(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(displayData, buffer, offset)
            let criteria = value.criteria
            offset = ((value, buffer, offset) => {
              offset = (ctx.varint)(value.length, buffer, offset)
              for (let i = 0; i < value.length; i++) {
                offset = ((value, buffer, offset) => {
                let key1 = value.key
                offset = (ctx.string)(key1, buffer, offset)
                let value2 = value.value
                offset = (ctx.void)(value2, buffer, offset)
                return offset
              })(value[i], buffer, offset)
              }
              return offset
            })(criteria, buffer, offset)
            let requirements = value.requirements
            offset = ((value, buffer, offset) => {
              offset = (ctx.varint)(value.length, buffer, offset)
              for (let i = 0; i < value.length; i++) {
                offset = ((value, buffer, offset) => {
                offset = (ctx.varint)(value.length, buffer, offset)
                for (let i = 0; i < value.length; i++) {
                  offset = (ctx.string)(value[i], buffer, offset)
                }
                return offset
              })(value[i], buffer, offset)
              }
              return offset
            })(requirements, buffer, offset)
            return offset
          })(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(advancementMapping, buffer, offset)
      let identifiers = value.identifiers
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(identifiers, buffer, offset)
      let progressMapping = value.progressMapping
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = ((value, buffer, offset) => {
              let criterionIdentifier = value.criterionIdentifier
              offset = (ctx.string)(criterionIdentifier, buffer, offset)
              let criterionProgress = value.criterionProgress
              offset = ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.i64)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(criterionProgress, buffer, offset)
              return offset
            })(value[i], buffer, offset)
            }
            return offset
          })(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(progressMapping, buffer, offset)
      return offset
    },
    packet_block_break_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let destroyStage = value.destroyStage
      offset = (ctx.i8)(destroyStage, buffer, offset)
      return offset
    },
    packet_tile_entity_data: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    packet_block_action: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let byte1 = value.byte1
      offset = (ctx.u8)(byte1, buffer, offset)
      let byte2 = value.byte2
      offset = (ctx.u8)(byte2, buffer, offset)
      let blockId = value.blockId
      offset = (ctx.varint)(blockId, buffer, offset)
      return offset
    },
    packet_block_change: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      return offset
    },
    packet_boss_bar: (value, buffer, offset) => {
      let entityUUID = value.entityUUID
      offset = (ctx.UUID)(entityUUID, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let title = value.title
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 3: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(title, buffer, offset)
      let health = value.health
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.f32)(value, buffer, offset)
          case 2: return (ctx.f32)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(health, buffer, offset)
      let color = value.color
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 4: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(color, buffer, offset)
      let dividers = value.dividers
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 4: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(dividers, buffer, offset)
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.u8)(value, buffer, offset)
          case 5: return (ctx.u8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(flags, buffer, offset)
      return offset
    },
    packet_difficulty: (value, buffer, offset) => {
      let difficulty = value.difficulty
      offset = (ctx.u8)(difficulty, buffer, offset)
      let difficultyLocked = value.difficultyLocked
      offset = (ctx.bool)(difficultyLocked, buffer, offset)
      return offset
    },
    packet_tab_complete: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let start = value.start
      offset = (ctx.varint)(start, buffer, offset)
      let length = value.length
      offset = (ctx.varint)(length, buffer, offset)
      let matches = value.matches
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let match = value.match
          offset = (ctx.string)(match, buffer, offset)
          let tooltip = value.tooltip
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(tooltip, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(matches, buffer, offset)
      return offset
    },
    packet_declare_commands: (value, buffer, offset) => {
      let nodes = value.nodes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.command_node)(value[i], buffer, offset)
        }
        return offset
      })(nodes, buffer, offset)
      let rootIndex = value.rootIndex
      offset = (ctx.varint)(rootIndex, buffer, offset)
      return offset
    },
    packet_face_player: (value, buffer, offset) => {
      let feet_eyes = value.feet_eyes
      offset = (ctx.varint)(feet_eyes, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let isEntity = value.isEntity
      offset = (ctx.bool)(isEntity, buffer, offset)
      let entityId = value.entityId
      offset = ((value, buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(entityId, buffer, offset)
      let entity_feet_eyes = value.entity_feet_eyes
      offset = ((value, buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(entity_feet_eyes, buffer, offset)
      return offset
    },
    packet_nbt_query_response: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let nbt = value.nbt
      offset = (ctx.optionalNbt)(nbt, buffer, offset)
      return offset
    },
    packet_multi_block_change: (value, buffer, offset) => {
      let chunkCoordinates = value.chunkCoordinates
      offset = ((value, buffer, offset) => {
        let x = value.x
        buffer[offset++] = ((x >> 14) & 0xff)
        buffer[offset++] = ((x >> 6) & 0xff)
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0x3f)) << 2) | ((z >> 20) & 0x3)
        buffer[offset++] = ((z >> 12) & 0xff)
        buffer[offset++] = ((z >> 4) & 0xff)
        let y = value.y
        buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 16) & 0xf)
        buffer[offset++] = ((y >> 8) & 0xff)
        buffer[offset++] = ((y >> 0) & 0xff)
        return offset
      })(chunkCoordinates, buffer, offset)
      let suppressLightUpdates = value.suppressLightUpdates
      offset = (ctx.bool)(suppressLightUpdates, buffer, offset)
      let records = value.records
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(records, buffer, offset)
      return offset
    },
    packet_close_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      return offset
    },
    packet_open_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.varint)(windowId, buffer, offset)
      let inventoryType = value.inventoryType
      offset = (ctx.varint)(inventoryType, buffer, offset)
      let windowTitle = value.windowTitle
      offset = (ctx.string)(windowTitle, buffer, offset)
      return offset
    },
    packet_window_items: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let stateId = value.stateId
      offset = (ctx.varint)(stateId, buffer, offset)
      let items = value.items
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.slot)(value[i], buffer, offset)
        }
        return offset
      })(items, buffer, offset)
      let carriedItem = value.carriedItem
      offset = (ctx.slot)(carriedItem, buffer, offset)
      return offset
    },
    packet_craft_progress_bar: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let property = value.property
      offset = (ctx.i16)(property, buffer, offset)
      let value1 = value.value
      offset = (ctx.i16)(value1, buffer, offset)
      return offset
    },
    packet_set_slot: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let stateId = value.stateId
      offset = (ctx.varint)(stateId, buffer, offset)
      let slot = value.slot
      offset = (ctx.i16)(slot, buffer, offset)
      let item = value.item
      offset = (ctx.slot)(item, buffer, offset)
      return offset
    },
    packet_set_cooldown: (value, buffer, offset) => {
      let itemID = value.itemID
      offset = (ctx.varint)(itemID, buffer, offset)
      let cooldownTicks = value.cooldownTicks
      offset = (ctx.varint)(cooldownTicks, buffer, offset)
      return offset
    },
    packet_chat_suggestions: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let entries = value.entries
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(entries, buffer, offset)
      return offset
    },
    packet_custom_payload: (value, buffer, offset) => {
      let channel = value.channel
      offset = (ctx.string)(channel, buffer, offset)
      let data = value.data
      offset = (ctx.restBuffer)(data, buffer, offset)
      return offset
    },
    packet_hide_message: (value, buffer, offset) => {
      let id = value.id
      offset = (ctx.varint)(id, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        switch (id) {
          case 0: return ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            value.copy(buffer, offset)
            return offset + value.length
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(signature, buffer, offset)
      return offset
    },
    packet_kick_disconnect: (value, buffer, offset) => {
      let reason = value.reason
      offset = (ctx.string)(reason, buffer, offset)
      return offset
    },
    packet_profileless_chat: (value, buffer, offset) => {
      let message = value.message
      offset = (ctx.string)(message, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let target = value.target
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(target, buffer, offset)
      return offset
    },
    packet_entity_status: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let entityStatus = value.entityStatus
      offset = (ctx.i8)(entityStatus, buffer, offset)
      return offset
    },
    packet_explosion: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let radius = value.radius
      offset = (ctx.f32)(radius, buffer, offset)
      let affectedBlockOffsets = value.affectedBlockOffsets
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let x1 = value.x
          offset = (ctx.i8)(x1, buffer, offset)
          let y1 = value.y
          offset = (ctx.i8)(y1, buffer, offset)
          let z1 = value.z
          offset = (ctx.i8)(z1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(affectedBlockOffsets, buffer, offset)
      let playerMotionX = value.playerMotionX
      offset = (ctx.f32)(playerMotionX, buffer, offset)
      let playerMotionY = value.playerMotionY
      offset = (ctx.f32)(playerMotionY, buffer, offset)
      let playerMotionZ = value.playerMotionZ
      offset = (ctx.f32)(playerMotionZ, buffer, offset)
      return offset
    },
    packet_unload_chunk: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.i32)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.i32)(chunkZ, buffer, offset)
      return offset
    },
    packet_game_state_change: (value, buffer, offset) => {
      let reason = value.reason
      offset = (ctx.u8)(reason, buffer, offset)
      let gameMode = value.gameMode
      offset = (ctx.f32)(gameMode, buffer, offset)
      return offset
    },
    packet_open_horse_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let nbSlots = value.nbSlots
      offset = (ctx.varint)(nbSlots, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      return offset
    },
    packet_keep_alive: (value, buffer, offset) => {
      let keepAliveId = value.keepAliveId
      offset = (ctx.i64)(keepAliveId, buffer, offset)
      return offset
    },
    packet_map_chunk: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.i32)(x, buffer, offset)
      let z = value.z
      offset = (ctx.i32)(z, buffer, offset)
      let heightmaps = value.heightmaps
      offset = (ctx.nbt)(heightmaps, buffer, offset)
      let chunkData = value.chunkData
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(chunkData, buffer, offset)
      let blockEntities = value.blockEntities
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.chunkBlockEntity)(value[i], buffer, offset)
        }
        return offset
      })(blockEntities, buffer, offset)
      let trustEdges = value.trustEdges
      offset = (ctx.bool)(trustEdges, buffer, offset)
      let skyLightMask = value.skyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(skyLightMask, buffer, offset)
      let blockLightMask = value.blockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(blockLightMask, buffer, offset)
      let emptySkyLightMask = value.emptySkyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptySkyLightMask, buffer, offset)
      let emptyBlockLightMask = value.emptyBlockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptyBlockLightMask, buffer, offset)
      let skyLight = value.skyLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(skyLight, buffer, offset)
      let blockLight = value.blockLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(blockLight, buffer, offset)
      return offset
    },
    packet_world_event: (value, buffer, offset) => {
      let effectId = value.effectId
      offset = (ctx.i32)(effectId, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let data = value.data
      offset = (ctx.i32)(data, buffer, offset)
      let global = value.global
      offset = (ctx.bool)(global, buffer, offset)
      return offset
    },
    packet_world_particles: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let longDistance = value.longDistance
      offset = (ctx.bool)(longDistance, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let offsetX = value.offsetX
      offset = (ctx.f32)(offsetX, buffer, offset)
      let offsetY = value.offsetY
      offset = (ctx.f32)(offsetY, buffer, offset)
      let offsetZ = value.offsetZ
      offset = (ctx.f32)(offsetZ, buffer, offset)
      let particleData = value.particleData
      offset = (ctx.f32)(particleData, buffer, offset)
      let particles = value.particles
      offset = (ctx.i32)(particles, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    packet_update_light: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.varint)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.varint)(chunkZ, buffer, offset)
      let trustEdges = value.trustEdges
      offset = (ctx.bool)(trustEdges, buffer, offset)
      let skyLightMask = value.skyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(skyLightMask, buffer, offset)
      let blockLightMask = value.blockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(blockLightMask, buffer, offset)
      let emptySkyLightMask = value.emptySkyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptySkyLightMask, buffer, offset)
      let emptyBlockLightMask = value.emptyBlockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptyBlockLightMask, buffer, offset)
      let skyLight = value.skyLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(skyLight, buffer, offset)
      let blockLight = value.blockLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(blockLight, buffer, offset)
      return offset
    },
    packet_login: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let isHardcore = value.isHardcore
      offset = (ctx.bool)(isHardcore, buffer, offset)
      let gameMode = value.gameMode
      offset = (ctx.u8)(gameMode, buffer, offset)
      let previousGameMode = value.previousGameMode
      offset = (ctx.i8)(previousGameMode, buffer, offset)
      let worldNames = value.worldNames
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(worldNames, buffer, offset)
      let dimensionCodec = value.dimensionCodec
      offset = (ctx.nbt)(dimensionCodec, buffer, offset)
      let worldType = value.worldType
      offset = (ctx.string)(worldType, buffer, offset)
      let worldName = value.worldName
      offset = (ctx.string)(worldName, buffer, offset)
      let hashedSeed = value.hashedSeed
      offset = (ctx.i64)(hashedSeed, buffer, offset)
      let maxPlayers = value.maxPlayers
      offset = (ctx.varint)(maxPlayers, buffer, offset)
      let viewDistance = value.viewDistance
      offset = (ctx.varint)(viewDistance, buffer, offset)
      let simulationDistance = value.simulationDistance
      offset = (ctx.varint)(simulationDistance, buffer, offset)
      let reducedDebugInfo = value.reducedDebugInfo
      offset = (ctx.bool)(reducedDebugInfo, buffer, offset)
      let enableRespawnScreen = value.enableRespawnScreen
      offset = (ctx.bool)(enableRespawnScreen, buffer, offset)
      let isDebug = value.isDebug
      offset = (ctx.bool)(isDebug, buffer, offset)
      let isFlat = value.isFlat
      offset = (ctx.bool)(isFlat, buffer, offset)
      let death = value.death
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          let dimensionName = value.dimensionName
          offset = (ctx.string)(dimensionName, buffer, offset)
          let location1 = value.location
          offset = (ctx.position)(location1, buffer, offset)
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(death, buffer, offset)
      return offset
    },
    packet_map: (value, buffer, offset) => {
      let itemDamage = value.itemDamage
      offset = (ctx.varint)(itemDamage, buffer, offset)
      let scale = value.scale
      offset = (ctx.i8)(scale, buffer, offset)
      let locked = value.locked
      offset = (ctx.bool)(locked, buffer, offset)
      let icons = value.icons
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = ((value, buffer, offset) => {
            let type1 = value.type
            offset = (ctx.varint)(type1, buffer, offset)
            let x1 = value.x
            offset = (ctx.i8)(x1, buffer, offset)
            let z1 = value.z
            offset = (ctx.i8)(z1, buffer, offset)
            let direction = value.direction
            offset = (ctx.u8)(direction, buffer, offset)
            let displayName = value.displayName
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.string)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(displayName, buffer, offset)
            return offset
          })(value[i], buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(icons, buffer, offset)
      let columns = value.columns
      offset = (ctx.u8)(columns, buffer, offset)
      let rows = value.rows
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(rows, buffer, offset)
      let x = value.x
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(x, buffer, offset)
      let y = value.y
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(y, buffer, offset)
      let data = value.data
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(value, buffer, offset)
        }
      })(data, buffer, offset)
      return offset
    },
    packet_trade_list: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.varint)(windowId, buffer, offset)
      let trades = value.trades
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let inputItem1 = value.inputItem1
          offset = (ctx.slot)(inputItem1, buffer, offset)
          let outputItem = value.outputItem
          offset = (ctx.slot)(outputItem, buffer, offset)
          let inputItem2 = value.inputItem2
          offset = (ctx.slot)(inputItem2, buffer, offset)
          let tradeDisabled = value.tradeDisabled
          offset = (ctx.bool)(tradeDisabled, buffer, offset)
          let nbTradeUses = value.nbTradeUses
          offset = (ctx.i32)(nbTradeUses, buffer, offset)
          let maximumNbTradeUses = value.maximumNbTradeUses
          offset = (ctx.i32)(maximumNbTradeUses, buffer, offset)
          let xp = value.xp
          offset = (ctx.i32)(xp, buffer, offset)
          let specialPrice = value.specialPrice
          offset = (ctx.i32)(specialPrice, buffer, offset)
          let priceMultiplier = value.priceMultiplier
          offset = (ctx.f32)(priceMultiplier, buffer, offset)
          let demand = value.demand
          offset = (ctx.i32)(demand, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(trades, buffer, offset)
      let villagerLevel = value.villagerLevel
      offset = (ctx.varint)(villagerLevel, buffer, offset)
      let experience = value.experience
      offset = (ctx.varint)(experience, buffer, offset)
      let isRegularVillager = value.isRegularVillager
      offset = (ctx.bool)(isRegularVillager, buffer, offset)
      let canRestock = value.canRestock
      offset = (ctx.bool)(canRestock, buffer, offset)
      return offset
    },
    packet_rel_entity_move: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let dX = value.dX
      offset = (ctx.i16)(dX, buffer, offset)
      let dY = value.dY
      offset = (ctx.i16)(dY, buffer, offset)
      let dZ = value.dZ
      offset = (ctx.i16)(dZ, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_move_look: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let dX = value.dX
      offset = (ctx.i16)(dX, buffer, offset)
      let dY = value.dY
      offset = (ctx.i16)(dY, buffer, offset)
      let dZ = value.dZ
      offset = (ctx.i16)(dZ, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_look: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_vehicle_move: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      return offset
    },
    packet_open_book: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      return offset
    },
    packet_open_sign_entity: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      return offset
    },
    packet_craft_recipe_response: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let recipe = value.recipe
      offset = (ctx.string)(recipe, buffer, offset)
      return offset
    },
    packet_abilities: (value, buffer, offset) => {
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let flyingSpeed = value.flyingSpeed
      offset = (ctx.f32)(flyingSpeed, buffer, offset)
      let walkingSpeed = value.walkingSpeed
      offset = (ctx.f32)(walkingSpeed, buffer, offset)
      return offset
    },
    packet_player_chat: (value, buffer, offset) => {
      let senderUuid = value.senderUuid
      offset = (ctx.UUID)(senderUuid, buffer, offset)
      let index = value.index
      offset = (ctx.varint)(index, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          if (!(value instanceof Buffer)) value = Buffer.from(value)
          value.copy(buffer, offset)
          return offset + value.length
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(signature, buffer, offset)
      let plainMessage = value.plainMessage
      offset = (ctx.string)(plainMessage, buffer, offset)
      let timestamp = value.timestamp
      offset = (ctx.i64)(timestamp, buffer, offset)
      let salt = value.salt
      offset = (ctx.i64)(salt, buffer, offset)
      let previousMessages = value.previousMessages
      offset = (ctx.previousMessages)(previousMessages, buffer, offset)
      let unsignedChatContent = value.unsignedChatContent
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(unsignedChatContent, buffer, offset)
      let filterType = value.filterType
      offset = (ctx.varint)(filterType, buffer, offset)
      let filterTypeMask = value.filterTypeMask
      offset = ((value, buffer, offset) => {
        switch (filterType) {
          case 2: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.i64)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(filterTypeMask, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let networkName = value.networkName
      offset = (ctx.string)(networkName, buffer, offset)
      let networkTargetName = value.networkTargetName
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(networkTargetName, buffer, offset)
      return offset
    },
    packet_end_combat_event: (value, buffer, offset) => {
      let duration = value.duration
      offset = (ctx.varint)(duration, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      return offset
    },
    packet_enter_combat_event: (value, buffer, offset) => {
      return offset
    },
    packet_death_combat_event: (value, buffer, offset) => {
      let playerId = value.playerId
      offset = (ctx.varint)(playerId, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let message = value.message
      offset = (ctx.string)(message, buffer, offset)
      return offset
    },
    packet_player_remove: (value, buffer, offset) => {
      let players = value.players
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.UUID)(value[i], buffer, offset)
        }
        return offset
      })(players, buffer, offset)
      return offset
    },
    packet_player_info: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.i8)(action, buffer, offset)
      let data = value.data
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let uuid = value.uuid
          offset = (ctx.UUID)(uuid, buffer, offset)
          let player = value.player
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 1: return (ctx.game_profile)(value, buffer, offset)
              case 3: return (ctx.game_profile)(value, buffer, offset)
              case 5: return (ctx.game_profile)(value, buffer, offset)
              case 7: return (ctx.game_profile)(value, buffer, offset)
              case 9: return (ctx.game_profile)(value, buffer, offset)
              case 11: return (ctx.game_profile)(value, buffer, offset)
              case 13: return (ctx.game_profile)(value, buffer, offset)
              case 15: return (ctx.game_profile)(value, buffer, offset)
              case 17: return (ctx.game_profile)(value, buffer, offset)
              case 19: return (ctx.game_profile)(value, buffer, offset)
              case 21: return (ctx.game_profile)(value, buffer, offset)
              case 23: return (ctx.game_profile)(value, buffer, offset)
              case 25: return (ctx.game_profile)(value, buffer, offset)
              case 27: return (ctx.game_profile)(value, buffer, offset)
              case 29: return (ctx.game_profile)(value, buffer, offset)
              case 31: return (ctx.game_profile)(value, buffer, offset)
              case 33: return (ctx.game_profile)(value, buffer, offset)
              case 35: return (ctx.game_profile)(value, buffer, offset)
              case 37: return (ctx.game_profile)(value, buffer, offset)
              case 39: return (ctx.game_profile)(value, buffer, offset)
              case 41: return (ctx.game_profile)(value, buffer, offset)
              case 43: return (ctx.game_profile)(value, buffer, offset)
              case 45: return (ctx.game_profile)(value, buffer, offset)
              case 47: return (ctx.game_profile)(value, buffer, offset)
              case 49: return (ctx.game_profile)(value, buffer, offset)
              case 51: return (ctx.game_profile)(value, buffer, offset)
              case 53: return (ctx.game_profile)(value, buffer, offset)
              case 55: return (ctx.game_profile)(value, buffer, offset)
              case 57: return (ctx.game_profile)(value, buffer, offset)
              case 59: return (ctx.game_profile)(value, buffer, offset)
              case 61: return (ctx.game_profile)(value, buffer, offset)
              case 63: return (ctx.game_profile)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(player, buffer, offset)
          let chatSession = value.chatSession
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 2: return (ctx.chat_session)(value, buffer, offset)
              case 3: return (ctx.chat_session)(value, buffer, offset)
              case 6: return (ctx.chat_session)(value, buffer, offset)
              case 7: return (ctx.chat_session)(value, buffer, offset)
              case 10: return (ctx.chat_session)(value, buffer, offset)
              case 11: return (ctx.chat_session)(value, buffer, offset)
              case 14: return (ctx.chat_session)(value, buffer, offset)
              case 15: return (ctx.chat_session)(value, buffer, offset)
              case 18: return (ctx.chat_session)(value, buffer, offset)
              case 19: return (ctx.chat_session)(value, buffer, offset)
              case 22: return (ctx.chat_session)(value, buffer, offset)
              case 23: return (ctx.chat_session)(value, buffer, offset)
              case 26: return (ctx.chat_session)(value, buffer, offset)
              case 27: return (ctx.chat_session)(value, buffer, offset)
              case 30: return (ctx.chat_session)(value, buffer, offset)
              case 31: return (ctx.chat_session)(value, buffer, offset)
              case 34: return (ctx.chat_session)(value, buffer, offset)
              case 35: return (ctx.chat_session)(value, buffer, offset)
              case 38: return (ctx.chat_session)(value, buffer, offset)
              case 39: return (ctx.chat_session)(value, buffer, offset)
              case 42: return (ctx.chat_session)(value, buffer, offset)
              case 43: return (ctx.chat_session)(value, buffer, offset)
              case 46: return (ctx.chat_session)(value, buffer, offset)
              case 47: return (ctx.chat_session)(value, buffer, offset)
              case 50: return (ctx.chat_session)(value, buffer, offset)
              case 51: return (ctx.chat_session)(value, buffer, offset)
              case 54: return (ctx.chat_session)(value, buffer, offset)
              case 55: return (ctx.chat_session)(value, buffer, offset)
              case 58: return (ctx.chat_session)(value, buffer, offset)
              case 59: return (ctx.chat_session)(value, buffer, offset)
              case 62: return (ctx.chat_session)(value, buffer, offset)
              case 63: return (ctx.chat_session)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(chatSession, buffer, offset)
          let gamemode = value.gamemode
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 4: return (ctx.varint)(value, buffer, offset)
              case 5: return (ctx.varint)(value, buffer, offset)
              case 6: return (ctx.varint)(value, buffer, offset)
              case 7: return (ctx.varint)(value, buffer, offset)
              case 12: return (ctx.varint)(value, buffer, offset)
              case 13: return (ctx.varint)(value, buffer, offset)
              case 14: return (ctx.varint)(value, buffer, offset)
              case 15: return (ctx.varint)(value, buffer, offset)
              case 20: return (ctx.varint)(value, buffer, offset)
              case 21: return (ctx.varint)(value, buffer, offset)
              case 22: return (ctx.varint)(value, buffer, offset)
              case 23: return (ctx.varint)(value, buffer, offset)
              case 28: return (ctx.varint)(value, buffer, offset)
              case 29: return (ctx.varint)(value, buffer, offset)
              case 30: return (ctx.varint)(value, buffer, offset)
              case 31: return (ctx.varint)(value, buffer, offset)
              case 36: return (ctx.varint)(value, buffer, offset)
              case 37: return (ctx.varint)(value, buffer, offset)
              case 38: return (ctx.varint)(value, buffer, offset)
              case 39: return (ctx.varint)(value, buffer, offset)
              case 44: return (ctx.varint)(value, buffer, offset)
              case 45: return (ctx.varint)(value, buffer, offset)
              case 46: return (ctx.varint)(value, buffer, offset)
              case 47: return (ctx.varint)(value, buffer, offset)
              case 52: return (ctx.varint)(value, buffer, offset)
              case 53: return (ctx.varint)(value, buffer, offset)
              case 54: return (ctx.varint)(value, buffer, offset)
              case 55: return (ctx.varint)(value, buffer, offset)
              case 60: return (ctx.varint)(value, buffer, offset)
              case 61: return (ctx.varint)(value, buffer, offset)
              case 62: return (ctx.varint)(value, buffer, offset)
              case 63: return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(gamemode, buffer, offset)
          let listed = value.listed
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 8: return (ctx.bool)(value, buffer, offset)
              case 9: return (ctx.bool)(value, buffer, offset)
              case 10: return (ctx.bool)(value, buffer, offset)
              case 11: return (ctx.bool)(value, buffer, offset)
              case 12: return (ctx.bool)(value, buffer, offset)
              case 13: return (ctx.bool)(value, buffer, offset)
              case 14: return (ctx.bool)(value, buffer, offset)
              case 15: return (ctx.bool)(value, buffer, offset)
              case 24: return (ctx.bool)(value, buffer, offset)
              case 25: return (ctx.bool)(value, buffer, offset)
              case 26: return (ctx.bool)(value, buffer, offset)
              case 27: return (ctx.bool)(value, buffer, offset)
              case 28: return (ctx.bool)(value, buffer, offset)
              case 29: return (ctx.bool)(value, buffer, offset)
              case 30: return (ctx.bool)(value, buffer, offset)
              case 31: return (ctx.bool)(value, buffer, offset)
              case 40: return (ctx.bool)(value, buffer, offset)
              case 41: return (ctx.bool)(value, buffer, offset)
              case 42: return (ctx.bool)(value, buffer, offset)
              case 43: return (ctx.bool)(value, buffer, offset)
              case 44: return (ctx.bool)(value, buffer, offset)
              case 45: return (ctx.bool)(value, buffer, offset)
              case 46: return (ctx.bool)(value, buffer, offset)
              case 47: return (ctx.bool)(value, buffer, offset)
              case 56: return (ctx.bool)(value, buffer, offset)
              case 57: return (ctx.bool)(value, buffer, offset)
              case 58: return (ctx.bool)(value, buffer, offset)
              case 59: return (ctx.bool)(value, buffer, offset)
              case 60: return (ctx.bool)(value, buffer, offset)
              case 61: return (ctx.bool)(value, buffer, offset)
              case 62: return (ctx.bool)(value, buffer, offset)
              case 63: return (ctx.bool)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(listed, buffer, offset)
          let latency = value.latency
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 16: return (ctx.varint)(value, buffer, offset)
              case 17: return (ctx.varint)(value, buffer, offset)
              case 18: return (ctx.varint)(value, buffer, offset)
              case 19: return (ctx.varint)(value, buffer, offset)
              case 20: return (ctx.varint)(value, buffer, offset)
              case 21: return (ctx.varint)(value, buffer, offset)
              case 22: return (ctx.varint)(value, buffer, offset)
              case 23: return (ctx.varint)(value, buffer, offset)
              case 24: return (ctx.varint)(value, buffer, offset)
              case 25: return (ctx.varint)(value, buffer, offset)
              case 26: return (ctx.varint)(value, buffer, offset)
              case 27: return (ctx.varint)(value, buffer, offset)
              case 28: return (ctx.varint)(value, buffer, offset)
              case 29: return (ctx.varint)(value, buffer, offset)
              case 30: return (ctx.varint)(value, buffer, offset)
              case 31: return (ctx.varint)(value, buffer, offset)
              case 48: return (ctx.varint)(value, buffer, offset)
              case 49: return (ctx.varint)(value, buffer, offset)
              case 50: return (ctx.varint)(value, buffer, offset)
              case 51: return (ctx.varint)(value, buffer, offset)
              case 52: return (ctx.varint)(value, buffer, offset)
              case 53: return (ctx.varint)(value, buffer, offset)
              case 54: return (ctx.varint)(value, buffer, offset)
              case 55: return (ctx.varint)(value, buffer, offset)
              case 56: return (ctx.varint)(value, buffer, offset)
              case 57: return (ctx.varint)(value, buffer, offset)
              case 58: return (ctx.varint)(value, buffer, offset)
              case 59: return (ctx.varint)(value, buffer, offset)
              case 60: return (ctx.varint)(value, buffer, offset)
              case 61: return (ctx.varint)(value, buffer, offset)
              case 62: return (ctx.varint)(value, buffer, offset)
              case 63: return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(latency, buffer, offset)
          let displayName = value.displayName
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 32: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 33: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 34: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 35: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 36: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 37: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 38: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 39: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 40: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 41: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 42: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 43: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 44: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 45: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 46: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 47: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 48: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 49: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 50: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 51: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 52: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 53: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 54: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 55: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 56: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 57: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 58: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 59: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 60: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 61: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 62: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 63: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(displayName, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(data, buffer, offset)
      return offset
    },
    packet_position: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let teleportId = value.teleportId
      offset = (ctx.varint)(teleportId, buffer, offset)
      return offset
    },
    packet_unlock_recipes: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let craftingBookOpen = value.craftingBookOpen
      offset = (ctx.bool)(craftingBookOpen, buffer, offset)
      let filteringCraftable = value.filteringCraftable
      offset = (ctx.bool)(filteringCraftable, buffer, offset)
      let smeltingBookOpen = value.smeltingBookOpen
      offset = (ctx.bool)(smeltingBookOpen, buffer, offset)
      let filteringSmeltable = value.filteringSmeltable
      offset = (ctx.bool)(filteringSmeltable, buffer, offset)
      let blastFurnaceOpen = value.blastFurnaceOpen
      offset = (ctx.bool)(blastFurnaceOpen, buffer, offset)
      let filteringBlastFurnace = value.filteringBlastFurnace
      offset = (ctx.bool)(filteringBlastFurnace, buffer, offset)
      let smokerBookOpen = value.smokerBookOpen
      offset = (ctx.bool)(smokerBookOpen, buffer, offset)
      let filteringSmoker = value.filteringSmoker
      offset = (ctx.bool)(filteringSmoker, buffer, offset)
      let recipes1 = value.recipes1
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(recipes1, buffer, offset)
      let recipes2 = value.recipes2
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(recipes2, buffer, offset)
      return offset
    },
    packet_entity_destroy: (value, buffer, offset) => {
      let entityIds = value.entityIds
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(entityIds, buffer, offset)
      return offset
    },
    packet_remove_entity_effect: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let effectId = value.effectId
      offset = (ctx.varint)(effectId, buffer, offset)
      return offset
    },
    packet_resource_pack_send: (value, buffer, offset) => {
      let url = value.url
      offset = (ctx.string)(url, buffer, offset)
      let hash = value.hash
      offset = (ctx.string)(hash, buffer, offset)
      let forced = value.forced
      offset = (ctx.bool)(forced, buffer, offset)
      let promptMessage = value.promptMessage
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(promptMessage, buffer, offset)
      return offset
    },
    packet_respawn: (value, buffer, offset) => {
      let dimension = value.dimension
      offset = (ctx.string)(dimension, buffer, offset)
      let worldName = value.worldName
      offset = (ctx.string)(worldName, buffer, offset)
      let hashedSeed = value.hashedSeed
      offset = (ctx.i64)(hashedSeed, buffer, offset)
      let gamemode = value.gamemode
      offset = (ctx.i8)(gamemode, buffer, offset)
      let previousGamemode = value.previousGamemode
      offset = (ctx.u8)(previousGamemode, buffer, offset)
      let isDebug = value.isDebug
      offset = (ctx.bool)(isDebug, buffer, offset)
      let isFlat = value.isFlat
      offset = (ctx.bool)(isFlat, buffer, offset)
      let copyMetadata = value.copyMetadata
      offset = (ctx.bool)(copyMetadata, buffer, offset)
      let death = value.death
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          let dimensionName = value.dimensionName
          offset = (ctx.string)(dimensionName, buffer, offset)
          let location1 = value.location
          offset = (ctx.position)(location1, buffer, offset)
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(death, buffer, offset)
      return offset
    },
    packet_entity_head_rotation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let headYaw = value.headYaw
      offset = (ctx.i8)(headYaw, buffer, offset)
      return offset
    },
    packet_camera: (value, buffer, offset) => {
      let cameraId = value.cameraId
      offset = (ctx.varint)(cameraId, buffer, offset)
      return offset
    },
    packet_held_item_slot: (value, buffer, offset) => {
      let slot = value.slot
      offset = (ctx.i8)(slot, buffer, offset)
      return offset
    },
    packet_update_view_position: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.varint)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.varint)(chunkZ, buffer, offset)
      return offset
    },
    packet_update_view_distance: (value, buffer, offset) => {
      let viewDistance = value.viewDistance
      offset = (ctx.varint)(viewDistance, buffer, offset)
      return offset
    },
    packet_scoreboard_display_objective: (value, buffer, offset) => {
      let position = value.position
      offset = (ctx.i8)(position, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      return offset
    },
    packet_entity_metadata: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let metadata = value.metadata
      offset = (ctx.entityMetadata)(metadata, buffer, offset)
      return offset
    },
    packet_attach_entity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let vehicleId = value.vehicleId
      offset = (ctx.i32)(vehicleId, buffer, offset)
      return offset
    },
    packet_entity_velocity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let velocityX = value.velocityX
      offset = (ctx.i16)(velocityX, buffer, offset)
      let velocityY = value.velocityY
      offset = (ctx.i16)(velocityY, buffer, offset)
      let velocityZ = value.velocityZ
      offset = (ctx.i16)(velocityZ, buffer, offset)
      return offset
    },
    packet_entity_equipment: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let equipments = value.equipments
      offset = ((value, buffer, offset) => {
        let prevOffset = offset
        let ind = 0
        for (const i in value) {
          prevOffset = offset
          offset = ((value, buffer, offset) => {
          let slot1 = value.slot
          offset = (ctx.i8)(slot1, buffer, offset)
          let item1 = value.item
          offset = (ctx.slot)(item1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
          buffer[prevOffset] = ind !== value.length-1 ? (buffer[prevOffset] | 128) : buffer[prevOffset]
          ind++
        }
        return offset
      })(equipments, buffer, offset)
      return offset
    },
    packet_experience: (value, buffer, offset) => {
      let experienceBar = value.experienceBar
      offset = (ctx.f32)(experienceBar, buffer, offset)
      let totalExperience = value.totalExperience
      offset = (ctx.varint)(totalExperience, buffer, offset)
      let level = value.level
      offset = (ctx.varint)(level, buffer, offset)
      return offset
    },
    packet_update_health: (value, buffer, offset) => {
      let health = value.health
      offset = (ctx.f32)(health, buffer, offset)
      let food = value.food
      offset = (ctx.varint)(food, buffer, offset)
      let foodSaturation = value.foodSaturation
      offset = (ctx.f32)(foodSaturation, buffer, offset)
      return offset
    },
    packet_scoreboard_objective: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let action = value.action
      offset = (ctx.i8)(action, buffer, offset)
      let displayText = value.displayText
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(displayText, buffer, offset)
      let type = value.type
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 2: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(type, buffer, offset)
      return offset
    },
    packet_set_passengers: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let passengers = value.passengers
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(passengers, buffer, offset)
      return offset
    },
    packet_teams: (value, buffer, offset) => {
      let team = value.team
      offset = (ctx.string)(team, buffer, offset)
      let mode = value.mode
      offset = (ctx.i8)(mode, buffer, offset)
      let name = value.name
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(name, buffer, offset)
      let friendlyFire = value.friendlyFire
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.i8)(value, buffer, offset)
          case 2: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(friendlyFire, buffer, offset)
      let nameTagVisibility = value.nameTagVisibility
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nameTagVisibility, buffer, offset)
      let collisionRule = value.collisionRule
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(collisionRule, buffer, offset)
      let formatting = value.formatting
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 2: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(formatting, buffer, offset)
      let prefix = value.prefix
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(prefix, buffer, offset)
      let suffix = value.suffix
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(suffix, buffer, offset)
      let players = value.players
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          case 3: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          case 4: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(players, buffer, offset)
      return offset
    },
    packet_scoreboard_score: (value, buffer, offset) => {
      let itemName = value.itemName
      offset = (ctx.string)(itemName, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let scoreName = value.scoreName
      offset = (ctx.string)(scoreName, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 1: return (ctx.void)(value, buffer, offset)
          default: return (ctx.varint)(value, buffer, offset)
        }
      })(value1, buffer, offset)
      return offset
    },
    packet_spawn_position: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let angle = value.angle
      offset = (ctx.f32)(angle, buffer, offset)
      return offset
    },
    packet_update_time: (value, buffer, offset) => {
      let age = value.age
      offset = (ctx.i64)(age, buffer, offset)
      let time = value.time
      offset = (ctx.i64)(time, buffer, offset)
      return offset
    },
    packet_entity_sound_effect: (value, buffer, offset) => {
      let soundId = value.soundId
      offset = (ctx.varint)(soundId, buffer, offset)
      let soundEvent = value.soundEvent
      offset = ((value, buffer, offset) => {
        switch (soundId) {
          case 0: return ((value, buffer, offset) => {
            let resource = value.resource
            offset = (ctx.string)(resource, buffer, offset)
            let range = value.range
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.f32)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(range, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(soundEvent, buffer, offset)
      let soundCategory = value.soundCategory
      offset = (ctx.varint)(soundCategory, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let volume = value.volume
      offset = (ctx.f32)(volume, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let seed = value.seed
      offset = (ctx.i64)(seed, buffer, offset)
      return offset
    },
    packet_stop_sound: (value, buffer, offset) => {
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let source = value.source
      offset = ((value, buffer, offset) => {
        switch (flags) {
          case 1: return (ctx.varint)(value, buffer, offset)
          case 3: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(source, buffer, offset)
      let sound = value.sound
      offset = ((value, buffer, offset) => {
        switch (flags) {
          case 2: return (ctx.string)(value, buffer, offset)
          case 3: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(sound, buffer, offset)
      return offset
    },
    packet_sound_effect: (value, buffer, offset) => {
      let soundId = value.soundId
      offset = (ctx.varint)(soundId, buffer, offset)
      let soundEvent = value.soundEvent
      offset = ((value, buffer, offset) => {
        switch (soundId) {
          case 0: return ((value, buffer, offset) => {
            let resource = value.resource
            offset = (ctx.string)(resource, buffer, offset)
            let range = value.range
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.f32)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(range, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(soundEvent, buffer, offset)
      let soundCategory = value.soundCategory
      offset = (ctx.varint)(soundCategory, buffer, offset)
      let x = value.x
      offset = (ctx.i32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.i32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.i32)(z, buffer, offset)
      let volume = value.volume
      offset = (ctx.f32)(volume, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let seed = value.seed
      offset = (ctx.i64)(seed, buffer, offset)
      return offset
    },
    packet_system_chat: (value, buffer, offset) => {
      let content = value.content
      offset = (ctx.string)(content, buffer, offset)
      let isActionBar = value.isActionBar
      offset = (ctx.bool)(isActionBar, buffer, offset)
      return offset
    },
    packet_playerlist_header: (value, buffer, offset) => {
      let header = value.header
      offset = (ctx.string)(header, buffer, offset)
      let footer = value.footer
      offset = (ctx.string)(footer, buffer, offset)
      return offset
    },
    packet_collect: (value, buffer, offset) => {
      let collectedEntityId = value.collectedEntityId
      offset = (ctx.varint)(collectedEntityId, buffer, offset)
      let collectorEntityId = value.collectorEntityId
      offset = (ctx.varint)(collectorEntityId, buffer, offset)
      let pickupItemCount = value.pickupItemCount
      offset = (ctx.varint)(pickupItemCount, buffer, offset)
      return offset
    },
    packet_entity_teleport: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_update_attributes: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value2 = value.value
          offset = (ctx.f64)(value2, buffer, offset)
          let modifiers = value.modifiers
          offset = ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = ((value, buffer, offset) => {
              let uuid = value.uuid
              offset = (ctx.UUID)(uuid, buffer, offset)
              let amount = value.amount
              offset = (ctx.f64)(amount, buffer, offset)
              let operation = value.operation
              offset = (ctx.i8)(operation, buffer, offset)
              return offset
            })(value[i], buffer, offset)
            }
            return offset
          })(modifiers, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    packet_feature_flags: (value, buffer, offset) => {
      let features = value.features
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(features, buffer, offset)
      return offset
    },
    packet_entity_effect: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let effectId = value.effectId
      offset = (ctx.varint)(effectId, buffer, offset)
      let amplifier = value.amplifier
      offset = (ctx.i8)(amplifier, buffer, offset)
      let duration = value.duration
      offset = (ctx.varint)(duration, buffer, offset)
      let hideParticles = value.hideParticles
      offset = (ctx.i8)(hideParticles, buffer, offset)
      let factorCodec = value.factorCodec
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.nbt)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(factorCodec, buffer, offset)
      return offset
    },
    packet_select_advancement_tab: (value, buffer, offset) => {
      let id = value.id
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(id, buffer, offset)
      return offset
    },
    packet_server_data: (value, buffer, offset) => {
      let motd = value.motd
      offset = (ctx.string)(motd, buffer, offset)
      let iconBytes = value.iconBytes
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          if (!(value instanceof Buffer)) value = Buffer.from(value)
          offset = (ctx.varint)(value.length, buffer, offset)
          value.copy(buffer, offset)
          return offset + value.length
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(iconBytes, buffer, offset)
      let enforcesSecureChat = value.enforcesSecureChat
      offset = (ctx.bool)(enforcesSecureChat, buffer, offset)
      return offset
    },
    packet_declare_recipes: (value, buffer, offset) => {
      let recipes = value.recipes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let type1 = value.type
          offset = (ctx.string)(type1, buffer, offset)
          let recipeId = value.recipeId
          offset = (ctx.string)(recipeId, buffer, offset)
          let data1 = value.data
          offset = ((value, buffer, offset) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((value, buffer, offset) => {
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let category1 = value.category
                offset = (ctx.varint)(category1, buffer, offset)
                let ingredients = value.ingredients
                offset = ((value, buffer, offset) => {
                  offset = (ctx.varint)(value.length, buffer, offset)
                  for (let i = 0; i < value.length; i++) {
                    offset = (ctx.ingredient)(value[i], buffer, offset)
                  }
                  return offset
                })(ingredients, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_shaped": return ((value, buffer, offset) => {
                let width = value.width
                offset = (ctx.varint)(width, buffer, offset)
                let height = value.height
                offset = (ctx.varint)(height, buffer, offset)
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let category1 = value.category
                offset = (ctx.varint)(category1, buffer, offset)
                let ingredients = value.ingredients
                offset = ((value, buffer, offset) => {
                  for (let i = 0; i < value.length; i++) {
                    offset = ((value, buffer, offset) => {
                    for (let i = 0; i < value.length; i++) {
                      offset = (ctx.ingredient)(value[i], buffer, offset)
                    }
                    return offset
                  })(value[i], buffer, offset)
                  }
                  return offset
                })(ingredients, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                let showNotification = value.showNotification
                offset = (ctx.bool)(showNotification, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:stonecutting": return ((value, buffer, offset) => {
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let ingredient1 = value.ingredient
                offset = (ctx.ingredient)(ingredient1, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing": return ((value, buffer, offset) => {
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing_transform": return ((value, buffer, offset) => {
                let template = value.template
                offset = (ctx.ingredient)(template, buffer, offset)
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing_trim": return ((value, buffer, offset) => {
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(data1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(recipes, buffer, offset)
      return offset
    },
    packet_tags: (value, buffer, offset) => {
      let tags = value.tags
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let tagType = value.tagType
          offset = (ctx.string)(tagType, buffer, offset)
          let tags1 = value.tags
          offset = (ctx.tags)(tags1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(tags, buffer, offset)
      return offset
    },
    packet_acknowledge_player_digging: (value, buffer, offset) => {
      let sequenceId = value.sequenceId
      offset = (ctx.varint)(sequenceId, buffer, offset)
      return offset
    },
    packet_clear_titles: (value, buffer, offset) => {
      let reset = value.reset
      offset = (ctx.bool)(reset, buffer, offset)
      return offset
    },
    packet_initialize_world_border: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let oldDiameter = value.oldDiameter
      offset = (ctx.f64)(oldDiameter, buffer, offset)
      let newDiameter = value.newDiameter
      offset = (ctx.f64)(newDiameter, buffer, offset)
      let speed = value.speed
      offset = (ctx.varint)(speed, buffer, offset)
      let portalTeleportBoundary = value.portalTeleportBoundary
      offset = (ctx.varint)(portalTeleportBoundary, buffer, offset)
      let warningBlocks = value.warningBlocks
      offset = (ctx.varint)(warningBlocks, buffer, offset)
      let warningTime = value.warningTime
      offset = (ctx.varint)(warningTime, buffer, offset)
      return offset
    },
    packet_action_bar: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_world_border_center: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    packet_world_border_lerp_size: (value, buffer, offset) => {
      let oldDiameter = value.oldDiameter
      offset = (ctx.f64)(oldDiameter, buffer, offset)
      let newDiameter = value.newDiameter
      offset = (ctx.f64)(newDiameter, buffer, offset)
      let speed = value.speed
      offset = (ctx.varint)(speed, buffer, offset)
      return offset
    },
    packet_world_border_size: (value, buffer, offset) => {
      let diameter = value.diameter
      offset = (ctx.f64)(diameter, buffer, offset)
      return offset
    },
    packet_world_border_warning_delay: (value, buffer, offset) => {
      let warningTime = value.warningTime
      offset = (ctx.varint)(warningTime, buffer, offset)
      return offset
    },
    packet_world_border_warning_reach: (value, buffer, offset) => {
      let warningBlocks = value.warningBlocks
      offset = (ctx.varint)(warningBlocks, buffer, offset)
      return offset
    },
    packet_ping: (value, buffer, offset) => {
      let id = value.id
      offset = (ctx.i32)(id, buffer, offset)
      return offset
    },
    packet_set_title_subtitle: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_set_title_text: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_set_title_time: (value, buffer, offset) => {
      let fadeIn = value.fadeIn
      offset = (ctx.i32)(fadeIn, buffer, offset)
      let stay = value.stay
      offset = (ctx.i32)(stay, buffer, offset)
      let fadeOut = value.fadeOut
      offset = (ctx.i32)(fadeOut, buffer, offset)
      return offset
    },
    packet_simulation_distance: (value, buffer, offset) => {
      let distance = value.distance
      offset = (ctx.varint)(distance, buffer, offset)
      return offset
    },
    packet_chunk_biomes: (value, buffer, offset) => {
      let biomes = value.biomes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let position1 = value.position
          offset = (ctx.position)(position1, buffer, offset)
          let data1 = value.data
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(data1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(biomes, buffer, offset)
      return offset
    },
    packet_damage_event: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let sourceTypeId = value.sourceTypeId
      offset = (ctx.varint)(sourceTypeId, buffer, offset)
      let sourceCauseId = value.sourceCauseId
      offset = (ctx.varint)(sourceCauseId, buffer, offset)
      let sourceDirectId = value.sourceDirectId
      offset = (ctx.varint)(sourceDirectId, buffer, offset)
      let sourcePosition = value.sourcePosition
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.vec3f64)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(sourcePosition, buffer, offset)
      return offset
    },
    packet_hurt_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"bundle_delimiter":0,"spawn_entity":1,"spawn_entity_experience_orb":2,"named_entity_spawn":3,"animation":4,"statistics":5,"acknowledge_player_digging":6,"block_break_animation":7,"tile_entity_data":8,"block_action":9,"block_change":10,"boss_bar":11,"difficulty":12,"chunk_biomes":13,"clear_titles":14,"tab_complete":15,"declare_commands":16,"close_window":17,"window_items":18,"craft_progress_bar":19,"set_slot":20,"set_cooldown":21,"chat_suggestions":22,"custom_payload":23,"damage_event":24,"hide_message":25,"kick_disconnect":26,"profileless_chat":27,"entity_status":28,"explosion":29,"unload_chunk":30,"game_state_change":31,"open_horse_window":32,"hurt_animation":33,"initialize_world_border":34,"keep_alive":35,"map_chunk":36,"world_event":37,"world_particles":38,"update_light":39,"login":40,"map":41,"trade_list":42,"rel_entity_move":43,"entity_move_look":44,"entity_look":45,"vehicle_move":46,"open_book":47,"open_window":48,"open_sign_entity":49,"ping":50,"craft_recipe_response":51,"abilities":52,"player_chat":53,"end_combat_event":54,"enter_combat_event":55,"death_combat_event":56,"player_remove":57,"player_info":58,"face_player":59,"position":60,"unlock_recipes":61,"entity_destroy":62,"remove_entity_effect":63,"resource_pack_send":64,"respawn":65,"entity_head_rotation":66,"multi_block_change":67,"select_advancement_tab":68,"server_data":69,"action_bar":70,"world_border_center":71,"world_border_lerp_size":72,"world_border_size":73,"world_border_warning_delay":74,"world_border_warning_reach":75,"camera":76,"held_item_slot":77,"update_view_position":78,"update_view_distance":79,"spawn_position":80,"scoreboard_display_objective":81,"entity_metadata":82,"attach_entity":83,"entity_velocity":84,"entity_equipment":85,"experience":86,"update_health":87,"scoreboard_objective":88,"set_passengers":89,"teams":90,"scoreboard_score":91,"simulation_distance":92,"set_title_subtitle":93,"update_time":94,"set_title_text":95,"set_title_time":96,"entity_sound_effect":97,"sound_effect":98,"stop_sound":99,"system_chat":100,"playerlist_header":101,"nbt_query_response":102,"collect":103,"entity_teleport":104,"advancements":105,"entity_update_attributes":106,"feature_flags":107,"entity_effect":108,"declare_recipes":109,"tags":110}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(value, buffer, offset)
          case "spawn_entity": return (ctx.packet_spawn_entity)(value, buffer, offset)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(value, buffer, offset)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(value, buffer, offset)
          case "animation": return (ctx.packet_animation)(value, buffer, offset)
          case "statistics": return (ctx.packet_statistics)(value, buffer, offset)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(value, buffer, offset)
          case "block_break_animation": return (ctx.packet_block_break_animation)(value, buffer, offset)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(value, buffer, offset)
          case "block_action": return (ctx.packet_block_action)(value, buffer, offset)
          case "block_change": return (ctx.packet_block_change)(value, buffer, offset)
          case "boss_bar": return (ctx.packet_boss_bar)(value, buffer, offset)
          case "difficulty": return (ctx.packet_difficulty)(value, buffer, offset)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(value, buffer, offset)
          case "clear_titles": return (ctx.packet_clear_titles)(value, buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(value, buffer, offset)
          case "declare_commands": return (ctx.packet_declare_commands)(value, buffer, offset)
          case "close_window": return (ctx.packet_close_window)(value, buffer, offset)
          case "window_items": return (ctx.packet_window_items)(value, buffer, offset)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(value, buffer, offset)
          case "set_slot": return (ctx.packet_set_slot)(value, buffer, offset)
          case "set_cooldown": return (ctx.packet_set_cooldown)(value, buffer, offset)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(value, buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(value, buffer, offset)
          case "damage_event": return (ctx.packet_damage_event)(value, buffer, offset)
          case "hide_message": return (ctx.packet_hide_message)(value, buffer, offset)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(value, buffer, offset)
          case "profileless_chat": return (ctx.packet_profileless_chat)(value, buffer, offset)
          case "entity_status": return (ctx.packet_entity_status)(value, buffer, offset)
          case "explosion": return (ctx.packet_explosion)(value, buffer, offset)
          case "unload_chunk": return (ctx.packet_unload_chunk)(value, buffer, offset)
          case "game_state_change": return (ctx.packet_game_state_change)(value, buffer, offset)
          case "open_horse_window": return (ctx.packet_open_horse_window)(value, buffer, offset)
          case "hurt_animation": return (ctx.packet_hurt_animation)(value, buffer, offset)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(value, buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(value, buffer, offset)
          case "map_chunk": return (ctx.packet_map_chunk)(value, buffer, offset)
          case "world_event": return (ctx.packet_world_event)(value, buffer, offset)
          case "world_particles": return (ctx.packet_world_particles)(value, buffer, offset)
          case "update_light": return (ctx.packet_update_light)(value, buffer, offset)
          case "login": return (ctx.packet_login)(value, buffer, offset)
          case "map": return (ctx.packet_map)(value, buffer, offset)
          case "trade_list": return (ctx.packet_trade_list)(value, buffer, offset)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(value, buffer, offset)
          case "entity_move_look": return (ctx.packet_entity_move_look)(value, buffer, offset)
          case "entity_look": return (ctx.packet_entity_look)(value, buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value, buffer, offset)
          case "open_book": return (ctx.packet_open_book)(value, buffer, offset)
          case "open_window": return (ctx.packet_open_window)(value, buffer, offset)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(value, buffer, offset)
          case "ping": return (ctx.packet_ping)(value, buffer, offset)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(value, buffer, offset)
          case "abilities": return (ctx.packet_abilities)(value, buffer, offset)
          case "player_chat": return (ctx.packet_player_chat)(value, buffer, offset)
          case "end_combat_event": return (ctx.packet_end_combat_event)(value, buffer, offset)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(value, buffer, offset)
          case "death_combat_event": return (ctx.packet_death_combat_event)(value, buffer, offset)
          case "player_remove": return (ctx.packet_player_remove)(value, buffer, offset)
          case "player_info": return (ctx.packet_player_info)(value, buffer, offset)
          case "face_player": return (ctx.packet_face_player)(value, buffer, offset)
          case "position": return (ctx.packet_position)(value, buffer, offset)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(value, buffer, offset)
          case "entity_destroy": return (ctx.packet_entity_destroy)(value, buffer, offset)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(value, buffer, offset)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(value, buffer, offset)
          case "respawn": return (ctx.packet_respawn)(value, buffer, offset)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(value, buffer, offset)
          case "multi_block_change": return (ctx.packet_multi_block_change)(value, buffer, offset)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(value, buffer, offset)
          case "server_data": return (ctx.packet_server_data)(value, buffer, offset)
          case "action_bar": return (ctx.packet_action_bar)(value, buffer, offset)
          case "world_border_center": return (ctx.packet_world_border_center)(value, buffer, offset)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(value, buffer, offset)
          case "world_border_size": return (ctx.packet_world_border_size)(value, buffer, offset)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(value, buffer, offset)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(value, buffer, offset)
          case "camera": return (ctx.packet_camera)(value, buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value, buffer, offset)
          case "update_view_position": return (ctx.packet_update_view_position)(value, buffer, offset)
          case "update_view_distance": return (ctx.packet_update_view_distance)(value, buffer, offset)
          case "spawn_position": return (ctx.packet_spawn_position)(value, buffer, offset)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(value, buffer, offset)
          case "entity_metadata": return (ctx.packet_entity_metadata)(value, buffer, offset)
          case "attach_entity": return (ctx.packet_attach_entity)(value, buffer, offset)
          case "entity_velocity": return (ctx.packet_entity_velocity)(value, buffer, offset)
          case "entity_equipment": return (ctx.packet_entity_equipment)(value, buffer, offset)
          case "experience": return (ctx.packet_experience)(value, buffer, offset)
          case "update_health": return (ctx.packet_update_health)(value, buffer, offset)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(value, buffer, offset)
          case "set_passengers": return (ctx.packet_set_passengers)(value, buffer, offset)
          case "teams": return (ctx.packet_teams)(value, buffer, offset)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(value, buffer, offset)
          case "simulation_distance": return (ctx.packet_simulation_distance)(value, buffer, offset)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(value, buffer, offset)
          case "update_time": return (ctx.packet_update_time)(value, buffer, offset)
          case "set_title_text": return (ctx.packet_set_title_text)(value, buffer, offset)
          case "set_title_time": return (ctx.packet_set_title_time)(value, buffer, offset)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(value, buffer, offset)
          case "sound_effect": return (ctx.packet_sound_effect)(value, buffer, offset)
          case "stop_sound": return (ctx.packet_stop_sound)(value, buffer, offset)
          case "system_chat": return (ctx.packet_system_chat)(value, buffer, offset)
          case "playerlist_header": return (ctx.packet_playerlist_header)(value, buffer, offset)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(value, buffer, offset)
          case "collect": return (ctx.packet_collect)(value, buffer, offset)
          case "entity_teleport": return (ctx.packet_entity_teleport)(value, buffer, offset)
          case "advancements": return (ctx.packet_advancements)(value, buffer, offset)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(value, buffer, offset)
          case "feature_flags": return (ctx.packet_feature_flags)(value, buffer, offset)
          case "entity_effect": return (ctx.packet_entity_effect)(value, buffer, offset)
          case "declare_recipes": return (ctx.packet_declare_recipes)(value, buffer, offset)
          case "tags": return (ctx.packet_tags)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_spawn_entity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: objectUUID, size: objectUUIDSize } = (ctx.UUID)(buffer, offset + entityIdSize)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + entityIdSize + objectUUIDSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize)
      let { value: headPitch, size: headPitchSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize)
      let { value: objectData, size: objectDataSize } = (ctx.varint)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize)
      let { value: velocityX, size: velocityXSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize)
      let { value: velocityY, size: velocityYSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize)
      let { value: velocityZ, size: velocityZSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize + velocityYSize)
      return { value: { entityId, objectUUID, type, x, y, z, pitch, yaw, headPitch, objectData, velocityX, velocityY, velocityZ }, size: entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize + velocityYSize + velocityZSize}
    },
    packet_spawn_entity_experience_orb: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + xSize + ySize)
      let { value: count, size: countSize } = (ctx.i16)(buffer, offset + entityIdSize + xSize + ySize + zSize)
      return { value: { entityId, x, y, z, count }, size: entityIdSize + xSize + ySize + zSize + countSize}
    },
    packet_named_entity_spawn: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: playerUUID, size: playerUUIDSize } = (ctx.UUID)(buffer, offset + entityIdSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize + zSize + yawSize)
      return { value: { entityId, playerUUID, x, y, z, yaw, pitch }, size: entityIdSize + playerUUIDSize + xSize + ySize + zSize + yawSize + pitchSize}
    },
    packet_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: animation, size: animationSize } = (ctx.u8)(buffer, offset + entityIdSize)
      return { value: { entityId, animation }, size: entityIdSize + animationSize}
    },
    packet_statistics: (buffer, offset) => {
      let { value: entries, size: entriesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: categoryId, size: categoryIdSize } = (ctx.varint)(buffer, offset)
          let { value: statisticId, size: statisticIdSize } = (ctx.varint)(buffer, offset + categoryIdSize)
          let { value: value1, size: value1Size } = (ctx.varint)(buffer, offset + categoryIdSize + statisticIdSize)
          return { value: { categoryId, statisticId, value: value1 }, size: categoryIdSize + statisticIdSize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { entries }, size: entriesSize}
    },
    packet_advancements: (buffer, offset) => {
      let { value: reset, size: resetSize } = (ctx.bool)(buffer, offset)
      let { value: advancementMapping, size: advancementMappingSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = ((buffer, offset) => {
            let { value: parentId, size: parentIdSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.string)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset)
            let { value: displayData, size: displayDataSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = ((buffer, offset) => {
                let { value: title, size: titleSize } = (ctx.string)(buffer, offset)
                let { value: description, size: descriptionSize } = (ctx.string)(buffer, offset + titleSize)
                let { value: icon, size: iconSize } = (ctx.slot)(buffer, offset + titleSize + descriptionSize)
                let { value: frameType, size: frameTypeSize } = (ctx.varint)(buffer, offset + titleSize + descriptionSize + iconSize)
                let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                  if ( offset + 4 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  let _unused = (bits >> 3) & 0x1fffffff
                  let hidden = (bits >> 2) & 0x1
                  let show_toast = (bits >> 1) & 0x1
                  let has_background_texture = (bits >> 0) & 0x1
                  return { value: { _unused, hidden, show_toast, has_background_texture }, size: 4 }
                })(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize)
                let { value: backgroundTexture, size: backgroundTextureSize } = ((buffer, offset) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(buffer, offset)
                    default: return (ctx.void)(buffer, offset)
                  }
                })(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size)
                let { value: xCord, size: xCordSize } = (ctx.f32)(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize)
                let { value: yCord, size: yCordSize } = (ctx.f32)(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize + xCordSize)
                return { value: { title, description, icon, frameType, flags: flags1, backgroundTexture, xCord, yCord }, size: titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize + xCordSize + yCordSize}
              })(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + parentIdSize)
            let { value: criteria, size: criteriaSize } = ((buffer, offset) => {
              const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
              if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
              const data = []
              let size = countSize
              for (let i = 0; i < count; i++) {
                const elem = ((buffer, offset) => {
                let { value: key1, size: key1Size } = (ctx.string)(buffer, offset)
                let { value: value2, size: value2Size } = (ctx.void)(buffer, offset + key1Size)
                return { value: { key: key1, value: value2 }, size: key1Size + value2Size}
              })(buffer, offset + size)
                data.push(elem.value)
                size += elem.size
              }
              return { value: data, size }
            })(buffer, offset + parentIdSize + displayDataSize)
            let { value: requirements, size: requirementsSize } = ((buffer, offset) => {
              const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
              if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
              const data = []
              let size = countSize
              for (let i = 0; i < count; i++) {
                const elem = ((buffer, offset) => {
                const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
                if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                const data = []
                let size = countSize
                for (let i = 0; i < count; i++) {
                  const elem = (ctx.string)(buffer, offset + size)
                  data.push(elem.value)
                  size += elem.size
                }
                return { value: data, size }
              })(buffer, offset + size)
                data.push(elem.value)
                size += elem.size
              }
              return { value: data, size }
            })(buffer, offset + parentIdSize + displayDataSize + criteriaSize)
            return { value: { parentId, displayData, criteria, requirements }, size: parentIdSize + displayDataSize + criteriaSize + requirementsSize}
          })(buffer, offset + keySize)
          return { value: { key, value: value1 }, size: keySize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize)
      let { value: identifiers, size: identifiersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize + advancementMappingSize)
      let { value: progressMapping, size: progressMappingSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = ((buffer, offset) => {
              let { value: criterionIdentifier, size: criterionIdentifierSize } = (ctx.string)(buffer, offset)
              let { value: criterionProgress, size: criterionProgressSize } = ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.i64)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset + criterionIdentifierSize)
              return { value: { criterionIdentifier, criterionProgress }, size: criterionIdentifierSize + criterionProgressSize}
            })(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset + keySize)
          return { value: { key, value: value1 }, size: keySize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize + advancementMappingSize + identifiersSize)
      return { value: { reset, advancementMapping, identifiers, progressMapping }, size: resetSize + advancementMappingSize + identifiersSize + progressMappingSize}
    },
    packet_block_break_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + entityIdSize)
      let { value: destroyStage, size: destroyStageSize } = (ctx.i8)(buffer, offset + entityIdSize + locationSize)
      return { value: { entityId, location, destroyStage }, size: entityIdSize + locationSize + destroyStageSize}
    },
    packet_tile_entity_data: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + locationSize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + locationSize + actionSize)
      return { value: { location, action, nbtData }, size: locationSize + actionSize + nbtDataSize}
    },
    packet_block_action: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: byte1, size: byte1Size } = (ctx.u8)(buffer, offset + locationSize)
      let { value: byte2, size: byte2Size } = (ctx.u8)(buffer, offset + locationSize + byte1Size)
      let { value: blockId, size: blockIdSize } = (ctx.varint)(buffer, offset + locationSize + byte1Size + byte2Size)
      return { value: { location, byte1, byte2, blockId }, size: locationSize + byte1Size + byte2Size + blockIdSize}
    },
    packet_block_change: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + locationSize)
      return { value: { location, type }, size: locationSize + typeSize}
    },
    packet_boss_bar: (buffer, offset) => {
      let { value: entityUUID, size: entityUUIDSize } = (ctx.UUID)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + entityUUIDSize)
      let { value: title, size: titleSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(buffer, offset)
          case 3: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize)
      let { value: health, size: healthSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.f32)(buffer, offset)
          case 2: return (ctx.f32)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize)
      let { value: color, size: colorSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 4: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize)
      let { value: dividers, size: dividersSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 4: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize + colorSize)
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.u8)(buffer, offset)
          case 5: return (ctx.u8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize + colorSize + dividersSize)
      return { value: { entityUUID, action, title, health, color, dividers, flags }, size: entityUUIDSize + actionSize + titleSize + healthSize + colorSize + dividersSize + flagsSize}
    },
    packet_difficulty: (buffer, offset) => {
      let { value: difficulty, size: difficultySize } = (ctx.u8)(buffer, offset)
      let { value: difficultyLocked, size: difficultyLockedSize } = (ctx.bool)(buffer, offset + difficultySize)
      return { value: { difficulty, difficultyLocked }, size: difficultySize + difficultyLockedSize}
    },
    packet_tab_complete: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: start, size: startSize } = (ctx.varint)(buffer, offset + transactionIdSize)
      let { value: length, size: lengthSize } = (ctx.varint)(buffer, offset + transactionIdSize + startSize)
      let { value: matches, size: matchesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: match, size: matchSize } = (ctx.string)(buffer, offset)
          let { value: tooltip, size: tooltipSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + matchSize)
          return { value: { match, tooltip }, size: matchSize + tooltipSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + transactionIdSize + startSize + lengthSize)
      return { value: { transactionId, start, length, matches }, size: transactionIdSize + startSize + lengthSize + matchesSize}
    },
    packet_declare_commands: (buffer, offset) => {
      let { value: nodes, size: nodesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.command_node)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      let { value: rootIndex, size: rootIndexSize } = (ctx.varint)(buffer, offset + nodesSize)
      return { value: { nodes, rootIndex }, size: nodesSize + rootIndexSize}
    },
    packet_face_player: (buffer, offset) => {
      let { value: feet_eyes, size: feet_eyesSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + feet_eyesSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + feet_eyesSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + feet_eyesSize + xSize + ySize)
      let { value: isEntity, size: isEntitySize } = (ctx.bool)(buffer, offset + feet_eyesSize + xSize + ySize + zSize)
      let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + feet_eyesSize + xSize + ySize + zSize + isEntitySize)
      let { value: entity_feet_eyes, size: entity_feet_eyesSize } = ((buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + feet_eyesSize + xSize + ySize + zSize + isEntitySize + entityIdSize)
      return { value: { feet_eyes, x, y, z, isEntity, entityId, entity_feet_eyes }, size: feet_eyesSize + xSize + ySize + zSize + isEntitySize + entityIdSize + entity_feet_eyesSize}
    },
    packet_nbt_query_response: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: nbt, size: nbtSize } = (ctx.optionalNbt)(buffer, offset + transactionIdSize)
      return { value: { transactionId, nbt }, size: transactionIdSize + nbtSize}
    },
    packet_multi_block_change: (buffer, offset) => {
      let { value: chunkCoordinates, size: chunkCoordinatesSize } = ((buffer, offset) => {
        if ( offset + 8 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let x = (bits >> 2) & 0x3fffff
        x -= (x & 0x200000) << 1
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let z = (bits >> 4) & 0x3fffff
        z -= (z & 0x200000) << 1
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let y = (bits >> 0) & 0xfffff
        y -= (y & 0x80000) << 1
        return { value: { x, z, y }, size: 8 }
      })(buffer, offset)
      let { value: suppressLightUpdates, size: suppressLightUpdatesSize } = (ctx.bool)(buffer, offset + chunkCoordinatesSize)
      let { value: records, size: recordsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkCoordinatesSize + suppressLightUpdatesSize)
      return { value: { chunkCoordinates, suppressLightUpdates, records }, size: chunkCoordinatesSize + suppressLightUpdatesSize + recordsSize}
    },
    packet_close_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      return { value: { windowId }, size: windowIdSize}
    },
    packet_open_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.varint)(buffer, offset)
      let { value: inventoryType, size: inventoryTypeSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: windowTitle, size: windowTitleSize } = (ctx.string)(buffer, offset + windowIdSize + inventoryTypeSize)
      return { value: { windowId, inventoryType, windowTitle }, size: windowIdSize + inventoryTypeSize + windowTitleSize}
    },
    packet_window_items: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: stateId, size: stateIdSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: items, size: itemsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.slot)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + windowIdSize + stateIdSize)
      let { value: carriedItem, size: carriedItemSize } = (ctx.slot)(buffer, offset + windowIdSize + stateIdSize + itemsSize)
      return { value: { windowId, stateId, items, carriedItem }, size: windowIdSize + stateIdSize + itemsSize + carriedItemSize}
    },
    packet_craft_progress_bar: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: property, size: propertySize } = (ctx.i16)(buffer, offset + windowIdSize)
      let { value: value1, size: value1Size } = (ctx.i16)(buffer, offset + windowIdSize + propertySize)
      return { value: { windowId, property, value: value1 }, size: windowIdSize + propertySize + value1Size}
    },
    packet_set_slot: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: stateId, size: stateIdSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: slot, size: slotSize } = (ctx.i16)(buffer, offset + windowIdSize + stateIdSize)
      let { value: item, size: itemSize } = (ctx.slot)(buffer, offset + windowIdSize + stateIdSize + slotSize)
      return { value: { windowId, stateId, slot, item }, size: windowIdSize + stateIdSize + slotSize + itemSize}
    },
    packet_set_cooldown: (buffer, offset) => {
      let { value: itemID, size: itemIDSize } = (ctx.varint)(buffer, offset)
      let { value: cooldownTicks, size: cooldownTicksSize } = (ctx.varint)(buffer, offset + itemIDSize)
      return { value: { itemID, cooldownTicks }, size: itemIDSize + cooldownTicksSize}
    },
    packet_chat_suggestions: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset)
      let { value: entries, size: entriesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize)
      return { value: { action, entries }, size: actionSize + entriesSize}
    },
    packet_custom_payload: (buffer, offset) => {
      let { value: channel, size: channelSize } = (ctx.string)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.restBuffer)(buffer, offset + channelSize)
      return { value: { channel, data }, size: channelSize + dataSize}
    },
    packet_hide_message: (buffer, offset) => {
      let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        switch (id) {
          case 0: return ((buffer, offset) => {
            const count = 256
            const countSize = 0
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + idSize)
      return { value: { id, signature }, size: idSize + signatureSize}
    },
    packet_kick_disconnect: (buffer, offset) => {
      let { value: reason, size: reasonSize } = (ctx.string)(buffer, offset)
      return { value: { reason }, size: reasonSize}
    },
    packet_profileless_chat: (buffer, offset) => {
      let { value: message, size: messageSize } = (ctx.string)(buffer, offset)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + messageSize)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + messageSize + typeSize)
      let { value: target, size: targetSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + messageSize + typeSize + nameSize)
      return { value: { message, type, name, target }, size: messageSize + typeSize + nameSize + targetSize}
    },
    packet_entity_status: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: entityStatus, size: entityStatusSize } = (ctx.i8)(buffer, offset + entityIdSize)
      return { value: { entityId, entityStatus }, size: entityIdSize + entityStatusSize}
    },
    packet_explosion: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: radius, size: radiusSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: affectedBlockOffsets, size: affectedBlockOffsetsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: x1, size: x1Size } = (ctx.i8)(buffer, offset)
          let { value: y1, size: y1Size } = (ctx.i8)(buffer, offset + x1Size)
          let { value: z1, size: z1Size } = (ctx.i8)(buffer, offset + x1Size + y1Size)
          return { value: { x: x1, y: y1, z: z1 }, size: x1Size + y1Size + z1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + ySize + zSize + radiusSize)
      let { value: playerMotionX, size: playerMotionXSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize)
      let { value: playerMotionY, size: playerMotionYSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize)
      let { value: playerMotionZ, size: playerMotionZSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize + playerMotionYSize)
      return { value: { x, y, z, radius, affectedBlockOffsets, playerMotionX, playerMotionY, playerMotionZ }, size: xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize + playerMotionYSize + playerMotionZSize}
    },
    packet_unload_chunk: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.i32)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.i32)(buffer, offset + chunkXSize)
      return { value: { chunkX, chunkZ }, size: chunkXSize + chunkZSize}
    },
    packet_game_state_change: (buffer, offset) => {
      let { value: reason, size: reasonSize } = (ctx.u8)(buffer, offset)
      let { value: gameMode, size: gameModeSize } = (ctx.f32)(buffer, offset + reasonSize)
      return { value: { reason, gameMode }, size: reasonSize + gameModeSize}
    },
    packet_open_horse_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: nbSlots, size: nbSlotsSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + windowIdSize + nbSlotsSize)
      return { value: { windowId, nbSlots, entityId }, size: windowIdSize + nbSlotsSize + entityIdSize}
    },
    packet_keep_alive: (buffer, offset) => {
      let { value: keepAliveId, size: keepAliveIdSize } = (ctx.i64)(buffer, offset)
      return { value: { keepAliveId }, size: keepAliveIdSize}
    },
    packet_map_chunk: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.i32)(buffer, offset)
      let { value: z, size: zSize } = (ctx.i32)(buffer, offset + xSize)
      let { value: heightmaps, size: heightmapsSize } = (ctx.nbt)(buffer, offset + xSize + zSize)
      let { value: chunkData, size: chunkDataSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + xSize + zSize + heightmapsSize)
      let { value: blockEntities, size: blockEntitiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.chunkBlockEntity)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize)
      let { value: trustEdges, size: trustEdgesSize } = (ctx.bool)(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize)
      let { value: skyLightMask, size: skyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize)
      let { value: blockLightMask, size: blockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize)
      let { value: emptySkyLightMask, size: emptySkyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize)
      let { value: emptyBlockLightMask, size: emptyBlockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize)
      let { value: skyLight, size: skyLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize)
      let { value: blockLight, size: blockLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize)
      return { value: { x, z, heightmaps, chunkData, blockEntities, trustEdges, skyLightMask, blockLightMask, emptySkyLightMask, emptyBlockLightMask, skyLight, blockLight }, size: xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize + blockLightSize}
    },
    packet_world_event: (buffer, offset) => {
      let { value: effectId, size: effectIdSize } = (ctx.i32)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + effectIdSize)
      let { value: data, size: dataSize } = (ctx.i32)(buffer, offset + effectIdSize + locationSize)
      let { value: global, size: globalSize } = (ctx.bool)(buffer, offset + effectIdSize + locationSize + dataSize)
      return { value: { effectId, location, data, global }, size: effectIdSize + locationSize + dataSize + globalSize}
    },
    packet_world_particles: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: longDistance, size: longDistanceSize } = (ctx.bool)(buffer, offset + particleIdSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize)
      let { value: offsetX, size: offsetXSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize)
      let { value: offsetY, size: offsetYSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize)
      let { value: offsetZ, size: offsetZSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize)
      let { value: particleData, size: particleDataSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize)
      let { value: particles, size: particlesSize } = (ctx.i32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize + particlesSize, particleId)
      return { value: { particleId, longDistance, x, y, z, offsetX, offsetY, offsetZ, particleData, particles, data }, size: particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize + particlesSize + dataSize}
    },
    packet_update_light: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.varint)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.varint)(buffer, offset + chunkXSize)
      let { value: trustEdges, size: trustEdgesSize } = (ctx.bool)(buffer, offset + chunkXSize + chunkZSize)
      let { value: skyLightMask, size: skyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize)
      let { value: blockLightMask, size: blockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize)
      let { value: emptySkyLightMask, size: emptySkyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize)
      let { value: emptyBlockLightMask, size: emptyBlockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize)
      let { value: skyLight, size: skyLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize)
      let { value: blockLight, size: blockLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize)
      return { value: { chunkX, chunkZ, trustEdges, skyLightMask, blockLightMask, emptySkyLightMask, emptyBlockLightMask, skyLight, blockLight }, size: chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize + blockLightSize}
    },
    packet_login: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: isHardcore, size: isHardcoreSize } = (ctx.bool)(buffer, offset + entityIdSize)
      let { value: gameMode, size: gameModeSize } = (ctx.u8)(buffer, offset + entityIdSize + isHardcoreSize)
      let { value: previousGameMode, size: previousGameModeSize } = (ctx.i8)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize)
      let { value: worldNames, size: worldNamesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize)
      let { value: dimensionCodec, size: dimensionCodecSize } = (ctx.nbt)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize)
      let { value: worldType, size: worldTypeSize } = (ctx.string)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize)
      let { value: worldName, size: worldNameSize } = (ctx.string)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize)
      let { value: hashedSeed, size: hashedSeedSize } = (ctx.i64)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize)
      let { value: maxPlayers, size: maxPlayersSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize)
      let { value: viewDistance, size: viewDistanceSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize)
      let { value: simulationDistance, size: simulationDistanceSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize)
      let { value: reducedDebugInfo, size: reducedDebugInfoSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize)
      let { value: enableRespawnScreen, size: enableRespawnScreenSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize)
      let { value: isDebug, size: isDebugSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize)
      let { value: isFlat, size: isFlatSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize)
      let { value: death, size: deathSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          let { value: dimensionName, size: dimensionNameSize } = (ctx.string)(buffer, offset)
          let { value: location1, size: location1Size } = (ctx.position)(buffer, offset + dimensionNameSize)
          return { value: { dimensionName, location: location1 }, size: dimensionNameSize + location1Size}
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize + isFlatSize)
      return { value: { entityId, isHardcore, gameMode, previousGameMode, worldNames, dimensionCodec, worldType, worldName, hashedSeed, maxPlayers, viewDistance, simulationDistance, reducedDebugInfo, enableRespawnScreen, isDebug, isFlat, death }, size: entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize + isFlatSize + deathSize}
    },
    packet_map: (buffer, offset) => {
      let { value: itemDamage, size: itemDamageSize } = (ctx.varint)(buffer, offset)
      let { value: scale, size: scaleSize } = (ctx.i8)(buffer, offset + itemDamageSize)
      let { value: locked, size: lockedSize } = (ctx.bool)(buffer, offset + itemDamageSize + scaleSize)
      let { value: icons, size: iconsSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = ((buffer, offset) => {
            let { value: type1, size: type1Size } = (ctx.varint)(buffer, offset)
            let { value: x1, size: x1Size } = (ctx.i8)(buffer, offset + type1Size)
            let { value: z1, size: z1Size } = (ctx.i8)(buffer, offset + type1Size + x1Size)
            let { value: direction, size: directionSize } = (ctx.u8)(buffer, offset + type1Size + x1Size + z1Size)
            let { value: displayName, size: displayNameSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.string)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + type1Size + x1Size + z1Size + directionSize)
            return { value: { type: type1, x: x1, z: z1, direction, displayName }, size: type1Size + x1Size + z1Size + directionSize + displayNameSize}
          })(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize)
      let { value: columns, size: columnsSize } = (ctx.u8)(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize)
      let { value: rows, size: rowsSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize)
      let { value: x, size: xSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize)
      let { value: y, size: ySize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize)
      let { value: data, size: dataSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize + ySize)
      return { value: { itemDamage, scale, locked, icons, columns, rows, x, y, data }, size: itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize + ySize + dataSize}
    },
    packet_trade_list: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.varint)(buffer, offset)
      let { value: trades, size: tradesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: inputItem1, size: inputItem1Size } = (ctx.slot)(buffer, offset)
          let { value: outputItem, size: outputItemSize } = (ctx.slot)(buffer, offset + inputItem1Size)
          let { value: inputItem2, size: inputItem2Size } = (ctx.slot)(buffer, offset + inputItem1Size + outputItemSize)
          let { value: tradeDisabled, size: tradeDisabledSize } = (ctx.bool)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size)
          let { value: nbTradeUses, size: nbTradeUsesSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize)
          let { value: maximumNbTradeUses, size: maximumNbTradeUsesSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize)
          let { value: xp, size: xpSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize)
          let { value: specialPrice, size: specialPriceSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize)
          let { value: priceMultiplier, size: priceMultiplierSize } = (ctx.f32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize)
          let { value: demand, size: demandSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize + priceMultiplierSize)
          return { value: { inputItem1, outputItem, inputItem2, tradeDisabled, nbTradeUses, maximumNbTradeUses, xp, specialPrice, priceMultiplier, demand }, size: inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize + priceMultiplierSize + demandSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + windowIdSize)
      let { value: villagerLevel, size: villagerLevelSize } = (ctx.varint)(buffer, offset + windowIdSize + tradesSize)
      let { value: experience, size: experienceSize } = (ctx.varint)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize)
      let { value: isRegularVillager, size: isRegularVillagerSize } = (ctx.bool)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize + experienceSize)
      let { value: canRestock, size: canRestockSize } = (ctx.bool)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize + experienceSize + isRegularVillagerSize)
      return { value: { windowId, trades, villagerLevel, experience, isRegularVillager, canRestock }, size: windowIdSize + tradesSize + villagerLevelSize + experienceSize + isRegularVillagerSize + canRestockSize}
    },
    packet_rel_entity_move: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: dX, size: dXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: dY, size: dYSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize)
      let { value: dZ, size: dZSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize + dYSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize)
      return { value: { entityId, dX, dY, dZ, onGround }, size: entityIdSize + dXSize + dYSize + dZSize + onGroundSize}
    },
    packet_entity_move_look: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: dX, size: dXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: dY, size: dYSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize)
      let { value: dZ, size: dZSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize + dYSize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize + yawSize + pitchSize)
      return { value: { entityId, dX, dY, dZ, yaw, pitch, onGround }, size: entityIdSize + dXSize + dYSize + dZSize + yawSize + pitchSize + onGroundSize}
    },
    packet_entity_look: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + yawSize + pitchSize)
      return { value: { entityId, yaw, pitch, onGround }, size: entityIdSize + yawSize + pitchSize + onGroundSize}
    },
    packet_vehicle_move: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      return { value: { x, y, z, yaw, pitch }, size: xSize + ySize + zSize + yawSize + pitchSize}
    },
    packet_open_book: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      return { value: { hand }, size: handSize}
    },
    packet_open_sign_entity: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      return { value: { location }, size: locationSize}
    },
    packet_craft_recipe_response: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: recipe, size: recipeSize } = (ctx.string)(buffer, offset + windowIdSize)
      return { value: { windowId, recipe }, size: windowIdSize + recipeSize}
    },
    packet_abilities: (buffer, offset) => {
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset)
      let { value: flyingSpeed, size: flyingSpeedSize } = (ctx.f32)(buffer, offset + flagsSize)
      let { value: walkingSpeed, size: walkingSpeedSize } = (ctx.f32)(buffer, offset + flagsSize + flyingSpeedSize)
      return { value: { flags, flyingSpeed, walkingSpeed }, size: flagsSize + flyingSpeedSize + walkingSpeedSize}
    },
    packet_player_chat: (buffer, offset) => {
      let { value: senderUuid, size: senderUuidSize } = (ctx.UUID)(buffer, offset)
      let { value: index, size: indexSize } = (ctx.varint)(buffer, offset + senderUuidSize)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const count = 256
          const countSize = 0
          offset += countSize
          if (offset + count > buffer.length) {
            throw new PartialReadError()
          }
          return { value: buffer.slice(offset, offset + count), size: count + countSize }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize)
      let { value: plainMessage, size: plainMessageSize } = (ctx.string)(buffer, offset + senderUuidSize + indexSize + signatureSize)
      let { value: timestamp, size: timestampSize } = (ctx.i64)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize)
      let { value: salt, size: saltSize } = (ctx.i64)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize)
      let { value: previousMessages, size: previousMessagesSize } = (ctx.previousMessages)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize)
      let { value: unsignedChatContent, size: unsignedChatContentSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize)
      let { value: filterType, size: filterTypeSize } = (ctx.varint)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize)
      let { value: filterTypeMask, size: filterTypeMaskSize } = ((buffer, offset) => {
        switch (filterType) {
          case 2: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.i64)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize)
      let { value: networkName, size: networkNameSize } = (ctx.string)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize)
      let { value: networkTargetName, size: networkTargetNameSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize + networkNameSize)
      return { value: { senderUuid, index, signature, plainMessage, timestamp, salt, previousMessages, unsignedChatContent, filterType, filterTypeMask, type, networkName, networkTargetName }, size: senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize + networkNameSize + networkTargetNameSize}
    },
    packet_end_combat_event: (buffer, offset) => {
      let { value: duration, size: durationSize } = (ctx.varint)(buffer, offset)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + durationSize)
      return { value: { duration, entityId }, size: durationSize + entityIdSize}
    },
    packet_enter_combat_event: (buffer, offset) => {
      return { value: {  }, size: 0}
    },
    packet_death_combat_event: (buffer, offset) => {
      let { value: playerId, size: playerIdSize } = (ctx.varint)(buffer, offset)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + playerIdSize)
      let { value: message, size: messageSize } = (ctx.string)(buffer, offset + playerIdSize + entityIdSize)
      return { value: { playerId, entityId, message }, size: playerIdSize + entityIdSize + messageSize}
    },
    packet_player_remove: (buffer, offset) => {
      let { value: players, size: playersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.UUID)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { players }, size: playersSize}
    },
    packet_player_info: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.i8)(buffer, offset)
      let { value: data, size: dataSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
          let { value: player, size: playerSize } = ((buffer, offset) => {
            switch (action) {
              case 1: return (ctx.game_profile)(buffer, offset)
              case 3: return (ctx.game_profile)(buffer, offset)
              case 5: return (ctx.game_profile)(buffer, offset)
              case 7: return (ctx.game_profile)(buffer, offset)
              case 9: return (ctx.game_profile)(buffer, offset)
              case 11: return (ctx.game_profile)(buffer, offset)
              case 13: return (ctx.game_profile)(buffer, offset)
              case 15: return (ctx.game_profile)(buffer, offset)
              case 17: return (ctx.game_profile)(buffer, offset)
              case 19: return (ctx.game_profile)(buffer, offset)
              case 21: return (ctx.game_profile)(buffer, offset)
              case 23: return (ctx.game_profile)(buffer, offset)
              case 25: return (ctx.game_profile)(buffer, offset)
              case 27: return (ctx.game_profile)(buffer, offset)
              case 29: return (ctx.game_profile)(buffer, offset)
              case 31: return (ctx.game_profile)(buffer, offset)
              case 33: return (ctx.game_profile)(buffer, offset)
              case 35: return (ctx.game_profile)(buffer, offset)
              case 37: return (ctx.game_profile)(buffer, offset)
              case 39: return (ctx.game_profile)(buffer, offset)
              case 41: return (ctx.game_profile)(buffer, offset)
              case 43: return (ctx.game_profile)(buffer, offset)
              case 45: return (ctx.game_profile)(buffer, offset)
              case 47: return (ctx.game_profile)(buffer, offset)
              case 49: return (ctx.game_profile)(buffer, offset)
              case 51: return (ctx.game_profile)(buffer, offset)
              case 53: return (ctx.game_profile)(buffer, offset)
              case 55: return (ctx.game_profile)(buffer, offset)
              case 57: return (ctx.game_profile)(buffer, offset)
              case 59: return (ctx.game_profile)(buffer, offset)
              case 61: return (ctx.game_profile)(buffer, offset)
              case 63: return (ctx.game_profile)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize)
          let { value: chatSession, size: chatSessionSize } = ((buffer, offset) => {
            switch (action) {
              case 2: return (ctx.chat_session)(buffer, offset)
              case 3: return (ctx.chat_session)(buffer, offset)
              case 6: return (ctx.chat_session)(buffer, offset)
              case 7: return (ctx.chat_session)(buffer, offset)
              case 10: return (ctx.chat_session)(buffer, offset)
              case 11: return (ctx.chat_session)(buffer, offset)
              case 14: return (ctx.chat_session)(buffer, offset)
              case 15: return (ctx.chat_session)(buffer, offset)
              case 18: return (ctx.chat_session)(buffer, offset)
              case 19: return (ctx.chat_session)(buffer, offset)
              case 22: return (ctx.chat_session)(buffer, offset)
              case 23: return (ctx.chat_session)(buffer, offset)
              case 26: return (ctx.chat_session)(buffer, offset)
              case 27: return (ctx.chat_session)(buffer, offset)
              case 30: return (ctx.chat_session)(buffer, offset)
              case 31: return (ctx.chat_session)(buffer, offset)
              case 34: return (ctx.chat_session)(buffer, offset)
              case 35: return (ctx.chat_session)(buffer, offset)
              case 38: return (ctx.chat_session)(buffer, offset)
              case 39: return (ctx.chat_session)(buffer, offset)
              case 42: return (ctx.chat_session)(buffer, offset)
              case 43: return (ctx.chat_session)(buffer, offset)
              case 46: return (ctx.chat_session)(buffer, offset)
              case 47: return (ctx.chat_session)(buffer, offset)
              case 50: return (ctx.chat_session)(buffer, offset)
              case 51: return (ctx.chat_session)(buffer, offset)
              case 54: return (ctx.chat_session)(buffer, offset)
              case 55: return (ctx.chat_session)(buffer, offset)
              case 58: return (ctx.chat_session)(buffer, offset)
              case 59: return (ctx.chat_session)(buffer, offset)
              case 62: return (ctx.chat_session)(buffer, offset)
              case 63: return (ctx.chat_session)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize)
          let { value: gamemode, size: gamemodeSize } = ((buffer, offset) => {
            switch (action) {
              case 4: return (ctx.varint)(buffer, offset)
              case 5: return (ctx.varint)(buffer, offset)
              case 6: return (ctx.varint)(buffer, offset)
              case 7: return (ctx.varint)(buffer, offset)
              case 12: return (ctx.varint)(buffer, offset)
              case 13: return (ctx.varint)(buffer, offset)
              case 14: return (ctx.varint)(buffer, offset)
              case 15: return (ctx.varint)(buffer, offset)
              case 20: return (ctx.varint)(buffer, offset)
              case 21: return (ctx.varint)(buffer, offset)
              case 22: return (ctx.varint)(buffer, offset)
              case 23: return (ctx.varint)(buffer, offset)
              case 28: return (ctx.varint)(buffer, offset)
              case 29: return (ctx.varint)(buffer, offset)
              case 30: return (ctx.varint)(buffer, offset)
              case 31: return (ctx.varint)(buffer, offset)
              case 36: return (ctx.varint)(buffer, offset)
              case 37: return (ctx.varint)(buffer, offset)
              case 38: return (ctx.varint)(buffer, offset)
              case 39: return (ctx.varint)(buffer, offset)
              case 44: return (ctx.varint)(buffer, offset)
              case 45: return (ctx.varint)(buffer, offset)
              case 46: return (ctx.varint)(buffer, offset)
              case 47: return (ctx.varint)(buffer, offset)
              case 52: return (ctx.varint)(buffer, offset)
              case 53: return (ctx.varint)(buffer, offset)
              case 54: return (ctx.varint)(buffer, offset)
              case 55: return (ctx.varint)(buffer, offset)
              case 60: return (ctx.varint)(buffer, offset)
              case 61: return (ctx.varint)(buffer, offset)
              case 62: return (ctx.varint)(buffer, offset)
              case 63: return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize)
          let { value: listed, size: listedSize } = ((buffer, offset) => {
            switch (action) {
              case 8: return (ctx.bool)(buffer, offset)
              case 9: return (ctx.bool)(buffer, offset)
              case 10: return (ctx.bool)(buffer, offset)
              case 11: return (ctx.bool)(buffer, offset)
              case 12: return (ctx.bool)(buffer, offset)
              case 13: return (ctx.bool)(buffer, offset)
              case 14: return (ctx.bool)(buffer, offset)
              case 15: return (ctx.bool)(buffer, offset)
              case 24: return (ctx.bool)(buffer, offset)
              case 25: return (ctx.bool)(buffer, offset)
              case 26: return (ctx.bool)(buffer, offset)
              case 27: return (ctx.bool)(buffer, offset)
              case 28: return (ctx.bool)(buffer, offset)
              case 29: return (ctx.bool)(buffer, offset)
              case 30: return (ctx.bool)(buffer, offset)
              case 31: return (ctx.bool)(buffer, offset)
              case 40: return (ctx.bool)(buffer, offset)
              case 41: return (ctx.bool)(buffer, offset)
              case 42: return (ctx.bool)(buffer, offset)
              case 43: return (ctx.bool)(buffer, offset)
              case 44: return (ctx.bool)(buffer, offset)
              case 45: return (ctx.bool)(buffer, offset)
              case 46: return (ctx.bool)(buffer, offset)
              case 47: return (ctx.bool)(buffer, offset)
              case 56: return (ctx.bool)(buffer, offset)
              case 57: return (ctx.bool)(buffer, offset)
              case 58: return (ctx.bool)(buffer, offset)
              case 59: return (ctx.bool)(buffer, offset)
              case 60: return (ctx.bool)(buffer, offset)
              case 61: return (ctx.bool)(buffer, offset)
              case 62: return (ctx.bool)(buffer, offset)
              case 63: return (ctx.bool)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize)
          let { value: latency, size: latencySize } = ((buffer, offset) => {
            switch (action) {
              case 16: return (ctx.varint)(buffer, offset)
              case 17: return (ctx.varint)(buffer, offset)
              case 18: return (ctx.varint)(buffer, offset)
              case 19: return (ctx.varint)(buffer, offset)
              case 20: return (ctx.varint)(buffer, offset)
              case 21: return (ctx.varint)(buffer, offset)
              case 22: return (ctx.varint)(buffer, offset)
              case 23: return (ctx.varint)(buffer, offset)
              case 24: return (ctx.varint)(buffer, offset)
              case 25: return (ctx.varint)(buffer, offset)
              case 26: return (ctx.varint)(buffer, offset)
              case 27: return (ctx.varint)(buffer, offset)
              case 28: return (ctx.varint)(buffer, offset)
              case 29: return (ctx.varint)(buffer, offset)
              case 30: return (ctx.varint)(buffer, offset)
              case 31: return (ctx.varint)(buffer, offset)
              case 48: return (ctx.varint)(buffer, offset)
              case 49: return (ctx.varint)(buffer, offset)
              case 50: return (ctx.varint)(buffer, offset)
              case 51: return (ctx.varint)(buffer, offset)
              case 52: return (ctx.varint)(buffer, offset)
              case 53: return (ctx.varint)(buffer, offset)
              case 54: return (ctx.varint)(buffer, offset)
              case 55: return (ctx.varint)(buffer, offset)
              case 56: return (ctx.varint)(buffer, offset)
              case 57: return (ctx.varint)(buffer, offset)
              case 58: return (ctx.varint)(buffer, offset)
              case 59: return (ctx.varint)(buffer, offset)
              case 60: return (ctx.varint)(buffer, offset)
              case 61: return (ctx.varint)(buffer, offset)
              case 62: return (ctx.varint)(buffer, offset)
              case 63: return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize)
          let { value: displayName, size: displayNameSize } = ((buffer, offset) => {
            switch (action) {
              case 32: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 33: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 34: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 35: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 36: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 37: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 38: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 39: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 40: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 41: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 42: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 43: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 44: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 45: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 46: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 47: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 48: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 49: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 50: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 51: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 52: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 53: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 54: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 55: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 56: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 57: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 58: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 59: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 60: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 61: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 62: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 63: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize + latencySize)
          return { value: { uuid, player, chatSession, gamemode, listed, latency, displayName }, size: uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize + latencySize + displayNameSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize)
      return { value: { action, data }, size: actionSize + dataSize}
    },
    packet_position: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset + xSize + ySize + zSize + yawSize + pitchSize)
      let { value: teleportId, size: teleportIdSize } = (ctx.varint)(buffer, offset + xSize + ySize + zSize + yawSize + pitchSize + flagsSize)
      return { value: { x, y, z, yaw, pitch, flags, teleportId }, size: xSize + ySize + zSize + yawSize + pitchSize + flagsSize + teleportIdSize}
    },
    packet_unlock_recipes: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset)
      let { value: craftingBookOpen, size: craftingBookOpenSize } = (ctx.bool)(buffer, offset + actionSize)
      let { value: filteringCraftable, size: filteringCraftableSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize)
      let { value: smeltingBookOpen, size: smeltingBookOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize)
      let { value: filteringSmeltable, size: filteringSmeltableSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize)
      let { value: blastFurnaceOpen, size: blastFurnaceOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize)
      let { value: filteringBlastFurnace, size: filteringBlastFurnaceSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize)
      let { value: smokerBookOpen, size: smokerBookOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize)
      let { value: filteringSmoker, size: filteringSmokerSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize)
      let { value: recipes1, size: recipes1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize)
      let { value: recipes2, size: recipes2Size } = ((buffer, offset) => {
        switch (action) {
          case 0: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize + recipes1Size)
      return { value: { action, craftingBookOpen, filteringCraftable, smeltingBookOpen, filteringSmeltable, blastFurnaceOpen, filteringBlastFurnace, smokerBookOpen, filteringSmoker, recipes1, recipes2 }, size: actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize + recipes1Size + recipes2Size}
    },
    packet_entity_destroy: (buffer, offset) => {
      let { value: entityIds, size: entityIdsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { entityIds }, size: entityIdsSize}
    },
    packet_remove_entity_effect: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: effectId, size: effectIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      return { value: { entityId, effectId }, size: entityIdSize + effectIdSize}
    },
    packet_resource_pack_send: (buffer, offset) => {
      let { value: url, size: urlSize } = (ctx.string)(buffer, offset)
      let { value: hash, size: hashSize } = (ctx.string)(buffer, offset + urlSize)
      let { value: forced, size: forcedSize } = (ctx.bool)(buffer, offset + urlSize + hashSize)
      let { value: promptMessage, size: promptMessageSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + urlSize + hashSize + forcedSize)
      return { value: { url, hash, forced, promptMessage }, size: urlSize + hashSize + forcedSize + promptMessageSize}
    },
    packet_respawn: (buffer, offset) => {
      let { value: dimension, size: dimensionSize } = (ctx.string)(buffer, offset)
      let { value: worldName, size: worldNameSize } = (ctx.string)(buffer, offset + dimensionSize)
      let { value: hashedSeed, size: hashedSeedSize } = (ctx.i64)(buffer, offset + dimensionSize + worldNameSize)
      let { value: gamemode, size: gamemodeSize } = (ctx.i8)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize)
      let { value: previousGamemode, size: previousGamemodeSize } = (ctx.u8)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize)
      let { value: isDebug, size: isDebugSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize)
      let { value: isFlat, size: isFlatSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize)
      let { value: copyMetadata, size: copyMetadataSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize)
      let { value: death, size: deathSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          let { value: dimensionName, size: dimensionNameSize } = (ctx.string)(buffer, offset)
          let { value: location1, size: location1Size } = (ctx.position)(buffer, offset + dimensionNameSize)
          return { value: { dimensionName, location: location1 }, size: dimensionNameSize + location1Size}
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize + copyMetadataSize)
      return { value: { dimension, worldName, hashedSeed, gamemode, previousGamemode, isDebug, isFlat, copyMetadata, death }, size: dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize + copyMetadataSize + deathSize}
    },
    packet_entity_head_rotation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: headYaw, size: headYawSize } = (ctx.i8)(buffer, offset + entityIdSize)
      return { value: { entityId, headYaw }, size: entityIdSize + headYawSize}
    },
    packet_camera: (buffer, offset) => {
      let { value: cameraId, size: cameraIdSize } = (ctx.varint)(buffer, offset)
      return { value: { cameraId }, size: cameraIdSize}
    },
    packet_held_item_slot: (buffer, offset) => {
      let { value: slot, size: slotSize } = (ctx.i8)(buffer, offset)
      return { value: { slot }, size: slotSize}
    },
    packet_update_view_position: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.varint)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.varint)(buffer, offset + chunkXSize)
      return { value: { chunkX, chunkZ }, size: chunkXSize + chunkZSize}
    },
    packet_update_view_distance: (buffer, offset) => {
      let { value: viewDistance, size: viewDistanceSize } = (ctx.varint)(buffer, offset)
      return { value: { viewDistance }, size: viewDistanceSize}
    },
    packet_scoreboard_display_objective: (buffer, offset) => {
      let { value: position, size: positionSize } = (ctx.i8)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + positionSize)
      return { value: { position, name }, size: positionSize + nameSize}
    },
    packet_entity_metadata: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: metadata, size: metadataSize } = (ctx.entityMetadata)(buffer, offset + entityIdSize)
      return { value: { entityId, metadata }, size: entityIdSize + metadataSize}
    },
    packet_attach_entity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: vehicleId, size: vehicleIdSize } = (ctx.i32)(buffer, offset + entityIdSize)
      return { value: { entityId, vehicleId }, size: entityIdSize + vehicleIdSize}
    },
    packet_entity_velocity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: velocityX, size: velocityXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: velocityY, size: velocityYSize } = (ctx.i16)(buffer, offset + entityIdSize + velocityXSize)
      let { value: velocityZ, size: velocityZSize } = (ctx.i16)(buffer, offset + entityIdSize + velocityXSize + velocityYSize)
      return { value: { entityId, velocityX, velocityY, velocityZ }, size: entityIdSize + velocityXSize + velocityYSize + velocityZSize}
    },
    packet_entity_equipment: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: equipments, size: equipmentsSize } = ((buffer, offset) => {
        let cursor = offset
        const data = []
        while (true) {
          const item = ctx.u8(buffer, cursor).value
          buffer[cursor] = buffer[cursor] & 127
          const elem = ((buffer, offset) => {
          let { value: slot1, size: slot1Size } = (ctx.i8)(buffer, offset)
          let { value: item1, size: item1Size } = (ctx.slot)(buffer, offset + slot1Size)
          return { value: { slot: slot1, item: item1 }, size: slot1Size + item1Size}
        })(buffer, cursor)
          data.push(elem.value)
          cursor += elem.size
          if ((item & 128) === 0) return { value: data, size: cursor - offset }
        }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, equipments }, size: entityIdSize + equipmentsSize}
    },
    packet_experience: (buffer, offset) => {
      let { value: experienceBar, size: experienceBarSize } = (ctx.f32)(buffer, offset)
      let { value: totalExperience, size: totalExperienceSize } = (ctx.varint)(buffer, offset + experienceBarSize)
      let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + experienceBarSize + totalExperienceSize)
      return { value: { experienceBar, totalExperience, level }, size: experienceBarSize + totalExperienceSize + levelSize}
    },
    packet_update_health: (buffer, offset) => {
      let { value: health, size: healthSize } = (ctx.f32)(buffer, offset)
      let { value: food, size: foodSize } = (ctx.varint)(buffer, offset + healthSize)
      let { value: foodSaturation, size: foodSaturationSize } = (ctx.f32)(buffer, offset + healthSize + foodSize)
      return { value: { health, food, foodSaturation }, size: healthSize + foodSize + foodSaturationSize}
    },
    packet_scoreboard_objective: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.i8)(buffer, offset + nameSize)
      let { value: displayText, size: displayTextSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize + actionSize)
      let { value: type, size: typeSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 2: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize + actionSize + displayTextSize)
      return { value: { name, action, displayText, type }, size: nameSize + actionSize + displayTextSize + typeSize}
    },
    packet_set_passengers: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: passengers, size: passengersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, passengers }, size: entityIdSize + passengersSize}
    },
    packet_teams: (buffer, offset) => {
      let { value: team, size: teamSize } = (ctx.string)(buffer, offset)
      let { value: mode, size: modeSize } = (ctx.i8)(buffer, offset + teamSize)
      let { value: name, size: nameSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize)
      let { value: friendlyFire, size: friendlyFireSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.i8)(buffer, offset)
          case 2: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize)
      let { value: nameTagVisibility, size: nameTagVisibilitySize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize)
      let { value: collisionRule, size: collisionRuleSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize)
      let { value: formatting, size: formattingSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.varint)(buffer, offset)
          case 2: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize)
      let { value: prefix, size: prefixSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize)
      let { value: suffix, size: suffixSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize)
      let { value: players, size: playersSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          case 3: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          case 4: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize + suffixSize)
      return { value: { team, mode, name, friendlyFire, nameTagVisibility, collisionRule, formatting, prefix, suffix, players }, size: teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize + suffixSize + playersSize}
    },
    packet_scoreboard_score: (buffer, offset) => {
      let { value: itemName, size: itemNameSize } = (ctx.string)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + itemNameSize)
      let { value: scoreName, size: scoreNameSize } = (ctx.string)(buffer, offset + itemNameSize + actionSize)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        switch (action) {
          case 1: return (ctx.void)(buffer, offset)
          default: return (ctx.varint)(buffer, offset)
        }
      })(buffer, offset + itemNameSize + actionSize + scoreNameSize)
      return { value: { itemName, action, scoreName, value: value1 }, size: itemNameSize + actionSize + scoreNameSize + value1Size}
    },
    packet_spawn_position: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: angle, size: angleSize } = (ctx.f32)(buffer, offset + locationSize)
      return { value: { location, angle }, size: locationSize + angleSize}
    },
    packet_update_time: (buffer, offset) => {
      let { value: age, size: ageSize } = (ctx.i64)(buffer, offset)
      let { value: time, size: timeSize } = (ctx.i64)(buffer, offset + ageSize)
      return { value: { age, time }, size: ageSize + timeSize}
    },
    packet_entity_sound_effect: (buffer, offset) => {
      let { value: soundId, size: soundIdSize } = (ctx.varint)(buffer, offset)
      let { value: soundEvent, size: soundEventSize } = ((buffer, offset) => {
        switch (soundId) {
          case 0: return ((buffer, offset) => {
            let { value: resource, size: resourceSize } = (ctx.string)(buffer, offset)
            let { value: range, size: rangeSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.f32)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + resourceSize)
            return { value: { resource, range }, size: resourceSize + rangeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + soundIdSize)
      let { value: soundCategory, size: soundCategorySize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize)
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize)
      let { value: volume, size: volumeSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize)
      let { value: seed, size: seedSize } = (ctx.i64)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize + pitchSize)
      return { value: { soundId, soundEvent, soundCategory, entityId, volume, pitch, seed }, size: soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize + pitchSize + seedSize}
    },
    packet_stop_sound: (buffer, offset) => {
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset)
      let { value: source, size: sourceSize } = ((buffer, offset) => {
        switch (flags) {
          case 1: return (ctx.varint)(buffer, offset)
          case 3: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize)
      let { value: sound, size: soundSize } = ((buffer, offset) => {
        switch (flags) {
          case 2: return (ctx.string)(buffer, offset)
          case 3: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + sourceSize)
      return { value: { flags, source, sound }, size: flagsSize + sourceSize + soundSize}
    },
    packet_sound_effect: (buffer, offset) => {
      let { value: soundId, size: soundIdSize } = (ctx.varint)(buffer, offset)
      let { value: soundEvent, size: soundEventSize } = ((buffer, offset) => {
        switch (soundId) {
          case 0: return ((buffer, offset) => {
            let { value: resource, size: resourceSize } = (ctx.string)(buffer, offset)
            let { value: range, size: rangeSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.f32)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + resourceSize)
            return { value: { resource, range }, size: resourceSize + rangeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + soundIdSize)
      let { value: soundCategory, size: soundCategorySize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize)
      let { value: x, size: xSize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize)
      let { value: y, size: ySize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize)
      let { value: z, size: zSize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize)
      let { value: volume, size: volumeSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize)
      let { value: seed, size: seedSize } = (ctx.i64)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize + pitchSize)
      return { value: { soundId, soundEvent, soundCategory, x, y, z, volume, pitch, seed }, size: soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize + pitchSize + seedSize}
    },
    packet_system_chat: (buffer, offset) => {
      let { value: content, size: contentSize } = (ctx.string)(buffer, offset)
      let { value: isActionBar, size: isActionBarSize } = (ctx.bool)(buffer, offset + contentSize)
      return { value: { content, isActionBar }, size: contentSize + isActionBarSize}
    },
    packet_playerlist_header: (buffer, offset) => {
      let { value: header, size: headerSize } = (ctx.string)(buffer, offset)
      let { value: footer, size: footerSize } = (ctx.string)(buffer, offset + headerSize)
      return { value: { header, footer }, size: headerSize + footerSize}
    },
    packet_collect: (buffer, offset) => {
      let { value: collectedEntityId, size: collectedEntityIdSize } = (ctx.varint)(buffer, offset)
      let { value: collectorEntityId, size: collectorEntityIdSize } = (ctx.varint)(buffer, offset + collectedEntityIdSize)
      let { value: pickupItemCount, size: pickupItemCountSize } = (ctx.varint)(buffer, offset + collectedEntityIdSize + collectorEntityIdSize)
      return { value: { collectedEntityId, collectorEntityId, pickupItemCount }, size: collectedEntityIdSize + collectorEntityIdSize + pickupItemCountSize}
    },
    packet_entity_teleport: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + xSize + ySize + zSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + xSize + ySize + zSize + yawSize + pitchSize)
      return { value: { entityId, x, y, z, yaw, pitch, onGround }, size: entityIdSize + xSize + ySize + zSize + yawSize + pitchSize + onGroundSize}
    },
    packet_entity_update_attributes: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value2, size: value2Size } = (ctx.f64)(buffer, offset + keySize)
          let { value: modifiers, size: modifiersSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = ((buffer, offset) => {
              let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
              let { value: amount, size: amountSize } = (ctx.f64)(buffer, offset + uuidSize)
              let { value: operation, size: operationSize } = (ctx.i8)(buffer, offset + uuidSize + amountSize)
              return { value: { uuid, amount, operation }, size: uuidSize + amountSize + operationSize}
            })(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset + keySize + value2Size)
          return { value: { key, value: value2, modifiers }, size: keySize + value2Size + modifiersSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, properties }, size: entityIdSize + propertiesSize}
    },
    packet_feature_flags: (buffer, offset) => {
      let { value: features, size: featuresSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { features }, size: featuresSize}
    },
    packet_entity_effect: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: effectId, size: effectIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      let { value: amplifier, size: amplifierSize } = (ctx.i8)(buffer, offset + entityIdSize + effectIdSize)
      let { value: duration, size: durationSize } = (ctx.varint)(buffer, offset + entityIdSize + effectIdSize + amplifierSize)
      let { value: hideParticles, size: hideParticlesSize } = (ctx.i8)(buffer, offset + entityIdSize + effectIdSize + amplifierSize + durationSize)
      let { value: factorCodec, size: factorCodecSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.nbt)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + effectIdSize + amplifierSize + durationSize + hideParticlesSize)
      return { value: { entityId, effectId, amplifier, duration, hideParticles, factorCodec }, size: entityIdSize + effectIdSize + amplifierSize + durationSize + hideParticlesSize + factorCodecSize}
    },
    packet_select_advancement_tab: (buffer, offset) => {
      let { value: id, size: idSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset)
      return { value: { id }, size: idSize}
    },
    packet_server_data: (buffer, offset) => {
      let { value: motd, size: motdSize } = (ctx.string)(buffer, offset)
      let { value: iconBytes, size: iconBytesSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          offset += countSize
          if (offset + count > buffer.length) {
            throw new PartialReadError()
          }
          return { value: buffer.slice(offset, offset + count), size: count + countSize }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + motdSize)
      let { value: enforcesSecureChat, size: enforcesSecureChatSize } = (ctx.bool)(buffer, offset + motdSize + iconBytesSize)
      return { value: { motd, iconBytes, enforcesSecureChat }, size: motdSize + iconBytesSize + enforcesSecureChatSize}
    },
    packet_declare_recipes: (buffer, offset) => {
      let { value: recipes, size: recipesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: type1, size: type1Size } = (ctx.string)(buffer, offset)
          let { value: recipeId, size: recipeIdSize } = (ctx.string)(buffer, offset + type1Size)
          let { value: data1, size: data1Size } = ((buffer, offset) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((buffer, offset) => {
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset)
                let { value: category1, size: category1Size } = (ctx.varint)(buffer, offset + group1Size)
                let { value: ingredients, size: ingredientsSize } = ((buffer, offset) => {
                  const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
                  if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                  const data = []
                  let size = countSize
                  for (let i = 0; i < count; i++) {
                    const elem = (ctx.ingredient)(buffer, offset + size)
                    data.push(elem.value)
                    size += elem.size
                  }
                  return { value: data, size }
                })(buffer, offset + group1Size + category1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + group1Size + category1Size + ingredientsSize)
                return { value: { group: group1, category: category1, ingredients, result: result1 }, size: group1Size + category1Size + ingredientsSize + result1Size}
              })(buffer, offset)
              case "minecraft:crafting_shaped": return ((buffer, offset) => {
                let { value: width, size: widthSize } = (ctx.varint)(buffer, offset)
                let { value: height, size: heightSize } = (ctx.varint)(buffer, offset + widthSize)
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset + widthSize + heightSize)
                let { value: category1, size: category1Size } = (ctx.varint)(buffer, offset + widthSize + heightSize + group1Size)
                let { value: ingredients, size: ingredientsSize } = ((buffer, offset) => {
                  const count = width
                  const countSize = 0
                  if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                  const data = []
                  let size = countSize
                  for (let i = 0; i < count; i++) {
                    const elem = ((buffer, offset) => {
                    const count = height
                    const countSize = 0
                    if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                    const data = []
                    let size = countSize
                    for (let i = 0; i < count; i++) {
                      const elem = (ctx.ingredient)(buffer, offset + size)
                      data.push(elem.value)
                      size += elem.size
                    }
                    return { value: data, size }
                  })(buffer, offset + size)
                    data.push(elem.value)
                    size += elem.size
                  }
                  return { value: data, size }
                })(buffer, offset + widthSize + heightSize + group1Size + category1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + widthSize + heightSize + group1Size + category1Size + ingredientsSize)
                let { value: showNotification, size: showNotificationSize } = (ctx.bool)(buffer, offset + widthSize + heightSize + group1Size + category1Size + ingredientsSize + result1Size)
                return { value: { width, height, group: group1, category: category1, ingredients, result: result1, showNotification }, size: widthSize + heightSize + group1Size + category1Size + ingredientsSize + result1Size + showNotificationSize}
              })(buffer, offset)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:stonecutting": return ((buffer, offset) => {
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset)
                let { value: ingredient1, size: ingredient1Size } = (ctx.ingredient)(buffer, offset + group1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + group1Size + ingredient1Size)
                return { value: { group: group1, ingredient: ingredient1, result: result1 }, size: group1Size + ingredient1Size + result1Size}
              })(buffer, offset)
              case "minecraft:smithing": return ((buffer, offset) => {
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + baseSize + additionSize)
                return { value: { base, addition, result: result1 }, size: baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:smithing_transform": return ((buffer, offset) => {
                let { value: template, size: templateSize } = (ctx.ingredient)(buffer, offset)
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset + templateSize)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + templateSize + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + templateSize + baseSize + additionSize)
                return { value: { template, base, addition, result: result1 }, size: templateSize + baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:smithing_trim": return ((buffer, offset) => {
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + baseSize + additionSize)
                return { value: { base, addition, result: result1 }, size: baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + type1Size + recipeIdSize)
          return { value: { type: type1, recipeId, data: data1 }, size: type1Size + recipeIdSize + data1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { recipes }, size: recipesSize}
    },
    packet_tags: (buffer, offset) => {
      let { value: tags, size: tagsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: tagType, size: tagTypeSize } = (ctx.string)(buffer, offset)
          let { value: tags1, size: tags1Size } = (ctx.tags)(buffer, offset + tagTypeSize)
          return { value: { tagType, tags: tags1 }, size: tagTypeSize + tags1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { tags }, size: tagsSize}
    },
    packet_acknowledge_player_digging: (buffer, offset) => {
      let { value: sequenceId, size: sequenceIdSize } = (ctx.varint)(buffer, offset)
      return { value: { sequenceId }, size: sequenceIdSize}
    },
    packet_clear_titles: (buffer, offset) => {
      let { value: reset, size: resetSize } = (ctx.bool)(buffer, offset)
      return { value: { reset }, size: resetSize}
    },
    packet_initialize_world_border: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize)
      let { value: oldDiameter, size: oldDiameterSize } = (ctx.f64)(buffer, offset + xSize + zSize)
      let { value: newDiameter, size: newDiameterSize } = (ctx.f64)(buffer, offset + xSize + zSize + oldDiameterSize)
      let { value: speed, size: speedSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize)
      let { value: portalTeleportBoundary, size: portalTeleportBoundarySize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize)
      let { value: warningBlocks, size: warningBlocksSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize)
      let { value: warningTime, size: warningTimeSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize + warningBlocksSize)
      return { value: { x, z, oldDiameter, newDiameter, speed, portalTeleportBoundary, warningBlocks, warningTime }, size: xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize + warningBlocksSize + warningTimeSize}
    },
    packet_action_bar: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_world_border_center: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize)
      return { value: { x, z }, size: xSize + zSize}
    },
    packet_world_border_lerp_size: (buffer, offset) => {
      let { value: oldDiameter, size: oldDiameterSize } = (ctx.f64)(buffer, offset)
      let { value: newDiameter, size: newDiameterSize } = (ctx.f64)(buffer, offset + oldDiameterSize)
      let { value: speed, size: speedSize } = (ctx.varint)(buffer, offset + oldDiameterSize + newDiameterSize)
      return { value: { oldDiameter, newDiameter, speed }, size: oldDiameterSize + newDiameterSize + speedSize}
    },
    packet_world_border_size: (buffer, offset) => {
      let { value: diameter, size: diameterSize } = (ctx.f64)(buffer, offset)
      return { value: { diameter }, size: diameterSize}
    },
    packet_world_border_warning_delay: (buffer, offset) => {
      let { value: warningTime, size: warningTimeSize } = (ctx.varint)(buffer, offset)
      return { value: { warningTime }, size: warningTimeSize}
    },
    packet_world_border_warning_reach: (buffer, offset) => {
      let { value: warningBlocks, size: warningBlocksSize } = (ctx.varint)(buffer, offset)
      return { value: { warningBlocks }, size: warningBlocksSize}
    },
    packet_ping: (buffer, offset) => {
      let { value: id, size: idSize } = (ctx.i32)(buffer, offset)
      return { value: { id }, size: idSize}
    },
    packet_set_title_subtitle: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_set_title_text: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_set_title_time: (buffer, offset) => {
      let { value: fadeIn, size: fadeInSize } = (ctx.i32)(buffer, offset)
      let { value: stay, size: staySize } = (ctx.i32)(buffer, offset + fadeInSize)
      let { value: fadeOut, size: fadeOutSize } = (ctx.i32)(buffer, offset + fadeInSize + staySize)
      return { value: { fadeIn, stay, fadeOut }, size: fadeInSize + staySize + fadeOutSize}
    },
    packet_simulation_distance: (buffer, offset) => {
      let { value: distance, size: distanceSize } = (ctx.varint)(buffer, offset)
      return { value: { distance }, size: distanceSize}
    },
    packet_chunk_biomes: (buffer, offset) => {
      let { value: biomes, size: biomesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: position1, size: position1Size } = (ctx.position)(buffer, offset)
          let { value: data1, size: data1Size } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + position1Size)
          return { value: { position: position1, data: data1 }, size: position1Size + data1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { biomes }, size: biomesSize}
    },
    packet_damage_event: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: sourceTypeId, size: sourceTypeIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      let { value: sourceCauseId, size: sourceCauseIdSize } = (ctx.varint)(buffer, offset + entityIdSize + sourceTypeIdSize)
      let { value: sourceDirectId, size: sourceDirectIdSize } = (ctx.varint)(buffer, offset + entityIdSize + sourceTypeIdSize + sourceCauseIdSize)
      let { value: sourcePosition, size: sourcePositionSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.vec3f64)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + sourceTypeIdSize + sourceCauseIdSize + sourceDirectIdSize)
      return { value: { entityId, sourceTypeId, sourceCauseId, sourceDirectId, sourcePosition }, size: entityIdSize + sourceTypeIdSize + sourceCauseIdSize + sourceDirectIdSize + sourcePositionSize}
    },
    packet_hurt_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + entityIdSize)
      return { value: { entityId, yaw }, size: entityIdSize + yawSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"bundle_delimiter","1":"spawn_entity","2":"spawn_entity_experience_orb","3":"named_entity_spawn","4":"animation","5":"statistics","6":"acknowledge_player_digging","7":"block_break_animation","8":"tile_entity_data","9":"block_action","10":"block_change","11":"boss_bar","12":"difficulty","13":"chunk_biomes","14":"clear_titles","15":"tab_complete","16":"declare_commands","17":"close_window","18":"window_items","19":"craft_progress_bar","20":"set_slot","21":"set_cooldown","22":"chat_suggestions","23":"custom_payload","24":"damage_event","25":"hide_message","26":"kick_disconnect","27":"profileless_chat","28":"entity_status","29":"explosion","30":"unload_chunk","31":"game_state_change","32":"open_horse_window","33":"hurt_animation","34":"initialize_world_border","35":"keep_alive","36":"map_chunk","37":"world_event","38":"world_particles","39":"update_light","40":"login","41":"map","42":"trade_list","43":"rel_entity_move","44":"entity_move_look","45":"entity_look","46":"vehicle_move","47":"open_book","48":"open_window","49":"open_sign_entity","50":"ping","51":"craft_recipe_response","52":"abilities","53":"player_chat","54":"end_combat_event","55":"enter_combat_event","56":"death_combat_event","57":"player_remove","58":"player_info","59":"face_player","60":"position","61":"unlock_recipes","62":"entity_destroy","63":"remove_entity_effect","64":"resource_pack_send","65":"respawn","66":"entity_head_rotation","67":"multi_block_change","68":"select_advancement_tab","69":"server_data","70":"action_bar","71":"world_border_center","72":"world_border_lerp_size","73":"world_border_size","74":"world_border_warning_delay","75":"world_border_warning_reach","76":"camera","77":"held_item_slot","78":"update_view_position","79":"update_view_distance","80":"spawn_position","81":"scoreboard_display_objective","82":"entity_metadata","83":"attach_entity","84":"entity_velocity","85":"entity_equipment","86":"experience","87":"update_health","88":"scoreboard_objective","89":"set_passengers","90":"teams","91":"scoreboard_score","92":"simulation_distance","93":"set_title_subtitle","94":"update_time","95":"set_title_text","96":"set_title_time","97":"entity_sound_effect","98":"sound_effect","99":"stop_sound","100":"system_chat","101":"playerlist_header","102":"nbt_query_response","103":"collect","104":"entity_teleport","105":"advancements","106":"entity_update_attributes","107":"feature_flags","108":"entity_effect","109":"declare_recipes","110":"tags"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(buffer, offset)
          case "spawn_entity": return (ctx.packet_spawn_entity)(buffer, offset)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(buffer, offset)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(buffer, offset)
          case "animation": return (ctx.packet_animation)(buffer, offset)
          case "statistics": return (ctx.packet_statistics)(buffer, offset)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(buffer, offset)
          case "block_break_animation": return (ctx.packet_block_break_animation)(buffer, offset)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(buffer, offset)
          case "block_action": return (ctx.packet_block_action)(buffer, offset)
          case "block_change": return (ctx.packet_block_change)(buffer, offset)
          case "boss_bar": return (ctx.packet_boss_bar)(buffer, offset)
          case "difficulty": return (ctx.packet_difficulty)(buffer, offset)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(buffer, offset)
          case "clear_titles": return (ctx.packet_clear_titles)(buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(buffer, offset)
          case "declare_commands": return (ctx.packet_declare_commands)(buffer, offset)
          case "close_window": return (ctx.packet_close_window)(buffer, offset)
          case "window_items": return (ctx.packet_window_items)(buffer, offset)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(buffer, offset)
          case "set_slot": return (ctx.packet_set_slot)(buffer, offset)
          case "set_cooldown": return (ctx.packet_set_cooldown)(buffer, offset)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(buffer, offset)
          case "damage_event": return (ctx.packet_damage_event)(buffer, offset)
          case "hide_message": return (ctx.packet_hide_message)(buffer, offset)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(buffer, offset)
          case "profileless_chat": return (ctx.packet_profileless_chat)(buffer, offset)
          case "entity_status": return (ctx.packet_entity_status)(buffer, offset)
          case "explosion": return (ctx.packet_explosion)(buffer, offset)
          case "unload_chunk": return (ctx.packet_unload_chunk)(buffer, offset)
          case "game_state_change": return (ctx.packet_game_state_change)(buffer, offset)
          case "open_horse_window": return (ctx.packet_open_horse_window)(buffer, offset)
          case "hurt_animation": return (ctx.packet_hurt_animation)(buffer, offset)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(buffer, offset)
          case "map_chunk": return (ctx.packet_map_chunk)(buffer, offset)
          case "world_event": return (ctx.packet_world_event)(buffer, offset)
          case "world_particles": return (ctx.packet_world_particles)(buffer, offset)
          case "update_light": return (ctx.packet_update_light)(buffer, offset)
          case "login": return (ctx.packet_login)(buffer, offset)
          case "map": return (ctx.packet_map)(buffer, offset)
          case "trade_list": return (ctx.packet_trade_list)(buffer, offset)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(buffer, offset)
          case "entity_move_look": return (ctx.packet_entity_move_look)(buffer, offset)
          case "entity_look": return (ctx.packet_entity_look)(buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(buffer, offset)
          case "open_book": return (ctx.packet_open_book)(buffer, offset)
          case "open_window": return (ctx.packet_open_window)(buffer, offset)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(buffer, offset)
          case "ping": return (ctx.packet_ping)(buffer, offset)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(buffer, offset)
          case "abilities": return (ctx.packet_abilities)(buffer, offset)
          case "player_chat": return (ctx.packet_player_chat)(buffer, offset)
          case "end_combat_event": return (ctx.packet_end_combat_event)(buffer, offset)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(buffer, offset)
          case "death_combat_event": return (ctx.packet_death_combat_event)(buffer, offset)
          case "player_remove": return (ctx.packet_player_remove)(buffer, offset)
          case "player_info": return (ctx.packet_player_info)(buffer, offset)
          case "face_player": return (ctx.packet_face_player)(buffer, offset)
          case "position": return (ctx.packet_position)(buffer, offset)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(buffer, offset)
          case "entity_destroy": return (ctx.packet_entity_destroy)(buffer, offset)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(buffer, offset)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(buffer, offset)
          case "respawn": return (ctx.packet_respawn)(buffer, offset)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(buffer, offset)
          case "multi_block_change": return (ctx.packet_multi_block_change)(buffer, offset)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(buffer, offset)
          case "server_data": return (ctx.packet_server_data)(buffer, offset)
          case "action_bar": return (ctx.packet_action_bar)(buffer, offset)
          case "world_border_center": return (ctx.packet_world_border_center)(buffer, offset)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(buffer, offset)
          case "world_border_size": return (ctx.packet_world_border_size)(buffer, offset)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(buffer, offset)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(buffer, offset)
          case "camera": return (ctx.packet_camera)(buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(buffer, offset)
          case "update_view_position": return (ctx.packet_update_view_position)(buffer, offset)
          case "update_view_distance": return (ctx.packet_update_view_distance)(buffer, offset)
          case "spawn_position": return (ctx.packet_spawn_position)(buffer, offset)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(buffer, offset)
          case "entity_metadata": return (ctx.packet_entity_metadata)(buffer, offset)
          case "attach_entity": return (ctx.packet_attach_entity)(buffer, offset)
          case "entity_velocity": return (ctx.packet_entity_velocity)(buffer, offset)
          case "entity_equipment": return (ctx.packet_entity_equipment)(buffer, offset)
          case "experience": return (ctx.packet_experience)(buffer, offset)
          case "update_health": return (ctx.packet_update_health)(buffer, offset)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(buffer, offset)
          case "set_passengers": return (ctx.packet_set_passengers)(buffer, offset)
          case "teams": return (ctx.packet_teams)(buffer, offset)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(buffer, offset)
          case "simulation_distance": return (ctx.packet_simulation_distance)(buffer, offset)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(buffer, offset)
          case "update_time": return (ctx.packet_update_time)(buffer, offset)
          case "set_title_text": return (ctx.packet_set_title_text)(buffer, offset)
          case "set_title_time": return (ctx.packet_set_title_time)(buffer, offset)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(buffer, offset)
          case "sound_effect": return (ctx.packet_sound_effect)(buffer, offset)
          case "stop_sound": return (ctx.packet_stop_sound)(buffer, offset)
          case "system_chat": return (ctx.packet_system_chat)(buffer, offset)
          case "playerlist_header": return (ctx.packet_playerlist_header)(buffer, offset)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(buffer, offset)
          case "collect": return (ctx.packet_collect)(buffer, offset)
          case "entity_teleport": return (ctx.packet_entity_teleport)(buffer, offset)
          case "advancements": return (ctx.packet_advancements)(buffer, offset)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(buffer, offset)
          case "feature_flags": return (ctx.packet_feature_flags)(buffer, offset)
          case "entity_effect": return (ctx.packet_entity_effect)(buffer, offset)
          case "declare_recipes": return (ctx.packet_declare_recipes)(buffer, offset)
          case "tags": return (ctx.packet_tags)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.u16)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.i32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.i32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.i16)(value)
        case "int": return (ctx.i32)(value)
        case "long": return (ctx.i64)(value)
        case "float": return (ctx.f32)(value)
        case "double": return (ctx.f64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.u16)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.i32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.i32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.i16)(value, buffer, offset)
        case "int": return (ctx.i32)(value, buffer, offset)
        case "long": return (ctx.i64)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "double": return (ctx.f64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.u16)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.i32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.i16)(buffer, offset)
        case "int": return (ctx.i32)(buffer, offset)
        case "long": return (ctx.i64)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "double": return (ctx.f64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.lu16)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.li32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.li32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.li16)(value)
        case "int": return (ctx.li32)(value)
        case "long": return (ctx.li64)(value)
        case "float": return (ctx.lf32)(value)
        case "double": return (ctx.lf64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.lu16)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.li32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.li32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.li16)(value, buffer, offset)
        case "int": return (ctx.li32)(value, buffer, offset)
        case "long": return (ctx.li64)(value, buffer, offset)
        case "float": return (ctx.lf32)(value, buffer, offset)
        case "double": return (ctx.lf64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.lu16)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.li32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.li16)(buffer, offset)
        case "int": return (ctx.li32)(buffer, offset)
        case "long": return (ctx.li64)(buffer, offset)
        case "float": return (ctx.lf32)(buffer, offset)
        case "double": return (ctx.lf64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value) => {
          let size = 1
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            })
          }
          return size
        },
    nbtTagName: function sizeOfPString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    byteArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.i8)(value[i])
      }
      return size
    },
    list: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let value1 = value.value
      size += ((value) => {
        let size = (ctx.zigzag32)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.nbtSwitch)(value[i], type)
        }
        return size
      })(value1)
      return size
    },
    intArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li32)(value[i])
      }
      return size
    },
    longArray: (value) => {
      let size = (ctx.zigzag32)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.li64)(value[i])
      }
      return size
    },
    nbtMapper: (value) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value)
    },
    nbtSwitch: (value, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value)
        case "byte": return (ctx.i8)(value)
        case "short": return (ctx.li16)(value)
        case "int": return (ctx.zigzag32)(value)
        case "long": return (ctx.zigzag64)(value)
        case "float": return (ctx.lf32)(value)
        case "double": return (ctx.lf64)(value)
        case "byteArray": return (ctx.byteArray)(value)
        case "string": return (ctx.shortString)(value)
        case "list": return (ctx.list)(value)
        case "compound": return (ctx.compound)(value)
        case "intArray": return (ctx.intArray)(value)
        case "longArray": return (ctx.longArray)(value)
        default: return (ctx.void)(value)
      }
    },
    nbt: (value) => {
      let size = 0
      let type = value.type
      size += (ctx.nbtMapper)(type)
      let name = value.name
      size += (ctx.nbtTagName)(name)
      let value1 = value.value
      size += (ctx.nbtSwitch)(value1, type)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset)
          }
          offset = ctx.i8(0, buffer, offset)
          return offset
        },
    nbtTagName: function writePString (...args) {
      return ctx.shortString(...args)
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    byteArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.i8)(value[i], buffer, offset)
      }
      return offset
    },
    list: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        offset = (ctx.zigzag32)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.nbtSwitch)(value[i], buffer, offset, type)
        }
        return offset
      })(value1, buffer, offset)
      return offset
    },
    intArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li32)(value[i], buffer, offset)
      }
      return offset
    },
    longArray: (value, buffer, offset) => {
      offset = (ctx.zigzag32)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.li64)(value[i], buffer, offset)
      }
      return offset
    },
    nbtMapper: (value, buffer, offset) => {
      return (ctx.i8)({"end":0,"byte":1,"short":2,"int":3,"long":4,"float":5,"double":6,"byteArray":7,"string":8,"list":9,"compound":10,"intArray":11,"longArray":12}[value] || value, buffer, offset)
    },
    nbtSwitch: (value, buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(value, buffer, offset)
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "short": return (ctx.li16)(value, buffer, offset)
        case "int": return (ctx.zigzag32)(value, buffer, offset)
        case "long": return (ctx.zigzag64)(value, buffer, offset)
        case "float": return (ctx.lf32)(value, buffer, offset)
        case "double": return (ctx.lf64)(value, buffer, offset)
        case "byteArray": return (ctx.byteArray)(value, buffer, offset)
        case "string": return (ctx.shortString)(value, buffer, offset)
        case "list": return (ctx.list)(value, buffer, offset)
        case "compound": return (ctx.compound)(value, buffer, offset)
        case "intArray": return (ctx.intArray)(value, buffer, offset)
        case "longArray": return (ctx.longArray)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    nbt: (value, buffer, offset) => {
      let type = value.type
      offset = (ctx.nbtMapper)(type, buffer, offset)
      let name = value.name
      offset = (ctx.nbtTagName)(name, buffer, offset)
      let value1 = value.value
      offset = (ctx.nbtSwitch)(value1, buffer, offset, type)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    compound: (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          }
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset)
            if (typ.value === 0) {
              results.size += typ.size
              break
            }
    
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`)
            }
    
            const readResults = ctx.nbt(buffer, offset)
            offset += readResults.size
            results.size += readResults.size
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            }
          }
          return results
        },
    nbtTagName: function readPString (buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset)
      for (const c of value) {
        if (c === '\0') throw new Error('unexpected tag end')
      }
      return { value, size }
    },
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    zigzag64: native.zigzag64,
    zigzag32: native.zigzag32,
    container: native.container,
    switch: native.switch,
    shortString: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    byteArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.i8)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    list: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.nbtSwitch)(buffer, offset + size, type)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + typeSize)
      return { value: { type, value: value1 }, size: typeSize + value1Size}
    },
    intArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li32)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    longArray: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.zigzag32)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.li64)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    nbtMapper: (buffer, offset) => {
      const { value, size } = (ctx.i8)(buffer, offset)
      return { value: {"0":"end","1":"byte","2":"short","3":"int","4":"long","5":"float","6":"double","7":"byteArray","8":"string","9":"list","10":"compound","11":"intArray","12":"longArray"}[value] || value, size }
    },
    nbtSwitch: (buffer, offset, $type) => {
      switch ($type) {
        case "end": return (ctx.void)(buffer, offset)
        case "byte": return (ctx.i8)(buffer, offset)
        case "short": return (ctx.li16)(buffer, offset)
        case "int": return (ctx.zigzag32)(buffer, offset)
        case "long": return (ctx.zigzag64)(buffer, offset)
        case "float": return (ctx.lf32)(buffer, offset)
        case "double": return (ctx.lf64)(buffer, offset)
        case "byteArray": return (ctx.byteArray)(buffer, offset)
        case "string": return (ctx.shortString)(buffer, offset)
        case "list": return (ctx.list)(buffer, offset)
        case "compound": return (ctx.compound)(buffer, offset)
        case "intArray": return (ctx.intArray)(buffer, offset)
        case "longArray": return (ctx.longArray)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    nbt: (buffer, offset) => {
      let { value: type, size: typeSize } = (ctx.nbtMapper)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.nbtTagName)(buffer, offset + typeSize)
      let { value: value1, size: value1Size } = (ctx.nbtSwitch)(buffer, offset + typeSize + nameSize, type)
      return { value: { type, name, value: value1 }, size: typeSize + nameSize + value1Size}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_set_protocol: (value) => {
      let size = 0
      let protocolVersion = value.protocolVersion
      size += (ctx.varint)(protocolVersion)
      let serverHost = value.serverHost
      size += (ctx.string)(serverHost)
      let serverPort = value.serverPort
      size += (ctx.u16)(serverPort)
      let nextState = value.nextState
      size += (ctx.varint)(nextState)
      return size
    },
    packet_legacy_server_list_ping: (value) => {
      let size = 0
      let payload = value.payload
      size += (ctx.u8)(payload)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"set_protocol":0,"legacy_server_list_ping":254}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(value)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_set_protocol: (value, buffer, offset) => {
      let protocolVersion = value.protocolVersion
      offset = (ctx.varint)(protocolVersion, buffer, offset)
      let serverHost = value.serverHost
      offset = (ctx.string)(serverHost, buffer, offset)
      let serverPort = value.serverPort
      offset = (ctx.u16)(serverPort, buffer, offset)
      let nextState = value.nextState
      offset = (ctx.varint)(nextState, buffer, offset)
      return offset
    },
    packet_legacy_server_list_ping: (value, buffer, offset) => {
      let payload = value.payload
      offset = (ctx.u8)(payload, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"set_protocol":0,"legacy_server_list_ping":254}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(value, buffer, offset)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_set_protocol: (buffer, offset) => {
      let { value: protocolVersion, size: protocolVersionSize } = (ctx.varint)(buffer, offset)
      let { value: serverHost, size: serverHostSize } = (ctx.string)(buffer, offset + protocolVersionSize)
      let { value: serverPort, size: serverPortSize } = (ctx.u16)(buffer, offset + protocolVersionSize + serverHostSize)
      let { value: nextState, size: nextStateSize } = (ctx.varint)(buffer, offset + protocolVersionSize + serverHostSize + serverPortSize)
      return { value: { protocolVersion, serverHost, serverPort, nextState }, size: protocolVersionSize + serverHostSize + serverPortSize + nextStateSize}
    },
    packet_legacy_server_list_ping: (buffer, offset) => {
      let { value: payload, size: payloadSize } = (ctx.u8)(buffer, offset)
      return { value: { payload }, size: payloadSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"set_protocol","254":"legacy_server_list_ping"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "set_protocol": return (ctx.packet_set_protocol)(buffer, offset)
          case "legacy_server_list_ping": return (ctx.packet_legacy_server_list_ping)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_spawn_entity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let objectUUID = value.objectUUID
      size += (ctx.UUID)(objectUUID)
      let type = value.type
      size += (ctx.varint)(type)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let headPitch = value.headPitch
      size += (ctx.i8)(headPitch)
      let objectData = value.objectData
      size += (ctx.varint)(objectData)
      let velocityX = value.velocityX
      size += (ctx.i16)(velocityX)
      let velocityY = value.velocityY
      size += (ctx.i16)(velocityY)
      let velocityZ = value.velocityZ
      size += (ctx.i16)(velocityZ)
      return size
    },
    packet_spawn_entity_experience_orb: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let count = value.count
      size += (ctx.i16)(count)
      return size
    },
    packet_named_entity_spawn: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let playerUUID = value.playerUUID
      size += (ctx.UUID)(playerUUID)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      return size
    },
    packet_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let animation = value.animation
      size += (ctx.u8)(animation)
      return size
    },
    packet_statistics: (value) => {
      let size = 0
      let entries = value.entries
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let categoryId = value.categoryId
          size += (ctx.varint)(categoryId)
          let statisticId = value.statisticId
          size += (ctx.varint)(statisticId)
          let value1 = value.value
          size += (ctx.varint)(value1)
          return size
        })(value[i])
        }
        return size
      })(entries)
      return size
    },
    packet_advancements: (value) => {
      let size = 0
      let reset = value.reset
      size += (ctx.bool)(reset)
      let advancementMapping = value.advancementMapping
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += ((value) => {
            let size = 0
            let parentId = value.parentId
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.string)(value)
              }
              return 1
            })(parentId)
            let displayData = value.displayData
            size += ((value) => {
              if (value != null) {
                return 1 + ((value) => {
                let size = 0
                let title = value.title
                size += (ctx.string)(title)
                let description = value.description
                size += (ctx.string)(description)
                let icon = value.icon
                size += (ctx.slot)(icon)
                let frameType = value.frameType
                size += (ctx.varint)(frameType)
                let flags1 = value.flags
                size += 4
                let backgroundTexture = value.backgroundTexture
                size += ((value) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(value)
                    default: return (ctx.void)(value)
                  }
                })(backgroundTexture)
                let xCord = value.xCord
                size += (ctx.f32)(xCord)
                let yCord = value.yCord
                size += (ctx.f32)(yCord)
                return size
              })(value)
              }
              return 1
            })(displayData)
            let criteria = value.criteria
            size += ((value) => {
              let size = (ctx.varint)(value.length)
              for (let i = 0; i < value.length; i++) {
                size += ((value) => {
                let size = 0
                let key1 = value.key
                size += (ctx.string)(key1)
                let value2 = value.value
                size += (ctx.void)(value2)
                return size
              })(value[i])
              }
              return size
            })(criteria)
            let requirements = value.requirements
            size += ((value) => {
              let size = (ctx.varint)(value.length)
              for (let i = 0; i < value.length; i++) {
                size += ((value) => {
                let size = (ctx.varint)(value.length)
                for (let i = 0; i < value.length; i++) {
                  size += (ctx.string)(value[i])
                }
                return size
              })(value[i])
              }
              return size
            })(requirements)
            return size
          })(value1)
          return size
        })(value[i])
        }
        return size
      })(advancementMapping)
      let identifiers = value.identifiers
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(identifiers)
      let progressMapping = value.progressMapping
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += ((value) => {
              let size = 0
              let criterionIdentifier = value.criterionIdentifier
              size += (ctx.string)(criterionIdentifier)
              let criterionProgress = value.criterionProgress
              size += ((value) => {
                if (value != null) {
                  return 1 + (ctx.i64)(value)
                }
                return 1
              })(criterionProgress)
              return size
            })(value[i])
            }
            return size
          })(value1)
          return size
        })(value[i])
        }
        return size
      })(progressMapping)
      return size
    },
    packet_block_break_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let location = value.location
      size += (ctx.position)(location)
      let destroyStage = value.destroyStage
      size += (ctx.i8)(destroyStage)
      return size
    },
    packet_tile_entity_data: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let action = value.action
      size += (ctx.varint)(action)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    packet_block_action: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let byte1 = value.byte1
      size += (ctx.u8)(byte1)
      let byte2 = value.byte2
      size += (ctx.u8)(byte2)
      let blockId = value.blockId
      size += (ctx.varint)(blockId)
      return size
    },
    packet_block_change: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let type = value.type
      size += (ctx.varint)(type)
      return size
    },
    packet_boss_bar: (value) => {
      let size = 0
      let entityUUID = value.entityUUID
      size += (ctx.UUID)(entityUUID)
      let action = value.action
      size += (ctx.varint)(action)
      let title = value.title
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.string)(value)
          case 3: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(title)
      let health = value.health
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.f32)(value)
          case 2: return (ctx.f32)(value)
          default: return (ctx.void)(value)
        }
      })(health)
      let color = value.color
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 4: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(color)
      let dividers = value.dividers
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 4: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(dividers)
      let flags = value.flags
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.u8)(value)
          case 5: return (ctx.u8)(value)
          default: return (ctx.void)(value)
        }
      })(flags)
      return size
    },
    packet_difficulty: (value) => {
      let size = 0
      let difficulty = value.difficulty
      size += (ctx.u8)(difficulty)
      let difficultyLocked = value.difficultyLocked
      size += (ctx.bool)(difficultyLocked)
      return size
    },
    packet_tab_complete: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let start = value.start
      size += (ctx.varint)(start)
      let length = value.length
      size += (ctx.varint)(length)
      let matches = value.matches
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let match = value.match
          size += (ctx.string)(match)
          let tooltip = value.tooltip
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(tooltip)
          return size
        })(value[i])
        }
        return size
      })(matches)
      return size
    },
    packet_declare_commands: (value) => {
      let size = 0
      let nodes = value.nodes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.command_node)(value[i])
        }
        return size
      })(nodes)
      let rootIndex = value.rootIndex
      size += (ctx.varint)(rootIndex)
      return size
    },
    packet_face_player: (value) => {
      let size = 0
      let feet_eyes = value.feet_eyes
      size += (ctx.varint)(feet_eyes)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let isEntity = value.isEntity
      size += (ctx.bool)(isEntity)
      let entityId = value.entityId
      size += ((value) => {
        switch (isEntity) {
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(entityId)
      let entity_feet_eyes = value.entity_feet_eyes
      size += ((value) => {
        switch (isEntity) {
          case true: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(entity_feet_eyes)
      return size
    },
    packet_nbt_query_response: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let nbt = value.nbt
      size += (ctx.optionalNbt)(nbt)
      return size
    },
    packet_multi_block_change: (value) => {
      let size = 0
      let chunkCoordinates = value.chunkCoordinates
      size += 8
      let suppressLightUpdates = value.suppressLightUpdates
      size += (ctx.bool)(suppressLightUpdates)
      let records = value.records
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(records)
      return size
    },
    packet_close_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      return size
    },
    packet_open_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.varint)(windowId)
      let inventoryType = value.inventoryType
      size += (ctx.varint)(inventoryType)
      let windowTitle = value.windowTitle
      size += (ctx.string)(windowTitle)
      return size
    },
    packet_window_items: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let stateId = value.stateId
      size += (ctx.varint)(stateId)
      let items = value.items
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.slot)(value[i])
        }
        return size
      })(items)
      let carriedItem = value.carriedItem
      size += (ctx.slot)(carriedItem)
      return size
    },
    packet_craft_progress_bar: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let property = value.property
      size += (ctx.i16)(property)
      let value1 = value.value
      size += (ctx.i16)(value1)
      return size
    },
    packet_set_slot: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let stateId = value.stateId
      size += (ctx.varint)(stateId)
      let slot = value.slot
      size += (ctx.i16)(slot)
      let item = value.item
      size += (ctx.slot)(item)
      return size
    },
    packet_set_cooldown: (value) => {
      let size = 0
      let itemID = value.itemID
      size += (ctx.varint)(itemID)
      let cooldownTicks = value.cooldownTicks
      size += (ctx.varint)(cooldownTicks)
      return size
    },
    packet_chat_suggestions: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.varint)(action)
      let entries = value.entries
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(entries)
      return size
    },
    packet_custom_payload: (value) => {
      let size = 0
      let channel = value.channel
      size += (ctx.string)(channel)
      let data = value.data
      size += (ctx.restBuffer)(data)
      return size
    },
    packet_hide_message: (value) => {
      let size = 0
      let id = value.id
      size += (ctx.varint)(id)
      let signature = value.signature
      size += ((value) => {
        switch (id) {
          case 0: return ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(signature)
      return size
    },
    packet_kick_disconnect: (value) => {
      let size = 0
      let reason = value.reason
      size += (ctx.string)(reason)
      return size
    },
    packet_profileless_chat: (value) => {
      let size = 0
      let message = value.message
      size += (ctx.string)(message)
      let type = value.type
      size += (ctx.varint)(type)
      let name = value.name
      size += (ctx.string)(name)
      let target = value.target
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(target)
      return size
    },
    packet_entity_status: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let entityStatus = value.entityStatus
      size += (ctx.i8)(entityStatus)
      return size
    },
    packet_explosion: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let radius = value.radius
      size += (ctx.f32)(radius)
      let affectedBlockOffsets = value.affectedBlockOffsets
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let x1 = value.x
          size += (ctx.i8)(x1)
          let y1 = value.y
          size += (ctx.i8)(y1)
          let z1 = value.z
          size += (ctx.i8)(z1)
          return size
        })(value[i])
        }
        return size
      })(affectedBlockOffsets)
      let playerMotionX = value.playerMotionX
      size += (ctx.f32)(playerMotionX)
      let playerMotionY = value.playerMotionY
      size += (ctx.f32)(playerMotionY)
      let playerMotionZ = value.playerMotionZ
      size += (ctx.f32)(playerMotionZ)
      return size
    },
    packet_unload_chunk: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.i32)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.i32)(chunkZ)
      return size
    },
    packet_game_state_change: (value) => {
      let size = 0
      let reason = value.reason
      size += (ctx.u8)(reason)
      let gameMode = value.gameMode
      size += (ctx.f32)(gameMode)
      return size
    },
    packet_open_horse_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let nbSlots = value.nbSlots
      size += (ctx.varint)(nbSlots)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      return size
    },
    packet_keep_alive: (value) => {
      let size = 0
      let keepAliveId = value.keepAliveId
      size += (ctx.i64)(keepAliveId)
      return size
    },
    packet_map_chunk: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.i32)(x)
      let z = value.z
      size += (ctx.i32)(z)
      let heightmaps = value.heightmaps
      size += (ctx.nbt)(heightmaps)
      let chunkData = value.chunkData
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(chunkData)
      let blockEntities = value.blockEntities
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.chunkBlockEntity)(value[i])
        }
        return size
      })(blockEntities)
      let trustEdges = value.trustEdges
      size += (ctx.bool)(trustEdges)
      let skyLightMask = value.skyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(skyLightMask)
      let blockLightMask = value.blockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(blockLightMask)
      let emptySkyLightMask = value.emptySkyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptySkyLightMask)
      let emptyBlockLightMask = value.emptyBlockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptyBlockLightMask)
      let skyLight = value.skyLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(skyLight)
      let blockLight = value.blockLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(blockLight)
      return size
    },
    packet_world_event: (value) => {
      let size = 0
      let effectId = value.effectId
      size += (ctx.i32)(effectId)
      let location = value.location
      size += (ctx.position)(location)
      let data = value.data
      size += (ctx.i32)(data)
      let global = value.global
      size += (ctx.bool)(global)
      return size
    },
    packet_world_particles: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let longDistance = value.longDistance
      size += (ctx.bool)(longDistance)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let offsetX = value.offsetX
      size += (ctx.f32)(offsetX)
      let offsetY = value.offsetY
      size += (ctx.f32)(offsetY)
      let offsetZ = value.offsetZ
      size += (ctx.f32)(offsetZ)
      let particleData = value.particleData
      size += (ctx.f32)(particleData)
      let particles = value.particles
      size += (ctx.i32)(particles)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    packet_update_light: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.varint)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.varint)(chunkZ)
      let trustEdges = value.trustEdges
      size += (ctx.bool)(trustEdges)
      let skyLightMask = value.skyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(skyLightMask)
      let blockLightMask = value.blockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(blockLightMask)
      let emptySkyLightMask = value.emptySkyLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptySkyLightMask)
      let emptyBlockLightMask = value.emptyBlockLightMask
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.i64)(value[i])
        }
        return size
      })(emptyBlockLightMask)
      let skyLight = value.skyLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(skyLight)
      let blockLight = value.blockLight
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.u8)(value[i])
          }
          return size
        })(value[i])
        }
        return size
      })(blockLight)
      return size
    },
    packet_login: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let isHardcore = value.isHardcore
      size += (ctx.bool)(isHardcore)
      let gameMode = value.gameMode
      size += (ctx.u8)(gameMode)
      let previousGameMode = value.previousGameMode
      size += (ctx.i8)(previousGameMode)
      let worldNames = value.worldNames
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(worldNames)
      let dimensionCodec = value.dimensionCodec
      size += (ctx.nbt)(dimensionCodec)
      let worldType = value.worldType
      size += (ctx.string)(worldType)
      let worldName = value.worldName
      size += (ctx.string)(worldName)
      let hashedSeed = value.hashedSeed
      size += (ctx.i64)(hashedSeed)
      let maxPlayers = value.maxPlayers
      size += (ctx.varint)(maxPlayers)
      let viewDistance = value.viewDistance
      size += (ctx.varint)(viewDistance)
      let simulationDistance = value.simulationDistance
      size += (ctx.varint)(simulationDistance)
      let reducedDebugInfo = value.reducedDebugInfo
      size += (ctx.bool)(reducedDebugInfo)
      let enableRespawnScreen = value.enableRespawnScreen
      size += (ctx.bool)(enableRespawnScreen)
      let isDebug = value.isDebug
      size += (ctx.bool)(isDebug)
      let isFlat = value.isFlat
      size += (ctx.bool)(isFlat)
      let death = value.death
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = 0
          let dimensionName = value.dimensionName
          size += (ctx.string)(dimensionName)
          let location1 = value.location
          size += (ctx.position)(location1)
          return size
        })(value)
        }
        return 1
      })(death)
      return size
    },
    packet_map: (value) => {
      let size = 0
      let itemDamage = value.itemDamage
      size += (ctx.varint)(itemDamage)
      let scale = value.scale
      size += (ctx.i8)(scale)
      let locked = value.locked
      size += (ctx.bool)(locked)
      let icons = value.icons
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += ((value) => {
            let size = 0
            let type1 = value.type
            size += (ctx.varint)(type1)
            let x1 = value.x
            size += (ctx.i8)(x1)
            let z1 = value.z
            size += (ctx.i8)(z1)
            let direction = value.direction
            size += (ctx.u8)(direction)
            let displayName = value.displayName
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.string)(value)
              }
              return 1
            })(displayName)
            return size
          })(value[i])
          }
          return size
        })(value)
        }
        return 1
      })(icons)
      let columns = value.columns
      size += (ctx.u8)(columns)
      let rows = value.rows
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(rows)
      let x = value.x
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(x)
      let y = value.y
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return (ctx.u8)(value)
        }
      })(y)
      let data = value.data
      size += ((value) => {
        switch (columns) {
          case 0: return (ctx.void)(value)
          default: return ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(value)
        }
      })(data)
      return size
    },
    packet_trade_list: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.varint)(windowId)
      let trades = value.trades
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let inputItem1 = value.inputItem1
          size += (ctx.slot)(inputItem1)
          let outputItem = value.outputItem
          size += (ctx.slot)(outputItem)
          let inputItem2 = value.inputItem2
          size += (ctx.slot)(inputItem2)
          let tradeDisabled = value.tradeDisabled
          size += (ctx.bool)(tradeDisabled)
          let nbTradeUses = value.nbTradeUses
          size += (ctx.i32)(nbTradeUses)
          let maximumNbTradeUses = value.maximumNbTradeUses
          size += (ctx.i32)(maximumNbTradeUses)
          let xp = value.xp
          size += (ctx.i32)(xp)
          let specialPrice = value.specialPrice
          size += (ctx.i32)(specialPrice)
          let priceMultiplier = value.priceMultiplier
          size += (ctx.f32)(priceMultiplier)
          let demand = value.demand
          size += (ctx.i32)(demand)
          return size
        })(value[i])
        }
        return size
      })(trades)
      let villagerLevel = value.villagerLevel
      size += (ctx.varint)(villagerLevel)
      let experience = value.experience
      size += (ctx.varint)(experience)
      let isRegularVillager = value.isRegularVillager
      size += (ctx.bool)(isRegularVillager)
      let canRestock = value.canRestock
      size += (ctx.bool)(canRestock)
      return size
    },
    packet_rel_entity_move: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let dX = value.dX
      size += (ctx.i16)(dX)
      let dY = value.dY
      size += (ctx.i16)(dY)
      let dZ = value.dZ
      size += (ctx.i16)(dZ)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_move_look: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let dX = value.dX
      size += (ctx.i16)(dX)
      let dY = value.dY
      size += (ctx.i16)(dY)
      let dZ = value.dZ
      size += (ctx.i16)(dZ)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_look: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_vehicle_move: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      return size
    },
    packet_open_book: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      return size
    },
    packet_open_sign_entity: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      return size
    },
    packet_craft_recipe_response: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let recipe = value.recipe
      size += (ctx.string)(recipe)
      return size
    },
    packet_abilities: (value) => {
      let size = 0
      let flags = value.flags
      size += (ctx.i8)(flags)
      let flyingSpeed = value.flyingSpeed
      size += (ctx.f32)(flyingSpeed)
      let walkingSpeed = value.walkingSpeed
      size += (ctx.f32)(walkingSpeed)
      return size
    },
    packet_player_chat: (value) => {
      let size = 0
      let senderUuid = value.senderUuid
      size += (ctx.UUID)(senderUuid)
      let index = value.index
      size += (ctx.varint)(index)
      let signature = value.signature
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = value instanceof Buffer ? value.length : Buffer.from(value).length
          return size
        })(value)
        }
        return 1
      })(signature)
      let plainMessage = value.plainMessage
      size += (ctx.string)(plainMessage)
      let timestamp = value.timestamp
      size += (ctx.i64)(timestamp)
      let salt = value.salt
      size += (ctx.i64)(salt)
      let previousMessages = value.previousMessages
      size += (ctx.previousMessages)(previousMessages)
      let unsignedChatContent = value.unsignedChatContent
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(unsignedChatContent)
      let filterType = value.filterType
      size += (ctx.varint)(filterType)
      let filterTypeMask = value.filterTypeMask
      size += ((value) => {
        switch (filterType) {
          case 2: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.i64)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(filterTypeMask)
      let type = value.type
      size += (ctx.varint)(type)
      let networkName = value.networkName
      size += (ctx.string)(networkName)
      let networkTargetName = value.networkTargetName
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(networkTargetName)
      return size
    },
    packet_end_combat_event: (value) => {
      let size = 0
      let duration = value.duration
      size += (ctx.varint)(duration)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      return size
    },
    packet_enter_combat_event: (value) => {
      let size = 0
      return size
    },
    packet_death_combat_event: (value) => {
      let size = 0
      let playerId = value.playerId
      size += (ctx.varint)(playerId)
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let message = value.message
      size += (ctx.string)(message)
      return size
    },
    packet_player_remove: (value) => {
      let size = 0
      let players = value.players
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.UUID)(value[i])
        }
        return size
      })(players)
      return size
    },
    packet_player_info: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.i8)(action)
      let data = value.data
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let uuid = value.uuid
          size += (ctx.UUID)(uuid)
          let player = value.player
          size += ((value) => {
            switch (action) {
              case 1: return (ctx.game_profile)(value)
              case 3: return (ctx.game_profile)(value)
              case 5: return (ctx.game_profile)(value)
              case 7: return (ctx.game_profile)(value)
              case 9: return (ctx.game_profile)(value)
              case 11: return (ctx.game_profile)(value)
              case 13: return (ctx.game_profile)(value)
              case 15: return (ctx.game_profile)(value)
              case 17: return (ctx.game_profile)(value)
              case 19: return (ctx.game_profile)(value)
              case 21: return (ctx.game_profile)(value)
              case 23: return (ctx.game_profile)(value)
              case 25: return (ctx.game_profile)(value)
              case 27: return (ctx.game_profile)(value)
              case 29: return (ctx.game_profile)(value)
              case 31: return (ctx.game_profile)(value)
              case 33: return (ctx.game_profile)(value)
              case 35: return (ctx.game_profile)(value)
              case 37: return (ctx.game_profile)(value)
              case 39: return (ctx.game_profile)(value)
              case 41: return (ctx.game_profile)(value)
              case 43: return (ctx.game_profile)(value)
              case 45: return (ctx.game_profile)(value)
              case 47: return (ctx.game_profile)(value)
              case 49: return (ctx.game_profile)(value)
              case 51: return (ctx.game_profile)(value)
              case 53: return (ctx.game_profile)(value)
              case 55: return (ctx.game_profile)(value)
              case 57: return (ctx.game_profile)(value)
              case 59: return (ctx.game_profile)(value)
              case 61: return (ctx.game_profile)(value)
              case 63: return (ctx.game_profile)(value)
              default: return (ctx.void)(value)
            }
          })(player)
          let chatSession = value.chatSession
          size += ((value) => {
            switch (action) {
              case 2: return (ctx.chat_session)(value)
              case 3: return (ctx.chat_session)(value)
              case 6: return (ctx.chat_session)(value)
              case 7: return (ctx.chat_session)(value)
              case 10: return (ctx.chat_session)(value)
              case 11: return (ctx.chat_session)(value)
              case 14: return (ctx.chat_session)(value)
              case 15: return (ctx.chat_session)(value)
              case 18: return (ctx.chat_session)(value)
              case 19: return (ctx.chat_session)(value)
              case 22: return (ctx.chat_session)(value)
              case 23: return (ctx.chat_session)(value)
              case 26: return (ctx.chat_session)(value)
              case 27: return (ctx.chat_session)(value)
              case 30: return (ctx.chat_session)(value)
              case 31: return (ctx.chat_session)(value)
              case 34: return (ctx.chat_session)(value)
              case 35: return (ctx.chat_session)(value)
              case 38: return (ctx.chat_session)(value)
              case 39: return (ctx.chat_session)(value)
              case 42: return (ctx.chat_session)(value)
              case 43: return (ctx.chat_session)(value)
              case 46: return (ctx.chat_session)(value)
              case 47: return (ctx.chat_session)(value)
              case 50: return (ctx.chat_session)(value)
              case 51: return (ctx.chat_session)(value)
              case 54: return (ctx.chat_session)(value)
              case 55: return (ctx.chat_session)(value)
              case 58: return (ctx.chat_session)(value)
              case 59: return (ctx.chat_session)(value)
              case 62: return (ctx.chat_session)(value)
              case 63: return (ctx.chat_session)(value)
              default: return (ctx.void)(value)
            }
          })(chatSession)
          let gamemode = value.gamemode
          size += ((value) => {
            switch (action) {
              case 4: return (ctx.varint)(value)
              case 5: return (ctx.varint)(value)
              case 6: return (ctx.varint)(value)
              case 7: return (ctx.varint)(value)
              case 12: return (ctx.varint)(value)
              case 13: return (ctx.varint)(value)
              case 14: return (ctx.varint)(value)
              case 15: return (ctx.varint)(value)
              case 20: return (ctx.varint)(value)
              case 21: return (ctx.varint)(value)
              case 22: return (ctx.varint)(value)
              case 23: return (ctx.varint)(value)
              case 28: return (ctx.varint)(value)
              case 29: return (ctx.varint)(value)
              case 30: return (ctx.varint)(value)
              case 31: return (ctx.varint)(value)
              case 36: return (ctx.varint)(value)
              case 37: return (ctx.varint)(value)
              case 38: return (ctx.varint)(value)
              case 39: return (ctx.varint)(value)
              case 44: return (ctx.varint)(value)
              case 45: return (ctx.varint)(value)
              case 46: return (ctx.varint)(value)
              case 47: return (ctx.varint)(value)
              case 52: return (ctx.varint)(value)
              case 53: return (ctx.varint)(value)
              case 54: return (ctx.varint)(value)
              case 55: return (ctx.varint)(value)
              case 60: return (ctx.varint)(value)
              case 61: return (ctx.varint)(value)
              case 62: return (ctx.varint)(value)
              case 63: return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(gamemode)
          let listed = value.listed
          size += ((value) => {
            switch (action) {
              case 8: return (ctx.bool)(value)
              case 9: return (ctx.bool)(value)
              case 10: return (ctx.bool)(value)
              case 11: return (ctx.bool)(value)
              case 12: return (ctx.bool)(value)
              case 13: return (ctx.bool)(value)
              case 14: return (ctx.bool)(value)
              case 15: return (ctx.bool)(value)
              case 24: return (ctx.bool)(value)
              case 25: return (ctx.bool)(value)
              case 26: return (ctx.bool)(value)
              case 27: return (ctx.bool)(value)
              case 28: return (ctx.bool)(value)
              case 29: return (ctx.bool)(value)
              case 30: return (ctx.bool)(value)
              case 31: return (ctx.bool)(value)
              case 40: return (ctx.bool)(value)
              case 41: return (ctx.bool)(value)
              case 42: return (ctx.bool)(value)
              case 43: return (ctx.bool)(value)
              case 44: return (ctx.bool)(value)
              case 45: return (ctx.bool)(value)
              case 46: return (ctx.bool)(value)
              case 47: return (ctx.bool)(value)
              case 56: return (ctx.bool)(value)
              case 57: return (ctx.bool)(value)
              case 58: return (ctx.bool)(value)
              case 59: return (ctx.bool)(value)
              case 60: return (ctx.bool)(value)
              case 61: return (ctx.bool)(value)
              case 62: return (ctx.bool)(value)
              case 63: return (ctx.bool)(value)
              default: return (ctx.void)(value)
            }
          })(listed)
          let latency = value.latency
          size += ((value) => {
            switch (action) {
              case 16: return (ctx.varint)(value)
              case 17: return (ctx.varint)(value)
              case 18: return (ctx.varint)(value)
              case 19: return (ctx.varint)(value)
              case 20: return (ctx.varint)(value)
              case 21: return (ctx.varint)(value)
              case 22: return (ctx.varint)(value)
              case 23: return (ctx.varint)(value)
              case 24: return (ctx.varint)(value)
              case 25: return (ctx.varint)(value)
              case 26: return (ctx.varint)(value)
              case 27: return (ctx.varint)(value)
              case 28: return (ctx.varint)(value)
              case 29: return (ctx.varint)(value)
              case 30: return (ctx.varint)(value)
              case 31: return (ctx.varint)(value)
              case 48: return (ctx.varint)(value)
              case 49: return (ctx.varint)(value)
              case 50: return (ctx.varint)(value)
              case 51: return (ctx.varint)(value)
              case 52: return (ctx.varint)(value)
              case 53: return (ctx.varint)(value)
              case 54: return (ctx.varint)(value)
              case 55: return (ctx.varint)(value)
              case 56: return (ctx.varint)(value)
              case 57: return (ctx.varint)(value)
              case 58: return (ctx.varint)(value)
              case 59: return (ctx.varint)(value)
              case 60: return (ctx.varint)(value)
              case 61: return (ctx.varint)(value)
              case 62: return (ctx.varint)(value)
              case 63: return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(latency)
          let displayName = value.displayName
          size += ((value) => {
            switch (action) {
              case 32: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 33: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 34: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 35: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 36: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 37: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 38: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 39: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 40: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 41: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 42: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 43: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 44: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 45: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 46: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 47: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 48: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 49: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 50: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 51: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 52: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 53: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 54: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 55: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 56: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 57: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 58: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 59: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 60: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 61: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 62: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              case 63: return ((value) => {
                if (value != null) {
                  return 1 + (ctx.string)(value)
                }
                return 1
              })(value)
              default: return (ctx.void)(value)
            }
          })(displayName)
          return size
        })(value[i])
        }
        return size
      })(data)
      return size
    },
    packet_position: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let flags = value.flags
      size += (ctx.i8)(flags)
      let teleportId = value.teleportId
      size += (ctx.varint)(teleportId)
      return size
    },
    packet_unlock_recipes: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.varint)(action)
      let craftingBookOpen = value.craftingBookOpen
      size += (ctx.bool)(craftingBookOpen)
      let filteringCraftable = value.filteringCraftable
      size += (ctx.bool)(filteringCraftable)
      let smeltingBookOpen = value.smeltingBookOpen
      size += (ctx.bool)(smeltingBookOpen)
      let filteringSmeltable = value.filteringSmeltable
      size += (ctx.bool)(filteringSmeltable)
      let blastFurnaceOpen = value.blastFurnaceOpen
      size += (ctx.bool)(blastFurnaceOpen)
      let filteringBlastFurnace = value.filteringBlastFurnace
      size += (ctx.bool)(filteringBlastFurnace)
      let smokerBookOpen = value.smokerBookOpen
      size += (ctx.bool)(smokerBookOpen)
      let filteringSmoker = value.filteringSmoker
      size += (ctx.bool)(filteringSmoker)
      let recipes1 = value.recipes1
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(recipes1)
      let recipes2 = value.recipes2
      size += ((value) => {
        switch (action) {
          case 0: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(recipes2)
      return size
    },
    packet_entity_destroy: (value) => {
      let size = 0
      let entityIds = value.entityIds
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(entityIds)
      return size
    },
    packet_remove_entity_effect: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let effectId = value.effectId
      size += (ctx.varint)(effectId)
      return size
    },
    packet_resource_pack_send: (value) => {
      let size = 0
      let url = value.url
      size += (ctx.string)(url)
      let hash = value.hash
      size += (ctx.string)(hash)
      let forced = value.forced
      size += (ctx.bool)(forced)
      let promptMessage = value.promptMessage
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(promptMessage)
      return size
    },
    packet_respawn: (value) => {
      let size = 0
      let dimension = value.dimension
      size += (ctx.string)(dimension)
      let worldName = value.worldName
      size += (ctx.string)(worldName)
      let hashedSeed = value.hashedSeed
      size += (ctx.i64)(hashedSeed)
      let gamemode = value.gamemode
      size += (ctx.i8)(gamemode)
      let previousGamemode = value.previousGamemode
      size += (ctx.u8)(previousGamemode)
      let isDebug = value.isDebug
      size += (ctx.bool)(isDebug)
      let isFlat = value.isFlat
      size += (ctx.bool)(isFlat)
      let copyMetadata = value.copyMetadata
      size += (ctx.bool)(copyMetadata)
      let death = value.death
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = 0
          let dimensionName = value.dimensionName
          size += (ctx.string)(dimensionName)
          let location1 = value.location
          size += (ctx.position)(location1)
          return size
        })(value)
        }
        return 1
      })(death)
      return size
    },
    packet_entity_head_rotation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let headYaw = value.headYaw
      size += (ctx.i8)(headYaw)
      return size
    },
    packet_camera: (value) => {
      let size = 0
      let cameraId = value.cameraId
      size += (ctx.varint)(cameraId)
      return size
    },
    packet_held_item_slot: (value) => {
      let size = 0
      let slot = value.slot
      size += (ctx.i8)(slot)
      return size
    },
    packet_update_view_position: (value) => {
      let size = 0
      let chunkX = value.chunkX
      size += (ctx.varint)(chunkX)
      let chunkZ = value.chunkZ
      size += (ctx.varint)(chunkZ)
      return size
    },
    packet_update_view_distance: (value) => {
      let size = 0
      let viewDistance = value.viewDistance
      size += (ctx.varint)(viewDistance)
      return size
    },
    packet_scoreboard_display_objective: (value) => {
      let size = 0
      let position = value.position
      size += (ctx.i8)(position)
      let name = value.name
      size += (ctx.string)(name)
      return size
    },
    packet_entity_metadata: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let metadata = value.metadata
      size += (ctx.entityMetadata)(metadata)
      return size
    },
    packet_attach_entity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.i32)(entityId)
      let vehicleId = value.vehicleId
      size += (ctx.i32)(vehicleId)
      return size
    },
    packet_entity_velocity: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let velocityX = value.velocityX
      size += (ctx.i16)(velocityX)
      let velocityY = value.velocityY
      size += (ctx.i16)(velocityY)
      let velocityZ = value.velocityZ
      size += (ctx.i16)(velocityZ)
      return size
    },
    packet_entity_equipment: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let equipments = value.equipments
      size += ((value) => {
        let size = 0
        for (const i in value) {
          size += ((value) => {
          let size = 0
          let slot1 = value.slot
          size += (ctx.i8)(slot1)
          let item1 = value.item
          size += (ctx.slot)(item1)
          return size
        })(value[i])
        }
        return size
      })(equipments)
      return size
    },
    packet_experience: (value) => {
      let size = 0
      let experienceBar = value.experienceBar
      size += (ctx.f32)(experienceBar)
      let totalExperience = value.totalExperience
      size += (ctx.varint)(totalExperience)
      let level = value.level
      size += (ctx.varint)(level)
      return size
    },
    packet_update_health: (value) => {
      let size = 0
      let health = value.health
      size += (ctx.f32)(health)
      let food = value.food
      size += (ctx.varint)(food)
      let foodSaturation = value.foodSaturation
      size += (ctx.f32)(foodSaturation)
      return size
    },
    packet_scoreboard_objective: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let action = value.action
      size += (ctx.i8)(action)
      let displayText = value.displayText
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(displayText)
      let type = value.type
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.varint)(value)
          case 2: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(type)
      return size
    },
    packet_set_passengers: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let passengers = value.passengers
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(passengers)
      return size
    },
    packet_teams: (value) => {
      let size = 0
      let team = value.team
      size += (ctx.string)(team)
      let mode = value.mode
      size += (ctx.i8)(mode)
      let name = value.name
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(name)
      let friendlyFire = value.friendlyFire
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.i8)(value)
          case 2: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(friendlyFire)
      let nameTagVisibility = value.nameTagVisibility
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(nameTagVisibility)
      let collisionRule = value.collisionRule
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(collisionRule)
      let formatting = value.formatting
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.varint)(value)
          case 2: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(formatting)
      let prefix = value.prefix
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(prefix)
      let suffix = value.suffix
      size += ((value) => {
        switch (mode) {
          case 0: return (ctx.string)(value)
          case 2: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(suffix)
      let players = value.players
      size += ((value) => {
        switch (mode) {
          case 0: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          case 3: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          case 4: return ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += (ctx.string)(value[i])
            }
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(players)
      return size
    },
    packet_scoreboard_score: (value) => {
      let size = 0
      let itemName = value.itemName
      size += (ctx.string)(itemName)
      let action = value.action
      size += (ctx.varint)(action)
      let scoreName = value.scoreName
      size += (ctx.string)(scoreName)
      let value1 = value.value
      size += ((value) => {
        switch (action) {
          case 1: return (ctx.void)(value)
          default: return (ctx.varint)(value)
        }
      })(value1)
      return size
    },
    packet_spawn_position: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let angle = value.angle
      size += (ctx.f32)(angle)
      return size
    },
    packet_update_time: (value) => {
      let size = 0
      let age = value.age
      size += (ctx.i64)(age)
      let time = value.time
      size += (ctx.i64)(time)
      return size
    },
    packet_entity_sound_effect: (value) => {
      let size = 0
      let soundId = value.soundId
      size += (ctx.varint)(soundId)
      let soundEvent = value.soundEvent
      size += ((value) => {
        switch (soundId) {
          case 0: return ((value) => {
            let size = 0
            let resource = value.resource
            size += (ctx.string)(resource)
            let range = value.range
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.f32)(value)
              }
              return 1
            })(range)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(soundEvent)
      let soundCategory = value.soundCategory
      size += (ctx.varint)(soundCategory)
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let volume = value.volume
      size += (ctx.f32)(volume)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let seed = value.seed
      size += (ctx.i64)(seed)
      return size
    },
    packet_stop_sound: (value) => {
      let size = 0
      let flags = value.flags
      size += (ctx.i8)(flags)
      let source = value.source
      size += ((value) => {
        switch (flags) {
          case 1: return (ctx.varint)(value)
          case 3: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(source)
      let sound = value.sound
      size += ((value) => {
        switch (flags) {
          case 2: return (ctx.string)(value)
          case 3: return (ctx.string)(value)
          default: return (ctx.void)(value)
        }
      })(sound)
      return size
    },
    packet_sound_effect: (value) => {
      let size = 0
      let soundId = value.soundId
      size += (ctx.varint)(soundId)
      let soundEvent = value.soundEvent
      size += ((value) => {
        switch (soundId) {
          case 0: return ((value) => {
            let size = 0
            let resource = value.resource
            size += (ctx.string)(resource)
            let range = value.range
            size += ((value) => {
              if (value != null) {
                return 1 + (ctx.f32)(value)
              }
              return 1
            })(range)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(soundEvent)
      let soundCategory = value.soundCategory
      size += (ctx.varint)(soundCategory)
      let x = value.x
      size += (ctx.i32)(x)
      let y = value.y
      size += (ctx.i32)(y)
      let z = value.z
      size += (ctx.i32)(z)
      let volume = value.volume
      size += (ctx.f32)(volume)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let seed = value.seed
      size += (ctx.i64)(seed)
      return size
    },
    packet_system_chat: (value) => {
      let size = 0
      let content = value.content
      size += (ctx.string)(content)
      let isActionBar = value.isActionBar
      size += (ctx.bool)(isActionBar)
      return size
    },
    packet_playerlist_header: (value) => {
      let size = 0
      let header = value.header
      size += (ctx.string)(header)
      let footer = value.footer
      size += (ctx.string)(footer)
      return size
    },
    packet_collect: (value) => {
      let size = 0
      let collectedEntityId = value.collectedEntityId
      size += (ctx.varint)(collectedEntityId)
      let collectorEntityId = value.collectorEntityId
      size += (ctx.varint)(collectorEntityId)
      let pickupItemCount = value.pickupItemCount
      size += (ctx.varint)(pickupItemCount)
      return size
    },
    packet_entity_teleport: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.i8)(yaw)
      let pitch = value.pitch
      size += (ctx.i8)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_entity_update_attributes: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value2 = value.value
          size += (ctx.f64)(value2)
          let modifiers = value.modifiers
          size += ((value) => {
            let size = (ctx.varint)(value.length)
            for (let i = 0; i < value.length; i++) {
              size += ((value) => {
              let size = 0
              let uuid = value.uuid
              size += (ctx.UUID)(uuid)
              let amount = value.amount
              size += (ctx.f64)(amount)
              let operation = value.operation
              size += (ctx.i8)(operation)
              return size
            })(value[i])
            }
            return size
          })(modifiers)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    packet_feature_flags: (value) => {
      let size = 0
      let features = value.features
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(features)
      return size
    },
    packet_entity_effect: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let effectId = value.effectId
      size += (ctx.varint)(effectId)
      let amplifier = value.amplifier
      size += (ctx.i8)(amplifier)
      let duration = value.duration
      size += (ctx.varint)(duration)
      let hideParticles = value.hideParticles
      size += (ctx.i8)(hideParticles)
      let factorCodec = value.factorCodec
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.nbt)(value)
        }
        return 1
      })(factorCodec)
      return size
    },
    packet_select_advancement_tab: (value) => {
      let size = 0
      let id = value.id
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(id)
      return size
    },
    packet_server_data: (value) => {
      let size = 0
      let motd = value.motd
      size += (ctx.string)(motd)
      let iconBytes = value.iconBytes
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = value instanceof Buffer ? value.length : Buffer.from(value).length
          size += (ctx.varint)(size)
          return size
        })(value)
        }
        return 1
      })(iconBytes)
      let enforcesSecureChat = value.enforcesSecureChat
      size += (ctx.bool)(enforcesSecureChat)
      return size
    },
    packet_declare_recipes: (value) => {
      let size = 0
      let recipes = value.recipes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let type1 = value.type
          size += (ctx.string)(type1)
          let recipeId = value.recipeId
          size += (ctx.string)(recipeId)
          let data1 = value.data
          size += ((value) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((value) => {
                let size = 0
                let group1 = value.group
                size += (ctx.string)(group1)
                let category1 = value.category
                size += (ctx.varint)(category1)
                let ingredients = value.ingredients
                size += ((value) => {
                  let size = (ctx.varint)(value.length)
                  for (let i = 0; i < value.length; i++) {
                    size += (ctx.ingredient)(value[i])
                  }
                  return size
                })(ingredients)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:crafting_shaped": return ((value) => {
                let size = 0
                let width = value.width
                size += (ctx.varint)(width)
                let height = value.height
                size += (ctx.varint)(height)
                let group1 = value.group
                size += (ctx.string)(group1)
                let category1 = value.category
                size += (ctx.varint)(category1)
                let ingredients = value.ingredients
                size += ((value) => {
                  let size = 0
                  for (let i = 0; i < value.length; i++) {
                    size += ((value) => {
                    let size = 0
                    for (let i = 0; i < value.length; i++) {
                      size += (ctx.ingredient)(value[i])
                    }
                    return size
                  })(value[i])
                  }
                  return size
                })(ingredients)
                let result1 = value.result
                size += (ctx.slot)(result1)
                let showNotification = value.showNotification
                size += (ctx.bool)(showNotification)
                return size
              })(value)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(value)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(value)
              case "minecraft:stonecutting": return ((value) => {
                let size = 0
                let group1 = value.group
                size += (ctx.string)(group1)
                let ingredient1 = value.ingredient
                size += (ctx.ingredient)(ingredient1)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing": return ((value) => {
                let size = 0
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing_transform": return ((value) => {
                let size = 0
                let template = value.template
                size += (ctx.ingredient)(template)
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:smithing_trim": return ((value) => {
                let size = 0
                let base = value.base
                size += (ctx.ingredient)(base)
                let addition = value.addition
                size += (ctx.ingredient)(addition)
                let result1 = value.result
                size += (ctx.slot)(result1)
                return size
              })(value)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(value)
              default: return (ctx.void)(value)
            }
          })(data1)
          return size
        })(value[i])
        }
        return size
      })(recipes)
      return size
    },
    packet_tags: (value) => {
      let size = 0
      let tags = value.tags
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let tagType = value.tagType
          size += (ctx.string)(tagType)
          let tags1 = value.tags
          size += (ctx.tags)(tags1)
          return size
        })(value[i])
        }
        return size
      })(tags)
      return size
    },
    packet_acknowledge_player_digging: (value) => {
      let size = 0
      let sequenceId = value.sequenceId
      size += (ctx.varint)(sequenceId)
      return size
    },
    packet_clear_titles: (value) => {
      let size = 0
      let reset = value.reset
      size += (ctx.bool)(reset)
      return size
    },
    packet_initialize_world_border: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let z = value.z
      size += (ctx.f64)(z)
      let oldDiameter = value.oldDiameter
      size += (ctx.f64)(oldDiameter)
      let newDiameter = value.newDiameter
      size += (ctx.f64)(newDiameter)
      let speed = value.speed
      size += (ctx.varint)(speed)
      let portalTeleportBoundary = value.portalTeleportBoundary
      size += (ctx.varint)(portalTeleportBoundary)
      let warningBlocks = value.warningBlocks
      size += (ctx.varint)(warningBlocks)
      let warningTime = value.warningTime
      size += (ctx.varint)(warningTime)
      return size
    },
    packet_action_bar: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_world_border_center: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    packet_world_border_lerp_size: (value) => {
      let size = 0
      let oldDiameter = value.oldDiameter
      size += (ctx.f64)(oldDiameter)
      let newDiameter = value.newDiameter
      size += (ctx.f64)(newDiameter)
      let speed = value.speed
      size += (ctx.varint)(speed)
      return size
    },
    packet_world_border_size: (value) => {
      let size = 0
      let diameter = value.diameter
      size += (ctx.f64)(diameter)
      return size
    },
    packet_world_border_warning_delay: (value) => {
      let size = 0
      let warningTime = value.warningTime
      size += (ctx.varint)(warningTime)
      return size
    },
    packet_world_border_warning_reach: (value) => {
      let size = 0
      let warningBlocks = value.warningBlocks
      size += (ctx.varint)(warningBlocks)
      return size
    },
    packet_ping: (value) => {
      let size = 0
      let id = value.id
      size += (ctx.i32)(id)
      return size
    },
    packet_set_title_subtitle: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_set_title_text: (value) => {
      let size = 0
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_set_title_time: (value) => {
      let size = 0
      let fadeIn = value.fadeIn
      size += (ctx.i32)(fadeIn)
      let stay = value.stay
      size += (ctx.i32)(stay)
      let fadeOut = value.fadeOut
      size += (ctx.i32)(fadeOut)
      return size
    },
    packet_simulation_distance: (value) => {
      let size = 0
      let distance = value.distance
      size += (ctx.varint)(distance)
      return size
    },
    packet_chunk_biomes: (value) => {
      let size = 0
      let biomes = value.biomes
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let position1 = value.position
          size += (ctx.position)(position1)
          let data1 = value.data
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(data1)
          return size
        })(value[i])
        }
        return size
      })(biomes)
      return size
    },
    packet_damage_event: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let sourceTypeId = value.sourceTypeId
      size += (ctx.varint)(sourceTypeId)
      let sourceCauseId = value.sourceCauseId
      size += (ctx.varint)(sourceCauseId)
      let sourceDirectId = value.sourceDirectId
      size += (ctx.varint)(sourceDirectId)
      let sourcePosition = value.sourcePosition
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.vec3f64)(value)
        }
        return 1
      })(sourcePosition)
      return size
    },
    packet_hurt_animation: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"bundle_delimiter":0,"spawn_entity":1,"spawn_entity_experience_orb":2,"named_entity_spawn":3,"animation":4,"statistics":5,"acknowledge_player_digging":6,"block_break_animation":7,"tile_entity_data":8,"block_action":9,"block_change":10,"boss_bar":11,"difficulty":12,"chunk_biomes":13,"clear_titles":14,"tab_complete":15,"declare_commands":16,"close_window":17,"window_items":18,"craft_progress_bar":19,"set_slot":20,"set_cooldown":21,"chat_suggestions":22,"custom_payload":23,"damage_event":24,"hide_message":25,"kick_disconnect":26,"profileless_chat":27,"entity_status":28,"explosion":29,"unload_chunk":30,"game_state_change":31,"open_horse_window":32,"hurt_animation":33,"initialize_world_border":34,"keep_alive":35,"map_chunk":36,"world_event":37,"world_particles":38,"update_light":39,"login":40,"map":41,"trade_list":42,"rel_entity_move":43,"entity_move_look":44,"entity_look":45,"vehicle_move":46,"open_book":47,"open_window":48,"open_sign_entity":49,"ping":50,"craft_recipe_response":51,"abilities":52,"player_chat":53,"end_combat_event":54,"enter_combat_event":55,"death_combat_event":56,"player_remove":57,"player_info":58,"face_player":59,"position":60,"unlock_recipes":61,"entity_destroy":62,"remove_entity_effect":63,"resource_pack_send":64,"respawn":65,"entity_head_rotation":66,"multi_block_change":67,"select_advancement_tab":68,"server_data":69,"action_bar":70,"world_border_center":71,"world_border_lerp_size":72,"world_border_size":73,"world_border_warning_delay":74,"world_border_warning_reach":75,"camera":76,"held_item_slot":77,"update_view_position":78,"update_view_distance":79,"spawn_position":80,"scoreboard_display_objective":81,"entity_metadata":82,"attach_entity":83,"entity_velocity":84,"entity_equipment":85,"experience":86,"update_health":87,"scoreboard_objective":88,"set_passengers":89,"teams":90,"scoreboard_score":91,"simulation_distance":92,"set_title_subtitle":93,"update_time":94,"set_title_text":95,"set_title_time":96,"entity_sound_effect":97,"sound_effect":98,"stop_sound":99,"system_chat":100,"playerlist_header":101,"nbt_query_response":102,"collect":103,"entity_teleport":104,"advancements":105,"entity_update_attributes":106,"feature_flags":107,"entity_effect":108,"declare_recipes":109,"tags":110}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(value)
          case "spawn_entity": return (ctx.packet_spawn_entity)(value)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(value)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(value)
          case "animation": return (ctx.packet_animation)(value)
          case "statistics": return (ctx.packet_statistics)(value)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(value)
          case "block_break_animation": return (ctx.packet_block_break_animation)(value)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(value)
          case "block_action": return (ctx.packet_block_action)(value)
          case "block_change": return (ctx.packet_block_change)(value)
          case "boss_bar": return (ctx.packet_boss_bar)(value)
          case "difficulty": return (ctx.packet_difficulty)(value)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(value)
          case "clear_titles": return (ctx.packet_clear_titles)(value)
          case "tab_complete": return (ctx.packet_tab_complete)(value)
          case "declare_commands": return (ctx.packet_declare_commands)(value)
          case "close_window": return (ctx.packet_close_window)(value)
          case "window_items": return (ctx.packet_window_items)(value)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(value)
          case "set_slot": return (ctx.packet_set_slot)(value)
          case "set_cooldown": return (ctx.packet_set_cooldown)(value)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(value)
          case "custom_payload": return (ctx.packet_custom_payload)(value)
          case "damage_event": return (ctx.packet_damage_event)(value)
          case "hide_message": return (ctx.packet_hide_message)(value)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(value)
          case "profileless_chat": return (ctx.packet_profileless_chat)(value)
          case "entity_status": return (ctx.packet_entity_status)(value)
          case "explosion": return (ctx.packet_explosion)(value)
          case "unload_chunk": return (ctx.packet_unload_chunk)(value)
          case "game_state_change": return (ctx.packet_game_state_change)(value)
          case "open_horse_window": return (ctx.packet_open_horse_window)(value)
          case "hurt_animation": return (ctx.packet_hurt_animation)(value)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(value)
          case "keep_alive": return (ctx.packet_keep_alive)(value)
          case "map_chunk": return (ctx.packet_map_chunk)(value)
          case "world_event": return (ctx.packet_world_event)(value)
          case "world_particles": return (ctx.packet_world_particles)(value)
          case "update_light": return (ctx.packet_update_light)(value)
          case "login": return (ctx.packet_login)(value)
          case "map": return (ctx.packet_map)(value)
          case "trade_list": return (ctx.packet_trade_list)(value)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(value)
          case "entity_move_look": return (ctx.packet_entity_move_look)(value)
          case "entity_look": return (ctx.packet_entity_look)(value)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value)
          case "open_book": return (ctx.packet_open_book)(value)
          case "open_window": return (ctx.packet_open_window)(value)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(value)
          case "ping": return (ctx.packet_ping)(value)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(value)
          case "abilities": return (ctx.packet_abilities)(value)
          case "player_chat": return (ctx.packet_player_chat)(value)
          case "end_combat_event": return (ctx.packet_end_combat_event)(value)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(value)
          case "death_combat_event": return (ctx.packet_death_combat_event)(value)
          case "player_remove": return (ctx.packet_player_remove)(value)
          case "player_info": return (ctx.packet_player_info)(value)
          case "face_player": return (ctx.packet_face_player)(value)
          case "position": return (ctx.packet_position)(value)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(value)
          case "entity_destroy": return (ctx.packet_entity_destroy)(value)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(value)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(value)
          case "respawn": return (ctx.packet_respawn)(value)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(value)
          case "multi_block_change": return (ctx.packet_multi_block_change)(value)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(value)
          case "server_data": return (ctx.packet_server_data)(value)
          case "action_bar": return (ctx.packet_action_bar)(value)
          case "world_border_center": return (ctx.packet_world_border_center)(value)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(value)
          case "world_border_size": return (ctx.packet_world_border_size)(value)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(value)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(value)
          case "camera": return (ctx.packet_camera)(value)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value)
          case "update_view_position": return (ctx.packet_update_view_position)(value)
          case "update_view_distance": return (ctx.packet_update_view_distance)(value)
          case "spawn_position": return (ctx.packet_spawn_position)(value)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(value)
          case "entity_metadata": return (ctx.packet_entity_metadata)(value)
          case "attach_entity": return (ctx.packet_attach_entity)(value)
          case "entity_velocity": return (ctx.packet_entity_velocity)(value)
          case "entity_equipment": return (ctx.packet_entity_equipment)(value)
          case "experience": return (ctx.packet_experience)(value)
          case "update_health": return (ctx.packet_update_health)(value)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(value)
          case "set_passengers": return (ctx.packet_set_passengers)(value)
          case "teams": return (ctx.packet_teams)(value)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(value)
          case "simulation_distance": return (ctx.packet_simulation_distance)(value)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(value)
          case "update_time": return (ctx.packet_update_time)(value)
          case "set_title_text": return (ctx.packet_set_title_text)(value)
          case "set_title_time": return (ctx.packet_set_title_time)(value)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(value)
          case "sound_effect": return (ctx.packet_sound_effect)(value)
          case "stop_sound": return (ctx.packet_stop_sound)(value)
          case "system_chat": return (ctx.packet_system_chat)(value)
          case "playerlist_header": return (ctx.packet_playerlist_header)(value)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(value)
          case "collect": return (ctx.packet_collect)(value)
          case "entity_teleport": return (ctx.packet_entity_teleport)(value)
          case "advancements": return (ctx.packet_advancements)(value)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(value)
          case "feature_flags": return (ctx.packet_feature_flags)(value)
          case "entity_effect": return (ctx.packet_entity_effect)(value)
          case "declare_recipes": return (ctx.packet_declare_recipes)(value)
          case "tags": return (ctx.packet_tags)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_spawn_entity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let objectUUID = value.objectUUID
      offset = (ctx.UUID)(objectUUID, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let headPitch = value.headPitch
      offset = (ctx.i8)(headPitch, buffer, offset)
      let objectData = value.objectData
      offset = (ctx.varint)(objectData, buffer, offset)
      let velocityX = value.velocityX
      offset = (ctx.i16)(velocityX, buffer, offset)
      let velocityY = value.velocityY
      offset = (ctx.i16)(velocityY, buffer, offset)
      let velocityZ = value.velocityZ
      offset = (ctx.i16)(velocityZ, buffer, offset)
      return offset
    },
    packet_spawn_entity_experience_orb: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let count = value.count
      offset = (ctx.i16)(count, buffer, offset)
      return offset
    },
    packet_named_entity_spawn: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let playerUUID = value.playerUUID
      offset = (ctx.UUID)(playerUUID, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      return offset
    },
    packet_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let animation = value.animation
      offset = (ctx.u8)(animation, buffer, offset)
      return offset
    },
    packet_statistics: (value, buffer, offset) => {
      let entries = value.entries
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let categoryId = value.categoryId
          offset = (ctx.varint)(categoryId, buffer, offset)
          let statisticId = value.statisticId
          offset = (ctx.varint)(statisticId, buffer, offset)
          let value1 = value.value
          offset = (ctx.varint)(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(entries, buffer, offset)
      return offset
    },
    packet_advancements: (value, buffer, offset) => {
      let reset = value.reset
      offset = (ctx.bool)(reset, buffer, offset)
      let advancementMapping = value.advancementMapping
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = ((value, buffer, offset) => {
            let parentId = value.parentId
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.string)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(parentId, buffer, offset)
            let displayData = value.displayData
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = ((value, buffer, offset) => {
                let title = value.title
                offset = (ctx.string)(title, buffer, offset)
                let description = value.description
                offset = (ctx.string)(description, buffer, offset)
                let icon = value.icon
                offset = (ctx.slot)(icon, buffer, offset)
                let frameType = value.frameType
                offset = (ctx.varint)(frameType, buffer, offset)
                let flags1 = value.flags
                offset = ((value, buffer, offset) => {
                  let _unused = value._unused
                  buffer[offset++] = ((_unused >> 21) & 0xff)
                  buffer[offset++] = ((_unused >> 13) & 0xff)
                  buffer[offset++] = ((_unused >> 5) & 0xff)
                  let hidden = value.hidden
                  let show_toast = value.show_toast
                  let has_background_texture = value.has_background_texture
                  buffer[offset++] = ((((((((_unused >> 0) & 0x1f)) << 1) | ((hidden >> 0) & 0x1)) << 1) | ((show_toast >> 0) & 0x1)) << 1) | ((has_background_texture >> 0) & 0x1)
                  return offset
                })(flags1, buffer, offset)
                let backgroundTexture = value.backgroundTexture
                offset = ((value, buffer, offset) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(value, buffer, offset)
                    default: return (ctx.void)(value, buffer, offset)
                  }
                })(backgroundTexture, buffer, offset)
                let xCord = value.xCord
                offset = (ctx.f32)(xCord, buffer, offset)
                let yCord = value.yCord
                offset = (ctx.f32)(yCord, buffer, offset)
                return offset
              })(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(displayData, buffer, offset)
            let criteria = value.criteria
            offset = ((value, buffer, offset) => {
              offset = (ctx.varint)(value.length, buffer, offset)
              for (let i = 0; i < value.length; i++) {
                offset = ((value, buffer, offset) => {
                let key1 = value.key
                offset = (ctx.string)(key1, buffer, offset)
                let value2 = value.value
                offset = (ctx.void)(value2, buffer, offset)
                return offset
              })(value[i], buffer, offset)
              }
              return offset
            })(criteria, buffer, offset)
            let requirements = value.requirements
            offset = ((value, buffer, offset) => {
              offset = (ctx.varint)(value.length, buffer, offset)
              for (let i = 0; i < value.length; i++) {
                offset = ((value, buffer, offset) => {
                offset = (ctx.varint)(value.length, buffer, offset)
                for (let i = 0; i < value.length; i++) {
                  offset = (ctx.string)(value[i], buffer, offset)
                }
                return offset
              })(value[i], buffer, offset)
              }
              return offset
            })(requirements, buffer, offset)
            return offset
          })(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(advancementMapping, buffer, offset)
      let identifiers = value.identifiers
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(identifiers, buffer, offset)
      let progressMapping = value.progressMapping
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = ((value, buffer, offset) => {
              let criterionIdentifier = value.criterionIdentifier
              offset = (ctx.string)(criterionIdentifier, buffer, offset)
              let criterionProgress = value.criterionProgress
              offset = ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.i64)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(criterionProgress, buffer, offset)
              return offset
            })(value[i], buffer, offset)
            }
            return offset
          })(value1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(progressMapping, buffer, offset)
      return offset
    },
    packet_block_break_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let destroyStage = value.destroyStage
      offset = (ctx.i8)(destroyStage, buffer, offset)
      return offset
    },
    packet_tile_entity_data: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    packet_block_action: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let byte1 = value.byte1
      offset = (ctx.u8)(byte1, buffer, offset)
      let byte2 = value.byte2
      offset = (ctx.u8)(byte2, buffer, offset)
      let blockId = value.blockId
      offset = (ctx.varint)(blockId, buffer, offset)
      return offset
    },
    packet_block_change: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      return offset
    },
    packet_boss_bar: (value, buffer, offset) => {
      let entityUUID = value.entityUUID
      offset = (ctx.UUID)(entityUUID, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let title = value.title
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 3: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(title, buffer, offset)
      let health = value.health
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.f32)(value, buffer, offset)
          case 2: return (ctx.f32)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(health, buffer, offset)
      let color = value.color
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 4: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(color, buffer, offset)
      let dividers = value.dividers
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 4: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(dividers, buffer, offset)
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.u8)(value, buffer, offset)
          case 5: return (ctx.u8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(flags, buffer, offset)
      return offset
    },
    packet_difficulty: (value, buffer, offset) => {
      let difficulty = value.difficulty
      offset = (ctx.u8)(difficulty, buffer, offset)
      let difficultyLocked = value.difficultyLocked
      offset = (ctx.bool)(difficultyLocked, buffer, offset)
      return offset
    },
    packet_tab_complete: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let start = value.start
      offset = (ctx.varint)(start, buffer, offset)
      let length = value.length
      offset = (ctx.varint)(length, buffer, offset)
      let matches = value.matches
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let match = value.match
          offset = (ctx.string)(match, buffer, offset)
          let tooltip = value.tooltip
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(tooltip, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(matches, buffer, offset)
      return offset
    },
    packet_declare_commands: (value, buffer, offset) => {
      let nodes = value.nodes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.command_node)(value[i], buffer, offset)
        }
        return offset
      })(nodes, buffer, offset)
      let rootIndex = value.rootIndex
      offset = (ctx.varint)(rootIndex, buffer, offset)
      return offset
    },
    packet_face_player: (value, buffer, offset) => {
      let feet_eyes = value.feet_eyes
      offset = (ctx.varint)(feet_eyes, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let isEntity = value.isEntity
      offset = (ctx.bool)(isEntity, buffer, offset)
      let entityId = value.entityId
      offset = ((value, buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(entityId, buffer, offset)
      let entity_feet_eyes = value.entity_feet_eyes
      offset = ((value, buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(entity_feet_eyes, buffer, offset)
      return offset
    },
    packet_nbt_query_response: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let nbt = value.nbt
      offset = (ctx.optionalNbt)(nbt, buffer, offset)
      return offset
    },
    packet_multi_block_change: (value, buffer, offset) => {
      let chunkCoordinates = value.chunkCoordinates
      offset = ((value, buffer, offset) => {
        let x = value.x
        buffer[offset++] = ((x >> 14) & 0xff)
        buffer[offset++] = ((x >> 6) & 0xff)
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0x3f)) << 2) | ((z >> 20) & 0x3)
        buffer[offset++] = ((z >> 12) & 0xff)
        buffer[offset++] = ((z >> 4) & 0xff)
        let y = value.y
        buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 16) & 0xf)
        buffer[offset++] = ((y >> 8) & 0xff)
        buffer[offset++] = ((y >> 0) & 0xff)
        return offset
      })(chunkCoordinates, buffer, offset)
      let suppressLightUpdates = value.suppressLightUpdates
      offset = (ctx.bool)(suppressLightUpdates, buffer, offset)
      let records = value.records
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(records, buffer, offset)
      return offset
    },
    packet_close_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      return offset
    },
    packet_open_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.varint)(windowId, buffer, offset)
      let inventoryType = value.inventoryType
      offset = (ctx.varint)(inventoryType, buffer, offset)
      let windowTitle = value.windowTitle
      offset = (ctx.string)(windowTitle, buffer, offset)
      return offset
    },
    packet_window_items: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let stateId = value.stateId
      offset = (ctx.varint)(stateId, buffer, offset)
      let items = value.items
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.slot)(value[i], buffer, offset)
        }
        return offset
      })(items, buffer, offset)
      let carriedItem = value.carriedItem
      offset = (ctx.slot)(carriedItem, buffer, offset)
      return offset
    },
    packet_craft_progress_bar: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let property = value.property
      offset = (ctx.i16)(property, buffer, offset)
      let value1 = value.value
      offset = (ctx.i16)(value1, buffer, offset)
      return offset
    },
    packet_set_slot: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let stateId = value.stateId
      offset = (ctx.varint)(stateId, buffer, offset)
      let slot = value.slot
      offset = (ctx.i16)(slot, buffer, offset)
      let item = value.item
      offset = (ctx.slot)(item, buffer, offset)
      return offset
    },
    packet_set_cooldown: (value, buffer, offset) => {
      let itemID = value.itemID
      offset = (ctx.varint)(itemID, buffer, offset)
      let cooldownTicks = value.cooldownTicks
      offset = (ctx.varint)(cooldownTicks, buffer, offset)
      return offset
    },
    packet_chat_suggestions: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let entries = value.entries
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(entries, buffer, offset)
      return offset
    },
    packet_custom_payload: (value, buffer, offset) => {
      let channel = value.channel
      offset = (ctx.string)(channel, buffer, offset)
      let data = value.data
      offset = (ctx.restBuffer)(data, buffer, offset)
      return offset
    },
    packet_hide_message: (value, buffer, offset) => {
      let id = value.id
      offset = (ctx.varint)(id, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        switch (id) {
          case 0: return ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            value.copy(buffer, offset)
            return offset + value.length
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(signature, buffer, offset)
      return offset
    },
    packet_kick_disconnect: (value, buffer, offset) => {
      let reason = value.reason
      offset = (ctx.string)(reason, buffer, offset)
      return offset
    },
    packet_profileless_chat: (value, buffer, offset) => {
      let message = value.message
      offset = (ctx.string)(message, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let target = value.target
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(target, buffer, offset)
      return offset
    },
    packet_entity_status: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let entityStatus = value.entityStatus
      offset = (ctx.i8)(entityStatus, buffer, offset)
      return offset
    },
    packet_explosion: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let radius = value.radius
      offset = (ctx.f32)(radius, buffer, offset)
      let affectedBlockOffsets = value.affectedBlockOffsets
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let x1 = value.x
          offset = (ctx.i8)(x1, buffer, offset)
          let y1 = value.y
          offset = (ctx.i8)(y1, buffer, offset)
          let z1 = value.z
          offset = (ctx.i8)(z1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(affectedBlockOffsets, buffer, offset)
      let playerMotionX = value.playerMotionX
      offset = (ctx.f32)(playerMotionX, buffer, offset)
      let playerMotionY = value.playerMotionY
      offset = (ctx.f32)(playerMotionY, buffer, offset)
      let playerMotionZ = value.playerMotionZ
      offset = (ctx.f32)(playerMotionZ, buffer, offset)
      return offset
    },
    packet_unload_chunk: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.i32)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.i32)(chunkZ, buffer, offset)
      return offset
    },
    packet_game_state_change: (value, buffer, offset) => {
      let reason = value.reason
      offset = (ctx.u8)(reason, buffer, offset)
      let gameMode = value.gameMode
      offset = (ctx.f32)(gameMode, buffer, offset)
      return offset
    },
    packet_open_horse_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let nbSlots = value.nbSlots
      offset = (ctx.varint)(nbSlots, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      return offset
    },
    packet_keep_alive: (value, buffer, offset) => {
      let keepAliveId = value.keepAliveId
      offset = (ctx.i64)(keepAliveId, buffer, offset)
      return offset
    },
    packet_map_chunk: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.i32)(x, buffer, offset)
      let z = value.z
      offset = (ctx.i32)(z, buffer, offset)
      let heightmaps = value.heightmaps
      offset = (ctx.nbt)(heightmaps, buffer, offset)
      let chunkData = value.chunkData
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(chunkData, buffer, offset)
      let blockEntities = value.blockEntities
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.chunkBlockEntity)(value[i], buffer, offset)
        }
        return offset
      })(blockEntities, buffer, offset)
      let trustEdges = value.trustEdges
      offset = (ctx.bool)(trustEdges, buffer, offset)
      let skyLightMask = value.skyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(skyLightMask, buffer, offset)
      let blockLightMask = value.blockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(blockLightMask, buffer, offset)
      let emptySkyLightMask = value.emptySkyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptySkyLightMask, buffer, offset)
      let emptyBlockLightMask = value.emptyBlockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptyBlockLightMask, buffer, offset)
      let skyLight = value.skyLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(skyLight, buffer, offset)
      let blockLight = value.blockLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(blockLight, buffer, offset)
      return offset
    },
    packet_world_event: (value, buffer, offset) => {
      let effectId = value.effectId
      offset = (ctx.i32)(effectId, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let data = value.data
      offset = (ctx.i32)(data, buffer, offset)
      let global = value.global
      offset = (ctx.bool)(global, buffer, offset)
      return offset
    },
    packet_world_particles: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let longDistance = value.longDistance
      offset = (ctx.bool)(longDistance, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let offsetX = value.offsetX
      offset = (ctx.f32)(offsetX, buffer, offset)
      let offsetY = value.offsetY
      offset = (ctx.f32)(offsetY, buffer, offset)
      let offsetZ = value.offsetZ
      offset = (ctx.f32)(offsetZ, buffer, offset)
      let particleData = value.particleData
      offset = (ctx.f32)(particleData, buffer, offset)
      let particles = value.particles
      offset = (ctx.i32)(particles, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    packet_update_light: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.varint)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.varint)(chunkZ, buffer, offset)
      let trustEdges = value.trustEdges
      offset = (ctx.bool)(trustEdges, buffer, offset)
      let skyLightMask = value.skyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(skyLightMask, buffer, offset)
      let blockLightMask = value.blockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(blockLightMask, buffer, offset)
      let emptySkyLightMask = value.emptySkyLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptySkyLightMask, buffer, offset)
      let emptyBlockLightMask = value.emptyBlockLightMask
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.i64)(value[i], buffer, offset)
        }
        return offset
      })(emptyBlockLightMask, buffer, offset)
      let skyLight = value.skyLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(skyLight, buffer, offset)
      let blockLight = value.blockLight
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.u8)(value[i], buffer, offset)
          }
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(blockLight, buffer, offset)
      return offset
    },
    packet_login: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let isHardcore = value.isHardcore
      offset = (ctx.bool)(isHardcore, buffer, offset)
      let gameMode = value.gameMode
      offset = (ctx.u8)(gameMode, buffer, offset)
      let previousGameMode = value.previousGameMode
      offset = (ctx.i8)(previousGameMode, buffer, offset)
      let worldNames = value.worldNames
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(worldNames, buffer, offset)
      let dimensionCodec = value.dimensionCodec
      offset = (ctx.nbt)(dimensionCodec, buffer, offset)
      let worldType = value.worldType
      offset = (ctx.string)(worldType, buffer, offset)
      let worldName = value.worldName
      offset = (ctx.string)(worldName, buffer, offset)
      let hashedSeed = value.hashedSeed
      offset = (ctx.i64)(hashedSeed, buffer, offset)
      let maxPlayers = value.maxPlayers
      offset = (ctx.varint)(maxPlayers, buffer, offset)
      let viewDistance = value.viewDistance
      offset = (ctx.varint)(viewDistance, buffer, offset)
      let simulationDistance = value.simulationDistance
      offset = (ctx.varint)(simulationDistance, buffer, offset)
      let reducedDebugInfo = value.reducedDebugInfo
      offset = (ctx.bool)(reducedDebugInfo, buffer, offset)
      let enableRespawnScreen = value.enableRespawnScreen
      offset = (ctx.bool)(enableRespawnScreen, buffer, offset)
      let isDebug = value.isDebug
      offset = (ctx.bool)(isDebug, buffer, offset)
      let isFlat = value.isFlat
      offset = (ctx.bool)(isFlat, buffer, offset)
      let death = value.death
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          let dimensionName = value.dimensionName
          offset = (ctx.string)(dimensionName, buffer, offset)
          let location1 = value.location
          offset = (ctx.position)(location1, buffer, offset)
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(death, buffer, offset)
      return offset
    },
    packet_map: (value, buffer, offset) => {
      let itemDamage = value.itemDamage
      offset = (ctx.varint)(itemDamage, buffer, offset)
      let scale = value.scale
      offset = (ctx.i8)(scale, buffer, offset)
      let locked = value.locked
      offset = (ctx.bool)(locked, buffer, offset)
      let icons = value.icons
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = ((value, buffer, offset) => {
            let type1 = value.type
            offset = (ctx.varint)(type1, buffer, offset)
            let x1 = value.x
            offset = (ctx.i8)(x1, buffer, offset)
            let z1 = value.z
            offset = (ctx.i8)(z1, buffer, offset)
            let direction = value.direction
            offset = (ctx.u8)(direction, buffer, offset)
            let displayName = value.displayName
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.string)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(displayName, buffer, offset)
            return offset
          })(value[i], buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(icons, buffer, offset)
      let columns = value.columns
      offset = (ctx.u8)(columns, buffer, offset)
      let rows = value.rows
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(rows, buffer, offset)
      let x = value.x
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(x, buffer, offset)
      let y = value.y
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return (ctx.u8)(value, buffer, offset)
        }
      })(y, buffer, offset)
      let data = value.data
      offset = ((value, buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(value, buffer, offset)
          default: return ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(value, buffer, offset)
        }
      })(data, buffer, offset)
      return offset
    },
    packet_trade_list: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.varint)(windowId, buffer, offset)
      let trades = value.trades
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let inputItem1 = value.inputItem1
          offset = (ctx.slot)(inputItem1, buffer, offset)
          let outputItem = value.outputItem
          offset = (ctx.slot)(outputItem, buffer, offset)
          let inputItem2 = value.inputItem2
          offset = (ctx.slot)(inputItem2, buffer, offset)
          let tradeDisabled = value.tradeDisabled
          offset = (ctx.bool)(tradeDisabled, buffer, offset)
          let nbTradeUses = value.nbTradeUses
          offset = (ctx.i32)(nbTradeUses, buffer, offset)
          let maximumNbTradeUses = value.maximumNbTradeUses
          offset = (ctx.i32)(maximumNbTradeUses, buffer, offset)
          let xp = value.xp
          offset = (ctx.i32)(xp, buffer, offset)
          let specialPrice = value.specialPrice
          offset = (ctx.i32)(specialPrice, buffer, offset)
          let priceMultiplier = value.priceMultiplier
          offset = (ctx.f32)(priceMultiplier, buffer, offset)
          let demand = value.demand
          offset = (ctx.i32)(demand, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(trades, buffer, offset)
      let villagerLevel = value.villagerLevel
      offset = (ctx.varint)(villagerLevel, buffer, offset)
      let experience = value.experience
      offset = (ctx.varint)(experience, buffer, offset)
      let isRegularVillager = value.isRegularVillager
      offset = (ctx.bool)(isRegularVillager, buffer, offset)
      let canRestock = value.canRestock
      offset = (ctx.bool)(canRestock, buffer, offset)
      return offset
    },
    packet_rel_entity_move: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let dX = value.dX
      offset = (ctx.i16)(dX, buffer, offset)
      let dY = value.dY
      offset = (ctx.i16)(dY, buffer, offset)
      let dZ = value.dZ
      offset = (ctx.i16)(dZ, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_move_look: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let dX = value.dX
      offset = (ctx.i16)(dX, buffer, offset)
      let dY = value.dY
      offset = (ctx.i16)(dY, buffer, offset)
      let dZ = value.dZ
      offset = (ctx.i16)(dZ, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_look: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_vehicle_move: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      return offset
    },
    packet_open_book: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      return offset
    },
    packet_open_sign_entity: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      return offset
    },
    packet_craft_recipe_response: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let recipe = value.recipe
      offset = (ctx.string)(recipe, buffer, offset)
      return offset
    },
    packet_abilities: (value, buffer, offset) => {
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let flyingSpeed = value.flyingSpeed
      offset = (ctx.f32)(flyingSpeed, buffer, offset)
      let walkingSpeed = value.walkingSpeed
      offset = (ctx.f32)(walkingSpeed, buffer, offset)
      return offset
    },
    packet_player_chat: (value, buffer, offset) => {
      let senderUuid = value.senderUuid
      offset = (ctx.UUID)(senderUuid, buffer, offset)
      let index = value.index
      offset = (ctx.varint)(index, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          if (!(value instanceof Buffer)) value = Buffer.from(value)
          value.copy(buffer, offset)
          return offset + value.length
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(signature, buffer, offset)
      let plainMessage = value.plainMessage
      offset = (ctx.string)(plainMessage, buffer, offset)
      let timestamp = value.timestamp
      offset = (ctx.i64)(timestamp, buffer, offset)
      let salt = value.salt
      offset = (ctx.i64)(salt, buffer, offset)
      let previousMessages = value.previousMessages
      offset = (ctx.previousMessages)(previousMessages, buffer, offset)
      let unsignedChatContent = value.unsignedChatContent
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(unsignedChatContent, buffer, offset)
      let filterType = value.filterType
      offset = (ctx.varint)(filterType, buffer, offset)
      let filterTypeMask = value.filterTypeMask
      offset = ((value, buffer, offset) => {
        switch (filterType) {
          case 2: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.i64)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(filterTypeMask, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let networkName = value.networkName
      offset = (ctx.string)(networkName, buffer, offset)
      let networkTargetName = value.networkTargetName
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(networkTargetName, buffer, offset)
      return offset
    },
    packet_end_combat_event: (value, buffer, offset) => {
      let duration = value.duration
      offset = (ctx.varint)(duration, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      return offset
    },
    packet_enter_combat_event: (value, buffer, offset) => {
      return offset
    },
    packet_death_combat_event: (value, buffer, offset) => {
      let playerId = value.playerId
      offset = (ctx.varint)(playerId, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let message = value.message
      offset = (ctx.string)(message, buffer, offset)
      return offset
    },
    packet_player_remove: (value, buffer, offset) => {
      let players = value.players
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.UUID)(value[i], buffer, offset)
        }
        return offset
      })(players, buffer, offset)
      return offset
    },
    packet_player_info: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.i8)(action, buffer, offset)
      let data = value.data
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let uuid = value.uuid
          offset = (ctx.UUID)(uuid, buffer, offset)
          let player = value.player
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 1: return (ctx.game_profile)(value, buffer, offset)
              case 3: return (ctx.game_profile)(value, buffer, offset)
              case 5: return (ctx.game_profile)(value, buffer, offset)
              case 7: return (ctx.game_profile)(value, buffer, offset)
              case 9: return (ctx.game_profile)(value, buffer, offset)
              case 11: return (ctx.game_profile)(value, buffer, offset)
              case 13: return (ctx.game_profile)(value, buffer, offset)
              case 15: return (ctx.game_profile)(value, buffer, offset)
              case 17: return (ctx.game_profile)(value, buffer, offset)
              case 19: return (ctx.game_profile)(value, buffer, offset)
              case 21: return (ctx.game_profile)(value, buffer, offset)
              case 23: return (ctx.game_profile)(value, buffer, offset)
              case 25: return (ctx.game_profile)(value, buffer, offset)
              case 27: return (ctx.game_profile)(value, buffer, offset)
              case 29: return (ctx.game_profile)(value, buffer, offset)
              case 31: return (ctx.game_profile)(value, buffer, offset)
              case 33: return (ctx.game_profile)(value, buffer, offset)
              case 35: return (ctx.game_profile)(value, buffer, offset)
              case 37: return (ctx.game_profile)(value, buffer, offset)
              case 39: return (ctx.game_profile)(value, buffer, offset)
              case 41: return (ctx.game_profile)(value, buffer, offset)
              case 43: return (ctx.game_profile)(value, buffer, offset)
              case 45: return (ctx.game_profile)(value, buffer, offset)
              case 47: return (ctx.game_profile)(value, buffer, offset)
              case 49: return (ctx.game_profile)(value, buffer, offset)
              case 51: return (ctx.game_profile)(value, buffer, offset)
              case 53: return (ctx.game_profile)(value, buffer, offset)
              case 55: return (ctx.game_profile)(value, buffer, offset)
              case 57: return (ctx.game_profile)(value, buffer, offset)
              case 59: return (ctx.game_profile)(value, buffer, offset)
              case 61: return (ctx.game_profile)(value, buffer, offset)
              case 63: return (ctx.game_profile)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(player, buffer, offset)
          let chatSession = value.chatSession
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 2: return (ctx.chat_session)(value, buffer, offset)
              case 3: return (ctx.chat_session)(value, buffer, offset)
              case 6: return (ctx.chat_session)(value, buffer, offset)
              case 7: return (ctx.chat_session)(value, buffer, offset)
              case 10: return (ctx.chat_session)(value, buffer, offset)
              case 11: return (ctx.chat_session)(value, buffer, offset)
              case 14: return (ctx.chat_session)(value, buffer, offset)
              case 15: return (ctx.chat_session)(value, buffer, offset)
              case 18: return (ctx.chat_session)(value, buffer, offset)
              case 19: return (ctx.chat_session)(value, buffer, offset)
              case 22: return (ctx.chat_session)(value, buffer, offset)
              case 23: return (ctx.chat_session)(value, buffer, offset)
              case 26: return (ctx.chat_session)(value, buffer, offset)
              case 27: return (ctx.chat_session)(value, buffer, offset)
              case 30: return (ctx.chat_session)(value, buffer, offset)
              case 31: return (ctx.chat_session)(value, buffer, offset)
              case 34: return (ctx.chat_session)(value, buffer, offset)
              case 35: return (ctx.chat_session)(value, buffer, offset)
              case 38: return (ctx.chat_session)(value, buffer, offset)
              case 39: return (ctx.chat_session)(value, buffer, offset)
              case 42: return (ctx.chat_session)(value, buffer, offset)
              case 43: return (ctx.chat_session)(value, buffer, offset)
              case 46: return (ctx.chat_session)(value, buffer, offset)
              case 47: return (ctx.chat_session)(value, buffer, offset)
              case 50: return (ctx.chat_session)(value, buffer, offset)
              case 51: return (ctx.chat_session)(value, buffer, offset)
              case 54: return (ctx.chat_session)(value, buffer, offset)
              case 55: return (ctx.chat_session)(value, buffer, offset)
              case 58: return (ctx.chat_session)(value, buffer, offset)
              case 59: return (ctx.chat_session)(value, buffer, offset)
              case 62: return (ctx.chat_session)(value, buffer, offset)
              case 63: return (ctx.chat_session)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(chatSession, buffer, offset)
          let gamemode = value.gamemode
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 4: return (ctx.varint)(value, buffer, offset)
              case 5: return (ctx.varint)(value, buffer, offset)
              case 6: return (ctx.varint)(value, buffer, offset)
              case 7: return (ctx.varint)(value, buffer, offset)
              case 12: return (ctx.varint)(value, buffer, offset)
              case 13: return (ctx.varint)(value, buffer, offset)
              case 14: return (ctx.varint)(value, buffer, offset)
              case 15: return (ctx.varint)(value, buffer, offset)
              case 20: return (ctx.varint)(value, buffer, offset)
              case 21: return (ctx.varint)(value, buffer, offset)
              case 22: return (ctx.varint)(value, buffer, offset)
              case 23: return (ctx.varint)(value, buffer, offset)
              case 28: return (ctx.varint)(value, buffer, offset)
              case 29: return (ctx.varint)(value, buffer, offset)
              case 30: return (ctx.varint)(value, buffer, offset)
              case 31: return (ctx.varint)(value, buffer, offset)
              case 36: return (ctx.varint)(value, buffer, offset)
              case 37: return (ctx.varint)(value, buffer, offset)
              case 38: return (ctx.varint)(value, buffer, offset)
              case 39: return (ctx.varint)(value, buffer, offset)
              case 44: return (ctx.varint)(value, buffer, offset)
              case 45: return (ctx.varint)(value, buffer, offset)
              case 46: return (ctx.varint)(value, buffer, offset)
              case 47: return (ctx.varint)(value, buffer, offset)
              case 52: return (ctx.varint)(value, buffer, offset)
              case 53: return (ctx.varint)(value, buffer, offset)
              case 54: return (ctx.varint)(value, buffer, offset)
              case 55: return (ctx.varint)(value, buffer, offset)
              case 60: return (ctx.varint)(value, buffer, offset)
              case 61: return (ctx.varint)(value, buffer, offset)
              case 62: return (ctx.varint)(value, buffer, offset)
              case 63: return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(gamemode, buffer, offset)
          let listed = value.listed
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 8: return (ctx.bool)(value, buffer, offset)
              case 9: return (ctx.bool)(value, buffer, offset)
              case 10: return (ctx.bool)(value, buffer, offset)
              case 11: return (ctx.bool)(value, buffer, offset)
              case 12: return (ctx.bool)(value, buffer, offset)
              case 13: return (ctx.bool)(value, buffer, offset)
              case 14: return (ctx.bool)(value, buffer, offset)
              case 15: return (ctx.bool)(value, buffer, offset)
              case 24: return (ctx.bool)(value, buffer, offset)
              case 25: return (ctx.bool)(value, buffer, offset)
              case 26: return (ctx.bool)(value, buffer, offset)
              case 27: return (ctx.bool)(value, buffer, offset)
              case 28: return (ctx.bool)(value, buffer, offset)
              case 29: return (ctx.bool)(value, buffer, offset)
              case 30: return (ctx.bool)(value, buffer, offset)
              case 31: return (ctx.bool)(value, buffer, offset)
              case 40: return (ctx.bool)(value, buffer, offset)
              case 41: return (ctx.bool)(value, buffer, offset)
              case 42: return (ctx.bool)(value, buffer, offset)
              case 43: return (ctx.bool)(value, buffer, offset)
              case 44: return (ctx.bool)(value, buffer, offset)
              case 45: return (ctx.bool)(value, buffer, offset)
              case 46: return (ctx.bool)(value, buffer, offset)
              case 47: return (ctx.bool)(value, buffer, offset)
              case 56: return (ctx.bool)(value, buffer, offset)
              case 57: return (ctx.bool)(value, buffer, offset)
              case 58: return (ctx.bool)(value, buffer, offset)
              case 59: return (ctx.bool)(value, buffer, offset)
              case 60: return (ctx.bool)(value, buffer, offset)
              case 61: return (ctx.bool)(value, buffer, offset)
              case 62: return (ctx.bool)(value, buffer, offset)
              case 63: return (ctx.bool)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(listed, buffer, offset)
          let latency = value.latency
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 16: return (ctx.varint)(value, buffer, offset)
              case 17: return (ctx.varint)(value, buffer, offset)
              case 18: return (ctx.varint)(value, buffer, offset)
              case 19: return (ctx.varint)(value, buffer, offset)
              case 20: return (ctx.varint)(value, buffer, offset)
              case 21: return (ctx.varint)(value, buffer, offset)
              case 22: return (ctx.varint)(value, buffer, offset)
              case 23: return (ctx.varint)(value, buffer, offset)
              case 24: return (ctx.varint)(value, buffer, offset)
              case 25: return (ctx.varint)(value, buffer, offset)
              case 26: return (ctx.varint)(value, buffer, offset)
              case 27: return (ctx.varint)(value, buffer, offset)
              case 28: return (ctx.varint)(value, buffer, offset)
              case 29: return (ctx.varint)(value, buffer, offset)
              case 30: return (ctx.varint)(value, buffer, offset)
              case 31: return (ctx.varint)(value, buffer, offset)
              case 48: return (ctx.varint)(value, buffer, offset)
              case 49: return (ctx.varint)(value, buffer, offset)
              case 50: return (ctx.varint)(value, buffer, offset)
              case 51: return (ctx.varint)(value, buffer, offset)
              case 52: return (ctx.varint)(value, buffer, offset)
              case 53: return (ctx.varint)(value, buffer, offset)
              case 54: return (ctx.varint)(value, buffer, offset)
              case 55: return (ctx.varint)(value, buffer, offset)
              case 56: return (ctx.varint)(value, buffer, offset)
              case 57: return (ctx.varint)(value, buffer, offset)
              case 58: return (ctx.varint)(value, buffer, offset)
              case 59: return (ctx.varint)(value, buffer, offset)
              case 60: return (ctx.varint)(value, buffer, offset)
              case 61: return (ctx.varint)(value, buffer, offset)
              case 62: return (ctx.varint)(value, buffer, offset)
              case 63: return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(latency, buffer, offset)
          let displayName = value.displayName
          offset = ((value, buffer, offset) => {
            switch (action) {
              case 32: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 33: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 34: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 35: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 36: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 37: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 38: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 39: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 40: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 41: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 42: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 43: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 44: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 45: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 46: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 47: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 48: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 49: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 50: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 51: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 52: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 53: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 54: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 55: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 56: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 57: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 58: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 59: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 60: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 61: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 62: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              case 63: return ((value, buffer, offset) => {
                if (value != null) {
                  offset = ctx.bool(1, buffer, offset)
                  offset = (ctx.string)(value, buffer, offset)
                } else {
                  offset = ctx.bool(0, buffer, offset)
                }
                return offset
              })(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(displayName, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(data, buffer, offset)
      return offset
    },
    packet_position: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let teleportId = value.teleportId
      offset = (ctx.varint)(teleportId, buffer, offset)
      return offset
    },
    packet_unlock_recipes: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let craftingBookOpen = value.craftingBookOpen
      offset = (ctx.bool)(craftingBookOpen, buffer, offset)
      let filteringCraftable = value.filteringCraftable
      offset = (ctx.bool)(filteringCraftable, buffer, offset)
      let smeltingBookOpen = value.smeltingBookOpen
      offset = (ctx.bool)(smeltingBookOpen, buffer, offset)
      let filteringSmeltable = value.filteringSmeltable
      offset = (ctx.bool)(filteringSmeltable, buffer, offset)
      let blastFurnaceOpen = value.blastFurnaceOpen
      offset = (ctx.bool)(blastFurnaceOpen, buffer, offset)
      let filteringBlastFurnace = value.filteringBlastFurnace
      offset = (ctx.bool)(filteringBlastFurnace, buffer, offset)
      let smokerBookOpen = value.smokerBookOpen
      offset = (ctx.bool)(smokerBookOpen, buffer, offset)
      let filteringSmoker = value.filteringSmoker
      offset = (ctx.bool)(filteringSmoker, buffer, offset)
      let recipes1 = value.recipes1
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(recipes1, buffer, offset)
      let recipes2 = value.recipes2
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(recipes2, buffer, offset)
      return offset
    },
    packet_entity_destroy: (value, buffer, offset) => {
      let entityIds = value.entityIds
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(entityIds, buffer, offset)
      return offset
    },
    packet_remove_entity_effect: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let effectId = value.effectId
      offset = (ctx.varint)(effectId, buffer, offset)
      return offset
    },
    packet_resource_pack_send: (value, buffer, offset) => {
      let url = value.url
      offset = (ctx.string)(url, buffer, offset)
      let hash = value.hash
      offset = (ctx.string)(hash, buffer, offset)
      let forced = value.forced
      offset = (ctx.bool)(forced, buffer, offset)
      let promptMessage = value.promptMessage
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(promptMessage, buffer, offset)
      return offset
    },
    packet_respawn: (value, buffer, offset) => {
      let dimension = value.dimension
      offset = (ctx.string)(dimension, buffer, offset)
      let worldName = value.worldName
      offset = (ctx.string)(worldName, buffer, offset)
      let hashedSeed = value.hashedSeed
      offset = (ctx.i64)(hashedSeed, buffer, offset)
      let gamemode = value.gamemode
      offset = (ctx.i8)(gamemode, buffer, offset)
      let previousGamemode = value.previousGamemode
      offset = (ctx.u8)(previousGamemode, buffer, offset)
      let isDebug = value.isDebug
      offset = (ctx.bool)(isDebug, buffer, offset)
      let isFlat = value.isFlat
      offset = (ctx.bool)(isFlat, buffer, offset)
      let copyMetadata = value.copyMetadata
      offset = (ctx.bool)(copyMetadata, buffer, offset)
      let death = value.death
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          let dimensionName = value.dimensionName
          offset = (ctx.string)(dimensionName, buffer, offset)
          let location1 = value.location
          offset = (ctx.position)(location1, buffer, offset)
          return offset
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(death, buffer, offset)
      return offset
    },
    packet_entity_head_rotation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let headYaw = value.headYaw
      offset = (ctx.i8)(headYaw, buffer, offset)
      return offset
    },
    packet_camera: (value, buffer, offset) => {
      let cameraId = value.cameraId
      offset = (ctx.varint)(cameraId, buffer, offset)
      return offset
    },
    packet_held_item_slot: (value, buffer, offset) => {
      let slot = value.slot
      offset = (ctx.i8)(slot, buffer, offset)
      return offset
    },
    packet_update_view_position: (value, buffer, offset) => {
      let chunkX = value.chunkX
      offset = (ctx.varint)(chunkX, buffer, offset)
      let chunkZ = value.chunkZ
      offset = (ctx.varint)(chunkZ, buffer, offset)
      return offset
    },
    packet_update_view_distance: (value, buffer, offset) => {
      let viewDistance = value.viewDistance
      offset = (ctx.varint)(viewDistance, buffer, offset)
      return offset
    },
    packet_scoreboard_display_objective: (value, buffer, offset) => {
      let position = value.position
      offset = (ctx.i8)(position, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      return offset
    },
    packet_entity_metadata: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let metadata = value.metadata
      offset = (ctx.entityMetadata)(metadata, buffer, offset)
      return offset
    },
    packet_attach_entity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.i32)(entityId, buffer, offset)
      let vehicleId = value.vehicleId
      offset = (ctx.i32)(vehicleId, buffer, offset)
      return offset
    },
    packet_entity_velocity: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let velocityX = value.velocityX
      offset = (ctx.i16)(velocityX, buffer, offset)
      let velocityY = value.velocityY
      offset = (ctx.i16)(velocityY, buffer, offset)
      let velocityZ = value.velocityZ
      offset = (ctx.i16)(velocityZ, buffer, offset)
      return offset
    },
    packet_entity_equipment: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let equipments = value.equipments
      offset = ((value, buffer, offset) => {
        let prevOffset = offset
        let ind = 0
        for (const i in value) {
          prevOffset = offset
          offset = ((value, buffer, offset) => {
          let slot1 = value.slot
          offset = (ctx.i8)(slot1, buffer, offset)
          let item1 = value.item
          offset = (ctx.slot)(item1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
          buffer[prevOffset] = ind !== value.length-1 ? (buffer[prevOffset] | 128) : buffer[prevOffset]
          ind++
        }
        return offset
      })(equipments, buffer, offset)
      return offset
    },
    packet_experience: (value, buffer, offset) => {
      let experienceBar = value.experienceBar
      offset = (ctx.f32)(experienceBar, buffer, offset)
      let totalExperience = value.totalExperience
      offset = (ctx.varint)(totalExperience, buffer, offset)
      let level = value.level
      offset = (ctx.varint)(level, buffer, offset)
      return offset
    },
    packet_update_health: (value, buffer, offset) => {
      let health = value.health
      offset = (ctx.f32)(health, buffer, offset)
      let food = value.food
      offset = (ctx.varint)(food, buffer, offset)
      let foodSaturation = value.foodSaturation
      offset = (ctx.f32)(foodSaturation, buffer, offset)
      return offset
    },
    packet_scoreboard_objective: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let action = value.action
      offset = (ctx.i8)(action, buffer, offset)
      let displayText = value.displayText
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(displayText, buffer, offset)
      let type = value.type
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 2: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(type, buffer, offset)
      return offset
    },
    packet_set_passengers: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let passengers = value.passengers
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(passengers, buffer, offset)
      return offset
    },
    packet_teams: (value, buffer, offset) => {
      let team = value.team
      offset = (ctx.string)(team, buffer, offset)
      let mode = value.mode
      offset = (ctx.i8)(mode, buffer, offset)
      let name = value.name
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(name, buffer, offset)
      let friendlyFire = value.friendlyFire
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.i8)(value, buffer, offset)
          case 2: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(friendlyFire, buffer, offset)
      let nameTagVisibility = value.nameTagVisibility
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nameTagVisibility, buffer, offset)
      let collisionRule = value.collisionRule
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(collisionRule, buffer, offset)
      let formatting = value.formatting
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 2: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(formatting, buffer, offset)
      let prefix = value.prefix
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(prefix, buffer, offset)
      let suffix = value.suffix
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 2: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(suffix, buffer, offset)
      let players = value.players
      offset = ((value, buffer, offset) => {
        switch (mode) {
          case 0: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          case 3: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          case 4: return ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = (ctx.string)(value[i], buffer, offset)
            }
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(players, buffer, offset)
      return offset
    },
    packet_scoreboard_score: (value, buffer, offset) => {
      let itemName = value.itemName
      offset = (ctx.string)(itemName, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let scoreName = value.scoreName
      offset = (ctx.string)(scoreName, buffer, offset)
      let value1 = value.value
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 1: return (ctx.void)(value, buffer, offset)
          default: return (ctx.varint)(value, buffer, offset)
        }
      })(value1, buffer, offset)
      return offset
    },
    packet_spawn_position: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let angle = value.angle
      offset = (ctx.f32)(angle, buffer, offset)
      return offset
    },
    packet_update_time: (value, buffer, offset) => {
      let age = value.age
      offset = (ctx.i64)(age, buffer, offset)
      let time = value.time
      offset = (ctx.i64)(time, buffer, offset)
      return offset
    },
    packet_entity_sound_effect: (value, buffer, offset) => {
      let soundId = value.soundId
      offset = (ctx.varint)(soundId, buffer, offset)
      let soundEvent = value.soundEvent
      offset = ((value, buffer, offset) => {
        switch (soundId) {
          case 0: return ((value, buffer, offset) => {
            let resource = value.resource
            offset = (ctx.string)(resource, buffer, offset)
            let range = value.range
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.f32)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(range, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(soundEvent, buffer, offset)
      let soundCategory = value.soundCategory
      offset = (ctx.varint)(soundCategory, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let volume = value.volume
      offset = (ctx.f32)(volume, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let seed = value.seed
      offset = (ctx.i64)(seed, buffer, offset)
      return offset
    },
    packet_stop_sound: (value, buffer, offset) => {
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      let source = value.source
      offset = ((value, buffer, offset) => {
        switch (flags) {
          case 1: return (ctx.varint)(value, buffer, offset)
          case 3: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(source, buffer, offset)
      let sound = value.sound
      offset = ((value, buffer, offset) => {
        switch (flags) {
          case 2: return (ctx.string)(value, buffer, offset)
          case 3: return (ctx.string)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(sound, buffer, offset)
      return offset
    },
    packet_sound_effect: (value, buffer, offset) => {
      let soundId = value.soundId
      offset = (ctx.varint)(soundId, buffer, offset)
      let soundEvent = value.soundEvent
      offset = ((value, buffer, offset) => {
        switch (soundId) {
          case 0: return ((value, buffer, offset) => {
            let resource = value.resource
            offset = (ctx.string)(resource, buffer, offset)
            let range = value.range
            offset = ((value, buffer, offset) => {
              if (value != null) {
                offset = ctx.bool(1, buffer, offset)
                offset = (ctx.f32)(value, buffer, offset)
              } else {
                offset = ctx.bool(0, buffer, offset)
              }
              return offset
            })(range, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(soundEvent, buffer, offset)
      let soundCategory = value.soundCategory
      offset = (ctx.varint)(soundCategory, buffer, offset)
      let x = value.x
      offset = (ctx.i32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.i32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.i32)(z, buffer, offset)
      let volume = value.volume
      offset = (ctx.f32)(volume, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let seed = value.seed
      offset = (ctx.i64)(seed, buffer, offset)
      return offset
    },
    packet_system_chat: (value, buffer, offset) => {
      let content = value.content
      offset = (ctx.string)(content, buffer, offset)
      let isActionBar = value.isActionBar
      offset = (ctx.bool)(isActionBar, buffer, offset)
      return offset
    },
    packet_playerlist_header: (value, buffer, offset) => {
      let header = value.header
      offset = (ctx.string)(header, buffer, offset)
      let footer = value.footer
      offset = (ctx.string)(footer, buffer, offset)
      return offset
    },
    packet_collect: (value, buffer, offset) => {
      let collectedEntityId = value.collectedEntityId
      offset = (ctx.varint)(collectedEntityId, buffer, offset)
      let collectorEntityId = value.collectorEntityId
      offset = (ctx.varint)(collectorEntityId, buffer, offset)
      let pickupItemCount = value.pickupItemCount
      offset = (ctx.varint)(pickupItemCount, buffer, offset)
      return offset
    },
    packet_entity_teleport: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.i8)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.i8)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_entity_update_attributes: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value2 = value.value
          offset = (ctx.f64)(value2, buffer, offset)
          let modifiers = value.modifiers
          offset = ((value, buffer, offset) => {
            offset = (ctx.varint)(value.length, buffer, offset)
            for (let i = 0; i < value.length; i++) {
              offset = ((value, buffer, offset) => {
              let uuid = value.uuid
              offset = (ctx.UUID)(uuid, buffer, offset)
              let amount = value.amount
              offset = (ctx.f64)(amount, buffer, offset)
              let operation = value.operation
              offset = (ctx.i8)(operation, buffer, offset)
              return offset
            })(value[i], buffer, offset)
            }
            return offset
          })(modifiers, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    packet_feature_flags: (value, buffer, offset) => {
      let features = value.features
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(features, buffer, offset)
      return offset
    },
    packet_entity_effect: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let effectId = value.effectId
      offset = (ctx.varint)(effectId, buffer, offset)
      let amplifier = value.amplifier
      offset = (ctx.i8)(amplifier, buffer, offset)
      let duration = value.duration
      offset = (ctx.varint)(duration, buffer, offset)
      let hideParticles = value.hideParticles
      offset = (ctx.i8)(hideParticles, buffer, offset)
      let factorCodec = value.factorCodec
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.nbt)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(factorCodec, buffer, offset)
      return offset
    },
    packet_select_advancement_tab: (value, buffer, offset) => {
      let id = value.id
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(id, buffer, offset)
      return offset
    },
    packet_server_data: (value, buffer, offset) => {
      let motd = value.motd
      offset = (ctx.string)(motd, buffer, offset)
      let iconBytes = value.iconBytes
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          if (!(value instanceof Buffer)) value = Buffer.from(value)
          offset = (ctx.varint)(value.length, buffer, offset)
          value.copy(buffer, offset)
          return offset + value.length
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(iconBytes, buffer, offset)
      let enforcesSecureChat = value.enforcesSecureChat
      offset = (ctx.bool)(enforcesSecureChat, buffer, offset)
      return offset
    },
    packet_declare_recipes: (value, buffer, offset) => {
      let recipes = value.recipes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let type1 = value.type
          offset = (ctx.string)(type1, buffer, offset)
          let recipeId = value.recipeId
          offset = (ctx.string)(recipeId, buffer, offset)
          let data1 = value.data
          offset = ((value, buffer, offset) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((value, buffer, offset) => {
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let category1 = value.category
                offset = (ctx.varint)(category1, buffer, offset)
                let ingredients = value.ingredients
                offset = ((value, buffer, offset) => {
                  offset = (ctx.varint)(value.length, buffer, offset)
                  for (let i = 0; i < value.length; i++) {
                    offset = (ctx.ingredient)(value[i], buffer, offset)
                  }
                  return offset
                })(ingredients, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_shaped": return ((value, buffer, offset) => {
                let width = value.width
                offset = (ctx.varint)(width, buffer, offset)
                let height = value.height
                offset = (ctx.varint)(height, buffer, offset)
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let category1 = value.category
                offset = (ctx.varint)(category1, buffer, offset)
                let ingredients = value.ingredients
                offset = ((value, buffer, offset) => {
                  for (let i = 0; i < value.length; i++) {
                    offset = ((value, buffer, offset) => {
                    for (let i = 0; i < value.length; i++) {
                      offset = (ctx.ingredient)(value[i], buffer, offset)
                    }
                    return offset
                  })(value[i], buffer, offset)
                  }
                  return offset
                })(ingredients, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                let showNotification = value.showNotification
                offset = (ctx.bool)(showNotification, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(value, buffer, offset)
              case "minecraft:stonecutting": return ((value, buffer, offset) => {
                let group1 = value.group
                offset = (ctx.string)(group1, buffer, offset)
                let ingredient1 = value.ingredient
                offset = (ctx.ingredient)(ingredient1, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing": return ((value, buffer, offset) => {
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing_transform": return ((value, buffer, offset) => {
                let template = value.template
                offset = (ctx.ingredient)(template, buffer, offset)
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:smithing_trim": return ((value, buffer, offset) => {
                let base = value.base
                offset = (ctx.ingredient)(base, buffer, offset)
                let addition = value.addition
                offset = (ctx.ingredient)(addition, buffer, offset)
                let result1 = value.result
                offset = (ctx.slot)(result1, buffer, offset)
                return offset
              })(value, buffer, offset)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(data1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(recipes, buffer, offset)
      return offset
    },
    packet_tags: (value, buffer, offset) => {
      let tags = value.tags
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let tagType = value.tagType
          offset = (ctx.string)(tagType, buffer, offset)
          let tags1 = value.tags
          offset = (ctx.tags)(tags1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(tags, buffer, offset)
      return offset
    },
    packet_acknowledge_player_digging: (value, buffer, offset) => {
      let sequenceId = value.sequenceId
      offset = (ctx.varint)(sequenceId, buffer, offset)
      return offset
    },
    packet_clear_titles: (value, buffer, offset) => {
      let reset = value.reset
      offset = (ctx.bool)(reset, buffer, offset)
      return offset
    },
    packet_initialize_world_border: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let oldDiameter = value.oldDiameter
      offset = (ctx.f64)(oldDiameter, buffer, offset)
      let newDiameter = value.newDiameter
      offset = (ctx.f64)(newDiameter, buffer, offset)
      let speed = value.speed
      offset = (ctx.varint)(speed, buffer, offset)
      let portalTeleportBoundary = value.portalTeleportBoundary
      offset = (ctx.varint)(portalTeleportBoundary, buffer, offset)
      let warningBlocks = value.warningBlocks
      offset = (ctx.varint)(warningBlocks, buffer, offset)
      let warningTime = value.warningTime
      offset = (ctx.varint)(warningTime, buffer, offset)
      return offset
    },
    packet_action_bar: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_world_border_center: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    packet_world_border_lerp_size: (value, buffer, offset) => {
      let oldDiameter = value.oldDiameter
      offset = (ctx.f64)(oldDiameter, buffer, offset)
      let newDiameter = value.newDiameter
      offset = (ctx.f64)(newDiameter, buffer, offset)
      let speed = value.speed
      offset = (ctx.varint)(speed, buffer, offset)
      return offset
    },
    packet_world_border_size: (value, buffer, offset) => {
      let diameter = value.diameter
      offset = (ctx.f64)(diameter, buffer, offset)
      return offset
    },
    packet_world_border_warning_delay: (value, buffer, offset) => {
      let warningTime = value.warningTime
      offset = (ctx.varint)(warningTime, buffer, offset)
      return offset
    },
    packet_world_border_warning_reach: (value, buffer, offset) => {
      let warningBlocks = value.warningBlocks
      offset = (ctx.varint)(warningBlocks, buffer, offset)
      return offset
    },
    packet_ping: (value, buffer, offset) => {
      let id = value.id
      offset = (ctx.i32)(id, buffer, offset)
      return offset
    },
    packet_set_title_subtitle: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_set_title_text: (value, buffer, offset) => {
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_set_title_time: (value, buffer, offset) => {
      let fadeIn = value.fadeIn
      offset = (ctx.i32)(fadeIn, buffer, offset)
      let stay = value.stay
      offset = (ctx.i32)(stay, buffer, offset)
      let fadeOut = value.fadeOut
      offset = (ctx.i32)(fadeOut, buffer, offset)
      return offset
    },
    packet_simulation_distance: (value, buffer, offset) => {
      let distance = value.distance
      offset = (ctx.varint)(distance, buffer, offset)
      return offset
    },
    packet_chunk_biomes: (value, buffer, offset) => {
      let biomes = value.biomes
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let position1 = value.position
          offset = (ctx.position)(position1, buffer, offset)
          let data1 = value.data
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(data1, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(biomes, buffer, offset)
      return offset
    },
    packet_damage_event: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let sourceTypeId = value.sourceTypeId
      offset = (ctx.varint)(sourceTypeId, buffer, offset)
      let sourceCauseId = value.sourceCauseId
      offset = (ctx.varint)(sourceCauseId, buffer, offset)
      let sourceDirectId = value.sourceDirectId
      offset = (ctx.varint)(sourceDirectId, buffer, offset)
      let sourcePosition = value.sourcePosition
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.vec3f64)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(sourcePosition, buffer, offset)
      return offset
    },
    packet_hurt_animation: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"bundle_delimiter":0,"spawn_entity":1,"spawn_entity_experience_orb":2,"named_entity_spawn":3,"animation":4,"statistics":5,"acknowledge_player_digging":6,"block_break_animation":7,"tile_entity_data":8,"block_action":9,"block_change":10,"boss_bar":11,"difficulty":12,"chunk_biomes":13,"clear_titles":14,"tab_complete":15,"declare_commands":16,"close_window":17,"window_items":18,"craft_progress_bar":19,"set_slot":20,"set_cooldown":21,"chat_suggestions":22,"custom_payload":23,"damage_event":24,"hide_message":25,"kick_disconnect":26,"profileless_chat":27,"entity_status":28,"explosion":29,"unload_chunk":30,"game_state_change":31,"open_horse_window":32,"hurt_animation":33,"initialize_world_border":34,"keep_alive":35,"map_chunk":36,"world_event":37,"world_particles":38,"update_light":39,"login":40,"map":41,"trade_list":42,"rel_entity_move":43,"entity_move_look":44,"entity_look":45,"vehicle_move":46,"open_book":47,"open_window":48,"open_sign_entity":49,"ping":50,"craft_recipe_response":51,"abilities":52,"player_chat":53,"end_combat_event":54,"enter_combat_event":55,"death_combat_event":56,"player_remove":57,"player_info":58,"face_player":59,"position":60,"unlock_recipes":61,"entity_destroy":62,"remove_entity_effect":63,"resource_pack_send":64,"respawn":65,"entity_head_rotation":66,"multi_block_change":67,"select_advancement_tab":68,"server_data":69,"action_bar":70,"world_border_center":71,"world_border_lerp_size":72,"world_border_size":73,"world_border_warning_delay":74,"world_border_warning_reach":75,"camera":76,"held_item_slot":77,"update_view_position":78,"update_view_distance":79,"spawn_position":80,"scoreboard_display_objective":81,"entity_metadata":82,"attach_entity":83,"entity_velocity":84,"entity_equipment":85,"experience":86,"update_health":87,"scoreboard_objective":88,"set_passengers":89,"teams":90,"scoreboard_score":91,"simulation_distance":92,"set_title_subtitle":93,"update_time":94,"set_title_text":95,"set_title_time":96,"entity_sound_effect":97,"sound_effect":98,"stop_sound":99,"system_chat":100,"playerlist_header":101,"nbt_query_response":102,"collect":103,"entity_teleport":104,"advancements":105,"entity_update_attributes":106,"feature_flags":107,"entity_effect":108,"declare_recipes":109,"tags":110}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(value, buffer, offset)
          case "spawn_entity": return (ctx.packet_spawn_entity)(value, buffer, offset)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(value, buffer, offset)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(value, buffer, offset)
          case "animation": return (ctx.packet_animation)(value, buffer, offset)
          case "statistics": return (ctx.packet_statistics)(value, buffer, offset)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(value, buffer, offset)
          case "block_break_animation": return (ctx.packet_block_break_animation)(value, buffer, offset)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(value, buffer, offset)
          case "block_action": return (ctx.packet_block_action)(value, buffer, offset)
          case "block_change": return (ctx.packet_block_change)(value, buffer, offset)
          case "boss_bar": return (ctx.packet_boss_bar)(value, buffer, offset)
          case "difficulty": return (ctx.packet_difficulty)(value, buffer, offset)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(value, buffer, offset)
          case "clear_titles": return (ctx.packet_clear_titles)(value, buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(value, buffer, offset)
          case "declare_commands": return (ctx.packet_declare_commands)(value, buffer, offset)
          case "close_window": return (ctx.packet_close_window)(value, buffer, offset)
          case "window_items": return (ctx.packet_window_items)(value, buffer, offset)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(value, buffer, offset)
          case "set_slot": return (ctx.packet_set_slot)(value, buffer, offset)
          case "set_cooldown": return (ctx.packet_set_cooldown)(value, buffer, offset)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(value, buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(value, buffer, offset)
          case "damage_event": return (ctx.packet_damage_event)(value, buffer, offset)
          case "hide_message": return (ctx.packet_hide_message)(value, buffer, offset)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(value, buffer, offset)
          case "profileless_chat": return (ctx.packet_profileless_chat)(value, buffer, offset)
          case "entity_status": return (ctx.packet_entity_status)(value, buffer, offset)
          case "explosion": return (ctx.packet_explosion)(value, buffer, offset)
          case "unload_chunk": return (ctx.packet_unload_chunk)(value, buffer, offset)
          case "game_state_change": return (ctx.packet_game_state_change)(value, buffer, offset)
          case "open_horse_window": return (ctx.packet_open_horse_window)(value, buffer, offset)
          case "hurt_animation": return (ctx.packet_hurt_animation)(value, buffer, offset)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(value, buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(value, buffer, offset)
          case "map_chunk": return (ctx.packet_map_chunk)(value, buffer, offset)
          case "world_event": return (ctx.packet_world_event)(value, buffer, offset)
          case "world_particles": return (ctx.packet_world_particles)(value, buffer, offset)
          case "update_light": return (ctx.packet_update_light)(value, buffer, offset)
          case "login": return (ctx.packet_login)(value, buffer, offset)
          case "map": return (ctx.packet_map)(value, buffer, offset)
          case "trade_list": return (ctx.packet_trade_list)(value, buffer, offset)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(value, buffer, offset)
          case "entity_move_look": return (ctx.packet_entity_move_look)(value, buffer, offset)
          case "entity_look": return (ctx.packet_entity_look)(value, buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value, buffer, offset)
          case "open_book": return (ctx.packet_open_book)(value, buffer, offset)
          case "open_window": return (ctx.packet_open_window)(value, buffer, offset)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(value, buffer, offset)
          case "ping": return (ctx.packet_ping)(value, buffer, offset)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(value, buffer, offset)
          case "abilities": return (ctx.packet_abilities)(value, buffer, offset)
          case "player_chat": return (ctx.packet_player_chat)(value, buffer, offset)
          case "end_combat_event": return (ctx.packet_end_combat_event)(value, buffer, offset)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(value, buffer, offset)
          case "death_combat_event": return (ctx.packet_death_combat_event)(value, buffer, offset)
          case "player_remove": return (ctx.packet_player_remove)(value, buffer, offset)
          case "player_info": return (ctx.packet_player_info)(value, buffer, offset)
          case "face_player": return (ctx.packet_face_player)(value, buffer, offset)
          case "position": return (ctx.packet_position)(value, buffer, offset)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(value, buffer, offset)
          case "entity_destroy": return (ctx.packet_entity_destroy)(value, buffer, offset)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(value, buffer, offset)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(value, buffer, offset)
          case "respawn": return (ctx.packet_respawn)(value, buffer, offset)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(value, buffer, offset)
          case "multi_block_change": return (ctx.packet_multi_block_change)(value, buffer, offset)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(value, buffer, offset)
          case "server_data": return (ctx.packet_server_data)(value, buffer, offset)
          case "action_bar": return (ctx.packet_action_bar)(value, buffer, offset)
          case "world_border_center": return (ctx.packet_world_border_center)(value, buffer, offset)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(value, buffer, offset)
          case "world_border_size": return (ctx.packet_world_border_size)(value, buffer, offset)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(value, buffer, offset)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(value, buffer, offset)
          case "camera": return (ctx.packet_camera)(value, buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value, buffer, offset)
          case "update_view_position": return (ctx.packet_update_view_position)(value, buffer, offset)
          case "update_view_distance": return (ctx.packet_update_view_distance)(value, buffer, offset)
          case "spawn_position": return (ctx.packet_spawn_position)(value, buffer, offset)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(value, buffer, offset)
          case "entity_metadata": return (ctx.packet_entity_metadata)(value, buffer, offset)
          case "attach_entity": return (ctx.packet_attach_entity)(value, buffer, offset)
          case "entity_velocity": return (ctx.packet_entity_velocity)(value, buffer, offset)
          case "entity_equipment": return (ctx.packet_entity_equipment)(value, buffer, offset)
          case "experience": return (ctx.packet_experience)(value, buffer, offset)
          case "update_health": return (ctx.packet_update_health)(value, buffer, offset)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(value, buffer, offset)
          case "set_passengers": return (ctx.packet_set_passengers)(value, buffer, offset)
          case "teams": return (ctx.packet_teams)(value, buffer, offset)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(value, buffer, offset)
          case "simulation_distance": return (ctx.packet_simulation_distance)(value, buffer, offset)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(value, buffer, offset)
          case "update_time": return (ctx.packet_update_time)(value, buffer, offset)
          case "set_title_text": return (ctx.packet_set_title_text)(value, buffer, offset)
          case "set_title_time": return (ctx.packet_set_title_time)(value, buffer, offset)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(value, buffer, offset)
          case "sound_effect": return (ctx.packet_sound_effect)(value, buffer, offset)
          case "stop_sound": return (ctx.packet_stop_sound)(value, buffer, offset)
          case "system_chat": return (ctx.packet_system_chat)(value, buffer, offset)
          case "playerlist_header": return (ctx.packet_playerlist_header)(value, buffer, offset)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(value, buffer, offset)
          case "collect": return (ctx.packet_collect)(value, buffer, offset)
          case "entity_teleport": return (ctx.packet_entity_teleport)(value, buffer, offset)
          case "advancements": return (ctx.packet_advancements)(value, buffer, offset)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(value, buffer, offset)
          case "feature_flags": return (ctx.packet_feature_flags)(value, buffer, offset)
          case "entity_effect": return (ctx.packet_entity_effect)(value, buffer, offset)
          case "declare_recipes": return (ctx.packet_declare_recipes)(value, buffer, offset)
          case "tags": return (ctx.packet_tags)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_spawn_entity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: objectUUID, size: objectUUIDSize } = (ctx.UUID)(buffer, offset + entityIdSize)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + entityIdSize + objectUUIDSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize)
      let { value: headPitch, size: headPitchSize } = (ctx.i8)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize)
      let { value: objectData, size: objectDataSize } = (ctx.varint)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize)
      let { value: velocityX, size: velocityXSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize)
      let { value: velocityY, size: velocityYSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize)
      let { value: velocityZ, size: velocityZSize } = (ctx.i16)(buffer, offset + entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize + velocityYSize)
      return { value: { entityId, objectUUID, type, x, y, z, pitch, yaw, headPitch, objectData, velocityX, velocityY, velocityZ }, size: entityIdSize + objectUUIDSize + typeSize + xSize + ySize + zSize + pitchSize + yawSize + headPitchSize + objectDataSize + velocityXSize + velocityYSize + velocityZSize}
    },
    packet_spawn_entity_experience_orb: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + xSize + ySize)
      let { value: count, size: countSize } = (ctx.i16)(buffer, offset + entityIdSize + xSize + ySize + zSize)
      return { value: { entityId, x, y, z, count }, size: entityIdSize + xSize + ySize + zSize + countSize}
    },
    packet_named_entity_spawn: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: playerUUID, size: playerUUIDSize } = (ctx.UUID)(buffer, offset + entityIdSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + playerUUIDSize + xSize + ySize + zSize + yawSize)
      return { value: { entityId, playerUUID, x, y, z, yaw, pitch }, size: entityIdSize + playerUUIDSize + xSize + ySize + zSize + yawSize + pitchSize}
    },
    packet_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: animation, size: animationSize } = (ctx.u8)(buffer, offset + entityIdSize)
      return { value: { entityId, animation }, size: entityIdSize + animationSize}
    },
    packet_statistics: (buffer, offset) => {
      let { value: entries, size: entriesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: categoryId, size: categoryIdSize } = (ctx.varint)(buffer, offset)
          let { value: statisticId, size: statisticIdSize } = (ctx.varint)(buffer, offset + categoryIdSize)
          let { value: value1, size: value1Size } = (ctx.varint)(buffer, offset + categoryIdSize + statisticIdSize)
          return { value: { categoryId, statisticId, value: value1 }, size: categoryIdSize + statisticIdSize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { entries }, size: entriesSize}
    },
    packet_advancements: (buffer, offset) => {
      let { value: reset, size: resetSize } = (ctx.bool)(buffer, offset)
      let { value: advancementMapping, size: advancementMappingSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = ((buffer, offset) => {
            let { value: parentId, size: parentIdSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.string)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset)
            let { value: displayData, size: displayDataSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = ((buffer, offset) => {
                let { value: title, size: titleSize } = (ctx.string)(buffer, offset)
                let { value: description, size: descriptionSize } = (ctx.string)(buffer, offset + titleSize)
                let { value: icon, size: iconSize } = (ctx.slot)(buffer, offset + titleSize + descriptionSize)
                let { value: frameType, size: frameTypeSize } = (ctx.varint)(buffer, offset + titleSize + descriptionSize + iconSize)
                let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                  if ( offset + 4 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  bits = (bits << 8) | buffer[offset++]
                  let _unused = (bits >> 3) & 0x1fffffff
                  let hidden = (bits >> 2) & 0x1
                  let show_toast = (bits >> 1) & 0x1
                  let has_background_texture = (bits >> 0) & 0x1
                  return { value: { _unused, hidden, show_toast, has_background_texture }, size: 4 }
                })(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize)
                let { value: backgroundTexture, size: backgroundTextureSize } = ((buffer, offset) => {
                  switch (flags1.has_background_texture) {
                    case 1: return (ctx.string)(buffer, offset)
                    default: return (ctx.void)(buffer, offset)
                  }
                })(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size)
                let { value: xCord, size: xCordSize } = (ctx.f32)(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize)
                let { value: yCord, size: yCordSize } = (ctx.f32)(buffer, offset + titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize + xCordSize)
                return { value: { title, description, icon, frameType, flags: flags1, backgroundTexture, xCord, yCord }, size: titleSize + descriptionSize + iconSize + frameTypeSize + flags1Size + backgroundTextureSize + xCordSize + yCordSize}
              })(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + parentIdSize)
            let { value: criteria, size: criteriaSize } = ((buffer, offset) => {
              const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
              if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
              const data = []
              let size = countSize
              for (let i = 0; i < count; i++) {
                const elem = ((buffer, offset) => {
                let { value: key1, size: key1Size } = (ctx.string)(buffer, offset)
                let { value: value2, size: value2Size } = (ctx.void)(buffer, offset + key1Size)
                return { value: { key: key1, value: value2 }, size: key1Size + value2Size}
              })(buffer, offset + size)
                data.push(elem.value)
                size += elem.size
              }
              return { value: data, size }
            })(buffer, offset + parentIdSize + displayDataSize)
            let { value: requirements, size: requirementsSize } = ((buffer, offset) => {
              const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
              if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
              const data = []
              let size = countSize
              for (let i = 0; i < count; i++) {
                const elem = ((buffer, offset) => {
                const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
                if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                const data = []
                let size = countSize
                for (let i = 0; i < count; i++) {
                  const elem = (ctx.string)(buffer, offset + size)
                  data.push(elem.value)
                  size += elem.size
                }
                return { value: data, size }
              })(buffer, offset + size)
                data.push(elem.value)
                size += elem.size
              }
              return { value: data, size }
            })(buffer, offset + parentIdSize + displayDataSize + criteriaSize)
            return { value: { parentId, displayData, criteria, requirements }, size: parentIdSize + displayDataSize + criteriaSize + requirementsSize}
          })(buffer, offset + keySize)
          return { value: { key, value: value1 }, size: keySize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize)
      let { value: identifiers, size: identifiersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize + advancementMappingSize)
      let { value: progressMapping, size: progressMappingSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = ((buffer, offset) => {
              let { value: criterionIdentifier, size: criterionIdentifierSize } = (ctx.string)(buffer, offset)
              let { value: criterionProgress, size: criterionProgressSize } = ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.i64)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset + criterionIdentifierSize)
              return { value: { criterionIdentifier, criterionProgress }, size: criterionIdentifierSize + criterionProgressSize}
            })(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset + keySize)
          return { value: { key, value: value1 }, size: keySize + value1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + resetSize + advancementMappingSize + identifiersSize)
      return { value: { reset, advancementMapping, identifiers, progressMapping }, size: resetSize + advancementMappingSize + identifiersSize + progressMappingSize}
    },
    packet_block_break_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + entityIdSize)
      let { value: destroyStage, size: destroyStageSize } = (ctx.i8)(buffer, offset + entityIdSize + locationSize)
      return { value: { entityId, location, destroyStage }, size: entityIdSize + locationSize + destroyStageSize}
    },
    packet_tile_entity_data: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + locationSize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + locationSize + actionSize)
      return { value: { location, action, nbtData }, size: locationSize + actionSize + nbtDataSize}
    },
    packet_block_action: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: byte1, size: byte1Size } = (ctx.u8)(buffer, offset + locationSize)
      let { value: byte2, size: byte2Size } = (ctx.u8)(buffer, offset + locationSize + byte1Size)
      let { value: blockId, size: blockIdSize } = (ctx.varint)(buffer, offset + locationSize + byte1Size + byte2Size)
      return { value: { location, byte1, byte2, blockId }, size: locationSize + byte1Size + byte2Size + blockIdSize}
    },
    packet_block_change: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + locationSize)
      return { value: { location, type }, size: locationSize + typeSize}
    },
    packet_boss_bar: (buffer, offset) => {
      let { value: entityUUID, size: entityUUIDSize } = (ctx.UUID)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + entityUUIDSize)
      let { value: title, size: titleSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(buffer, offset)
          case 3: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize)
      let { value: health, size: healthSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.f32)(buffer, offset)
          case 2: return (ctx.f32)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize)
      let { value: color, size: colorSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 4: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize)
      let { value: dividers, size: dividersSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 4: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize + colorSize)
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.u8)(buffer, offset)
          case 5: return (ctx.u8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + entityUUIDSize + actionSize + titleSize + healthSize + colorSize + dividersSize)
      return { value: { entityUUID, action, title, health, color, dividers, flags }, size: entityUUIDSize + actionSize + titleSize + healthSize + colorSize + dividersSize + flagsSize}
    },
    packet_difficulty: (buffer, offset) => {
      let { value: difficulty, size: difficultySize } = (ctx.u8)(buffer, offset)
      let { value: difficultyLocked, size: difficultyLockedSize } = (ctx.bool)(buffer, offset + difficultySize)
      return { value: { difficulty, difficultyLocked }, size: difficultySize + difficultyLockedSize}
    },
    packet_tab_complete: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: start, size: startSize } = (ctx.varint)(buffer, offset + transactionIdSize)
      let { value: length, size: lengthSize } = (ctx.varint)(buffer, offset + transactionIdSize + startSize)
      let { value: matches, size: matchesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: match, size: matchSize } = (ctx.string)(buffer, offset)
          let { value: tooltip, size: tooltipSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + matchSize)
          return { value: { match, tooltip }, size: matchSize + tooltipSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + transactionIdSize + startSize + lengthSize)
      return { value: { transactionId, start, length, matches }, size: transactionIdSize + startSize + lengthSize + matchesSize}
    },
    packet_declare_commands: (buffer, offset) => {
      let { value: nodes, size: nodesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.command_node)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      let { value: rootIndex, size: rootIndexSize } = (ctx.varint)(buffer, offset + nodesSize)
      return { value: { nodes, rootIndex }, size: nodesSize + rootIndexSize}
    },
    packet_face_player: (buffer, offset) => {
      let { value: feet_eyes, size: feet_eyesSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + feet_eyesSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + feet_eyesSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + feet_eyesSize + xSize + ySize)
      let { value: isEntity, size: isEntitySize } = (ctx.bool)(buffer, offset + feet_eyesSize + xSize + ySize + zSize)
      let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + feet_eyesSize + xSize + ySize + zSize + isEntitySize)
      let { value: entity_feet_eyes, size: entity_feet_eyesSize } = ((buffer, offset) => {
        switch (isEntity) {
          case true: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + feet_eyesSize + xSize + ySize + zSize + isEntitySize + entityIdSize)
      return { value: { feet_eyes, x, y, z, isEntity, entityId, entity_feet_eyes }, size: feet_eyesSize + xSize + ySize + zSize + isEntitySize + entityIdSize + entity_feet_eyesSize}
    },
    packet_nbt_query_response: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: nbt, size: nbtSize } = (ctx.optionalNbt)(buffer, offset + transactionIdSize)
      return { value: { transactionId, nbt }, size: transactionIdSize + nbtSize}
    },
    packet_multi_block_change: (buffer, offset) => {
      let { value: chunkCoordinates, size: chunkCoordinatesSize } = ((buffer, offset) => {
        if ( offset + 8 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let x = (bits >> 2) & 0x3fffff
        x -= (x & 0x200000) << 1
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let z = (bits >> 4) & 0x3fffff
        z -= (z & 0x200000) << 1
        bits = (bits << 8) | buffer[offset++]
        bits = (bits << 8) | buffer[offset++]
        let y = (bits >> 0) & 0xfffff
        y -= (y & 0x80000) << 1
        return { value: { x, z, y }, size: 8 }
      })(buffer, offset)
      let { value: suppressLightUpdates, size: suppressLightUpdatesSize } = (ctx.bool)(buffer, offset + chunkCoordinatesSize)
      let { value: records, size: recordsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkCoordinatesSize + suppressLightUpdatesSize)
      return { value: { chunkCoordinates, suppressLightUpdates, records }, size: chunkCoordinatesSize + suppressLightUpdatesSize + recordsSize}
    },
    packet_close_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      return { value: { windowId }, size: windowIdSize}
    },
    packet_open_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.varint)(buffer, offset)
      let { value: inventoryType, size: inventoryTypeSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: windowTitle, size: windowTitleSize } = (ctx.string)(buffer, offset + windowIdSize + inventoryTypeSize)
      return { value: { windowId, inventoryType, windowTitle }, size: windowIdSize + inventoryTypeSize + windowTitleSize}
    },
    packet_window_items: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: stateId, size: stateIdSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: items, size: itemsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.slot)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + windowIdSize + stateIdSize)
      let { value: carriedItem, size: carriedItemSize } = (ctx.slot)(buffer, offset + windowIdSize + stateIdSize + itemsSize)
      return { value: { windowId, stateId, items, carriedItem }, size: windowIdSize + stateIdSize + itemsSize + carriedItemSize}
    },
    packet_craft_progress_bar: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: property, size: propertySize } = (ctx.i16)(buffer, offset + windowIdSize)
      let { value: value1, size: value1Size } = (ctx.i16)(buffer, offset + windowIdSize + propertySize)
      return { value: { windowId, property, value: value1 }, size: windowIdSize + propertySize + value1Size}
    },
    packet_set_slot: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: stateId, size: stateIdSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: slot, size: slotSize } = (ctx.i16)(buffer, offset + windowIdSize + stateIdSize)
      let { value: item, size: itemSize } = (ctx.slot)(buffer, offset + windowIdSize + stateIdSize + slotSize)
      return { value: { windowId, stateId, slot, item }, size: windowIdSize + stateIdSize + slotSize + itemSize}
    },
    packet_set_cooldown: (buffer, offset) => {
      let { value: itemID, size: itemIDSize } = (ctx.varint)(buffer, offset)
      let { value: cooldownTicks, size: cooldownTicksSize } = (ctx.varint)(buffer, offset + itemIDSize)
      return { value: { itemID, cooldownTicks }, size: itemIDSize + cooldownTicksSize}
    },
    packet_chat_suggestions: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset)
      let { value: entries, size: entriesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize)
      return { value: { action, entries }, size: actionSize + entriesSize}
    },
    packet_custom_payload: (buffer, offset) => {
      let { value: channel, size: channelSize } = (ctx.string)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.restBuffer)(buffer, offset + channelSize)
      return { value: { channel, data }, size: channelSize + dataSize}
    },
    packet_hide_message: (buffer, offset) => {
      let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        switch (id) {
          case 0: return ((buffer, offset) => {
            const count = 256
            const countSize = 0
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + idSize)
      return { value: { id, signature }, size: idSize + signatureSize}
    },
    packet_kick_disconnect: (buffer, offset) => {
      let { value: reason, size: reasonSize } = (ctx.string)(buffer, offset)
      return { value: { reason }, size: reasonSize}
    },
    packet_profileless_chat: (buffer, offset) => {
      let { value: message, size: messageSize } = (ctx.string)(buffer, offset)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + messageSize)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + messageSize + typeSize)
      let { value: target, size: targetSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + messageSize + typeSize + nameSize)
      return { value: { message, type, name, target }, size: messageSize + typeSize + nameSize + targetSize}
    },
    packet_entity_status: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: entityStatus, size: entityStatusSize } = (ctx.i8)(buffer, offset + entityIdSize)
      return { value: { entityId, entityStatus }, size: entityIdSize + entityStatusSize}
    },
    packet_explosion: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: radius, size: radiusSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: affectedBlockOffsets, size: affectedBlockOffsetsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: x1, size: x1Size } = (ctx.i8)(buffer, offset)
          let { value: y1, size: y1Size } = (ctx.i8)(buffer, offset + x1Size)
          let { value: z1, size: z1Size } = (ctx.i8)(buffer, offset + x1Size + y1Size)
          return { value: { x: x1, y: y1, z: z1 }, size: x1Size + y1Size + z1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + ySize + zSize + radiusSize)
      let { value: playerMotionX, size: playerMotionXSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize)
      let { value: playerMotionY, size: playerMotionYSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize)
      let { value: playerMotionZ, size: playerMotionZSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize + playerMotionYSize)
      return { value: { x, y, z, radius, affectedBlockOffsets, playerMotionX, playerMotionY, playerMotionZ }, size: xSize + ySize + zSize + radiusSize + affectedBlockOffsetsSize + playerMotionXSize + playerMotionYSize + playerMotionZSize}
    },
    packet_unload_chunk: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.i32)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.i32)(buffer, offset + chunkXSize)
      return { value: { chunkX, chunkZ }, size: chunkXSize + chunkZSize}
    },
    packet_game_state_change: (buffer, offset) => {
      let { value: reason, size: reasonSize } = (ctx.u8)(buffer, offset)
      let { value: gameMode, size: gameModeSize } = (ctx.f32)(buffer, offset + reasonSize)
      return { value: { reason, gameMode }, size: reasonSize + gameModeSize}
    },
    packet_open_horse_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: nbSlots, size: nbSlotsSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + windowIdSize + nbSlotsSize)
      return { value: { windowId, nbSlots, entityId }, size: windowIdSize + nbSlotsSize + entityIdSize}
    },
    packet_keep_alive: (buffer, offset) => {
      let { value: keepAliveId, size: keepAliveIdSize } = (ctx.i64)(buffer, offset)
      return { value: { keepAliveId }, size: keepAliveIdSize}
    },
    packet_map_chunk: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.i32)(buffer, offset)
      let { value: z, size: zSize } = (ctx.i32)(buffer, offset + xSize)
      let { value: heightmaps, size: heightmapsSize } = (ctx.nbt)(buffer, offset + xSize + zSize)
      let { value: chunkData, size: chunkDataSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + xSize + zSize + heightmapsSize)
      let { value: blockEntities, size: blockEntitiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.chunkBlockEntity)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize)
      let { value: trustEdges, size: trustEdgesSize } = (ctx.bool)(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize)
      let { value: skyLightMask, size: skyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize)
      let { value: blockLightMask, size: blockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize)
      let { value: emptySkyLightMask, size: emptySkyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize)
      let { value: emptyBlockLightMask, size: emptyBlockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize)
      let { value: skyLight, size: skyLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize)
      let { value: blockLight, size: blockLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize)
      return { value: { x, z, heightmaps, chunkData, blockEntities, trustEdges, skyLightMask, blockLightMask, emptySkyLightMask, emptyBlockLightMask, skyLight, blockLight }, size: xSize + zSize + heightmapsSize + chunkDataSize + blockEntitiesSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize + blockLightSize}
    },
    packet_world_event: (buffer, offset) => {
      let { value: effectId, size: effectIdSize } = (ctx.i32)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + effectIdSize)
      let { value: data, size: dataSize } = (ctx.i32)(buffer, offset + effectIdSize + locationSize)
      let { value: global, size: globalSize } = (ctx.bool)(buffer, offset + effectIdSize + locationSize + dataSize)
      return { value: { effectId, location, data, global }, size: effectIdSize + locationSize + dataSize + globalSize}
    },
    packet_world_particles: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: longDistance, size: longDistanceSize } = (ctx.bool)(buffer, offset + particleIdSize)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize)
      let { value: offsetX, size: offsetXSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize)
      let { value: offsetY, size: offsetYSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize)
      let { value: offsetZ, size: offsetZSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize)
      let { value: particleData, size: particleDataSize } = (ctx.f32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize)
      let { value: particles, size: particlesSize } = (ctx.i32)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize + particlesSize, particleId)
      return { value: { particleId, longDistance, x, y, z, offsetX, offsetY, offsetZ, particleData, particles, data }, size: particleIdSize + longDistanceSize + xSize + ySize + zSize + offsetXSize + offsetYSize + offsetZSize + particleDataSize + particlesSize + dataSize}
    },
    packet_update_light: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.varint)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.varint)(buffer, offset + chunkXSize)
      let { value: trustEdges, size: trustEdgesSize } = (ctx.bool)(buffer, offset + chunkXSize + chunkZSize)
      let { value: skyLightMask, size: skyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize)
      let { value: blockLightMask, size: blockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize)
      let { value: emptySkyLightMask, size: emptySkyLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize)
      let { value: emptyBlockLightMask, size: emptyBlockLightMaskSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.i64)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize)
      let { value: skyLight, size: skyLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize)
      let { value: blockLight, size: blockLightSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.u8)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize)
      return { value: { chunkX, chunkZ, trustEdges, skyLightMask, blockLightMask, emptySkyLightMask, emptyBlockLightMask, skyLight, blockLight }, size: chunkXSize + chunkZSize + trustEdgesSize + skyLightMaskSize + blockLightMaskSize + emptySkyLightMaskSize + emptyBlockLightMaskSize + skyLightSize + blockLightSize}
    },
    packet_login: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: isHardcore, size: isHardcoreSize } = (ctx.bool)(buffer, offset + entityIdSize)
      let { value: gameMode, size: gameModeSize } = (ctx.u8)(buffer, offset + entityIdSize + isHardcoreSize)
      let { value: previousGameMode, size: previousGameModeSize } = (ctx.i8)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize)
      let { value: worldNames, size: worldNamesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize)
      let { value: dimensionCodec, size: dimensionCodecSize } = (ctx.nbt)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize)
      let { value: worldType, size: worldTypeSize } = (ctx.string)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize)
      let { value: worldName, size: worldNameSize } = (ctx.string)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize)
      let { value: hashedSeed, size: hashedSeedSize } = (ctx.i64)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize)
      let { value: maxPlayers, size: maxPlayersSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize)
      let { value: viewDistance, size: viewDistanceSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize)
      let { value: simulationDistance, size: simulationDistanceSize } = (ctx.varint)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize)
      let { value: reducedDebugInfo, size: reducedDebugInfoSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize)
      let { value: enableRespawnScreen, size: enableRespawnScreenSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize)
      let { value: isDebug, size: isDebugSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize)
      let { value: isFlat, size: isFlatSize } = (ctx.bool)(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize)
      let { value: death, size: deathSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          let { value: dimensionName, size: dimensionNameSize } = (ctx.string)(buffer, offset)
          let { value: location1, size: location1Size } = (ctx.position)(buffer, offset + dimensionNameSize)
          return { value: { dimensionName, location: location1 }, size: dimensionNameSize + location1Size}
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize + isFlatSize)
      return { value: { entityId, isHardcore, gameMode, previousGameMode, worldNames, dimensionCodec, worldType, worldName, hashedSeed, maxPlayers, viewDistance, simulationDistance, reducedDebugInfo, enableRespawnScreen, isDebug, isFlat, death }, size: entityIdSize + isHardcoreSize + gameModeSize + previousGameModeSize + worldNamesSize + dimensionCodecSize + worldTypeSize + worldNameSize + hashedSeedSize + maxPlayersSize + viewDistanceSize + simulationDistanceSize + reducedDebugInfoSize + enableRespawnScreenSize + isDebugSize + isFlatSize + deathSize}
    },
    packet_map: (buffer, offset) => {
      let { value: itemDamage, size: itemDamageSize } = (ctx.varint)(buffer, offset)
      let { value: scale, size: scaleSize } = (ctx.i8)(buffer, offset + itemDamageSize)
      let { value: locked, size: lockedSize } = (ctx.bool)(buffer, offset + itemDamageSize + scaleSize)
      let { value: icons, size: iconsSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = ((buffer, offset) => {
            let { value: type1, size: type1Size } = (ctx.varint)(buffer, offset)
            let { value: x1, size: x1Size } = (ctx.i8)(buffer, offset + type1Size)
            let { value: z1, size: z1Size } = (ctx.i8)(buffer, offset + type1Size + x1Size)
            let { value: direction, size: directionSize } = (ctx.u8)(buffer, offset + type1Size + x1Size + z1Size)
            let { value: displayName, size: displayNameSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.string)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + type1Size + x1Size + z1Size + directionSize)
            return { value: { type: type1, x: x1, z: z1, direction, displayName }, size: type1Size + x1Size + z1Size + directionSize + displayNameSize}
          })(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize)
      let { value: columns, size: columnsSize } = (ctx.u8)(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize)
      let { value: rows, size: rowsSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize)
      let { value: x, size: xSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize)
      let { value: y, size: ySize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return (ctx.u8)(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize)
      let { value: data, size: dataSize } = ((buffer, offset) => {
        switch (columns) {
          case 0: return (ctx.void)(buffer, offset)
          default: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset)
        }
      })(buffer, offset + itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize + ySize)
      return { value: { itemDamage, scale, locked, icons, columns, rows, x, y, data }, size: itemDamageSize + scaleSize + lockedSize + iconsSize + columnsSize + rowsSize + xSize + ySize + dataSize}
    },
    packet_trade_list: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.varint)(buffer, offset)
      let { value: trades, size: tradesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: inputItem1, size: inputItem1Size } = (ctx.slot)(buffer, offset)
          let { value: outputItem, size: outputItemSize } = (ctx.slot)(buffer, offset + inputItem1Size)
          let { value: inputItem2, size: inputItem2Size } = (ctx.slot)(buffer, offset + inputItem1Size + outputItemSize)
          let { value: tradeDisabled, size: tradeDisabledSize } = (ctx.bool)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size)
          let { value: nbTradeUses, size: nbTradeUsesSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize)
          let { value: maximumNbTradeUses, size: maximumNbTradeUsesSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize)
          let { value: xp, size: xpSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize)
          let { value: specialPrice, size: specialPriceSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize)
          let { value: priceMultiplier, size: priceMultiplierSize } = (ctx.f32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize)
          let { value: demand, size: demandSize } = (ctx.i32)(buffer, offset + inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize + priceMultiplierSize)
          return { value: { inputItem1, outputItem, inputItem2, tradeDisabled, nbTradeUses, maximumNbTradeUses, xp, specialPrice, priceMultiplier, demand }, size: inputItem1Size + outputItemSize + inputItem2Size + tradeDisabledSize + nbTradeUsesSize + maximumNbTradeUsesSize + xpSize + specialPriceSize + priceMultiplierSize + demandSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + windowIdSize)
      let { value: villagerLevel, size: villagerLevelSize } = (ctx.varint)(buffer, offset + windowIdSize + tradesSize)
      let { value: experience, size: experienceSize } = (ctx.varint)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize)
      let { value: isRegularVillager, size: isRegularVillagerSize } = (ctx.bool)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize + experienceSize)
      let { value: canRestock, size: canRestockSize } = (ctx.bool)(buffer, offset + windowIdSize + tradesSize + villagerLevelSize + experienceSize + isRegularVillagerSize)
      return { value: { windowId, trades, villagerLevel, experience, isRegularVillager, canRestock }, size: windowIdSize + tradesSize + villagerLevelSize + experienceSize + isRegularVillagerSize + canRestockSize}
    },
    packet_rel_entity_move: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: dX, size: dXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: dY, size: dYSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize)
      let { value: dZ, size: dZSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize + dYSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize)
      return { value: { entityId, dX, dY, dZ, onGround }, size: entityIdSize + dXSize + dYSize + dZSize + onGroundSize}
    },
    packet_entity_move_look: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: dX, size: dXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: dY, size: dYSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize)
      let { value: dZ, size: dZSize } = (ctx.i16)(buffer, offset + entityIdSize + dXSize + dYSize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + dXSize + dYSize + dZSize + yawSize + pitchSize)
      return { value: { entityId, dX, dY, dZ, yaw, pitch, onGround }, size: entityIdSize + dXSize + dYSize + dZSize + yawSize + pitchSize + onGroundSize}
    },
    packet_entity_look: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + yawSize + pitchSize)
      return { value: { entityId, yaw, pitch, onGround }, size: entityIdSize + yawSize + pitchSize + onGroundSize}
    },
    packet_vehicle_move: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      return { value: { x, y, z, yaw, pitch }, size: xSize + ySize + zSize + yawSize + pitchSize}
    },
    packet_open_book: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      return { value: { hand }, size: handSize}
    },
    packet_open_sign_entity: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      return { value: { location }, size: locationSize}
    },
    packet_craft_recipe_response: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: recipe, size: recipeSize } = (ctx.string)(buffer, offset + windowIdSize)
      return { value: { windowId, recipe }, size: windowIdSize + recipeSize}
    },
    packet_abilities: (buffer, offset) => {
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset)
      let { value: flyingSpeed, size: flyingSpeedSize } = (ctx.f32)(buffer, offset + flagsSize)
      let { value: walkingSpeed, size: walkingSpeedSize } = (ctx.f32)(buffer, offset + flagsSize + flyingSpeedSize)
      return { value: { flags, flyingSpeed, walkingSpeed }, size: flagsSize + flyingSpeedSize + walkingSpeedSize}
    },
    packet_player_chat: (buffer, offset) => {
      let { value: senderUuid, size: senderUuidSize } = (ctx.UUID)(buffer, offset)
      let { value: index, size: indexSize } = (ctx.varint)(buffer, offset + senderUuidSize)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const count = 256
          const countSize = 0
          offset += countSize
          if (offset + count > buffer.length) {
            throw new PartialReadError()
          }
          return { value: buffer.slice(offset, offset + count), size: count + countSize }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize)
      let { value: plainMessage, size: plainMessageSize } = (ctx.string)(buffer, offset + senderUuidSize + indexSize + signatureSize)
      let { value: timestamp, size: timestampSize } = (ctx.i64)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize)
      let { value: salt, size: saltSize } = (ctx.i64)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize)
      let { value: previousMessages, size: previousMessagesSize } = (ctx.previousMessages)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize)
      let { value: unsignedChatContent, size: unsignedChatContentSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize)
      let { value: filterType, size: filterTypeSize } = (ctx.varint)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize)
      let { value: filterTypeMask, size: filterTypeMaskSize } = ((buffer, offset) => {
        switch (filterType) {
          case 2: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.i64)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize)
      let { value: networkName, size: networkNameSize } = (ctx.string)(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize)
      let { value: networkTargetName, size: networkTargetNameSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize + networkNameSize)
      return { value: { senderUuid, index, signature, plainMessage, timestamp, salt, previousMessages, unsignedChatContent, filterType, filterTypeMask, type, networkName, networkTargetName }, size: senderUuidSize + indexSize + signatureSize + plainMessageSize + timestampSize + saltSize + previousMessagesSize + unsignedChatContentSize + filterTypeSize + filterTypeMaskSize + typeSize + networkNameSize + networkTargetNameSize}
    },
    packet_end_combat_event: (buffer, offset) => {
      let { value: duration, size: durationSize } = (ctx.varint)(buffer, offset)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + durationSize)
      return { value: { duration, entityId }, size: durationSize + entityIdSize}
    },
    packet_enter_combat_event: (buffer, offset) => {
      return { value: {  }, size: 0}
    },
    packet_death_combat_event: (buffer, offset) => {
      let { value: playerId, size: playerIdSize } = (ctx.varint)(buffer, offset)
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset + playerIdSize)
      let { value: message, size: messageSize } = (ctx.string)(buffer, offset + playerIdSize + entityIdSize)
      return { value: { playerId, entityId, message }, size: playerIdSize + entityIdSize + messageSize}
    },
    packet_player_remove: (buffer, offset) => {
      let { value: players, size: playersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.UUID)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { players }, size: playersSize}
    },
    packet_player_info: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.i8)(buffer, offset)
      let { value: data, size: dataSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
          let { value: player, size: playerSize } = ((buffer, offset) => {
            switch (action) {
              case 1: return (ctx.game_profile)(buffer, offset)
              case 3: return (ctx.game_profile)(buffer, offset)
              case 5: return (ctx.game_profile)(buffer, offset)
              case 7: return (ctx.game_profile)(buffer, offset)
              case 9: return (ctx.game_profile)(buffer, offset)
              case 11: return (ctx.game_profile)(buffer, offset)
              case 13: return (ctx.game_profile)(buffer, offset)
              case 15: return (ctx.game_profile)(buffer, offset)
              case 17: return (ctx.game_profile)(buffer, offset)
              case 19: return (ctx.game_profile)(buffer, offset)
              case 21: return (ctx.game_profile)(buffer, offset)
              case 23: return (ctx.game_profile)(buffer, offset)
              case 25: return (ctx.game_profile)(buffer, offset)
              case 27: return (ctx.game_profile)(buffer, offset)
              case 29: return (ctx.game_profile)(buffer, offset)
              case 31: return (ctx.game_profile)(buffer, offset)
              case 33: return (ctx.game_profile)(buffer, offset)
              case 35: return (ctx.game_profile)(buffer, offset)
              case 37: return (ctx.game_profile)(buffer, offset)
              case 39: return (ctx.game_profile)(buffer, offset)
              case 41: return (ctx.game_profile)(buffer, offset)
              case 43: return (ctx.game_profile)(buffer, offset)
              case 45: return (ctx.game_profile)(buffer, offset)
              case 47: return (ctx.game_profile)(buffer, offset)
              case 49: return (ctx.game_profile)(buffer, offset)
              case 51: return (ctx.game_profile)(buffer, offset)
              case 53: return (ctx.game_profile)(buffer, offset)
              case 55: return (ctx.game_profile)(buffer, offset)
              case 57: return (ctx.game_profile)(buffer, offset)
              case 59: return (ctx.game_profile)(buffer, offset)
              case 61: return (ctx.game_profile)(buffer, offset)
              case 63: return (ctx.game_profile)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize)
          let { value: chatSession, size: chatSessionSize } = ((buffer, offset) => {
            switch (action) {
              case 2: return (ctx.chat_session)(buffer, offset)
              case 3: return (ctx.chat_session)(buffer, offset)
              case 6: return (ctx.chat_session)(buffer, offset)
              case 7: return (ctx.chat_session)(buffer, offset)
              case 10: return (ctx.chat_session)(buffer, offset)
              case 11: return (ctx.chat_session)(buffer, offset)
              case 14: return (ctx.chat_session)(buffer, offset)
              case 15: return (ctx.chat_session)(buffer, offset)
              case 18: return (ctx.chat_session)(buffer, offset)
              case 19: return (ctx.chat_session)(buffer, offset)
              case 22: return (ctx.chat_session)(buffer, offset)
              case 23: return (ctx.chat_session)(buffer, offset)
              case 26: return (ctx.chat_session)(buffer, offset)
              case 27: return (ctx.chat_session)(buffer, offset)
              case 30: return (ctx.chat_session)(buffer, offset)
              case 31: return (ctx.chat_session)(buffer, offset)
              case 34: return (ctx.chat_session)(buffer, offset)
              case 35: return (ctx.chat_session)(buffer, offset)
              case 38: return (ctx.chat_session)(buffer, offset)
              case 39: return (ctx.chat_session)(buffer, offset)
              case 42: return (ctx.chat_session)(buffer, offset)
              case 43: return (ctx.chat_session)(buffer, offset)
              case 46: return (ctx.chat_session)(buffer, offset)
              case 47: return (ctx.chat_session)(buffer, offset)
              case 50: return (ctx.chat_session)(buffer, offset)
              case 51: return (ctx.chat_session)(buffer, offset)
              case 54: return (ctx.chat_session)(buffer, offset)
              case 55: return (ctx.chat_session)(buffer, offset)
              case 58: return (ctx.chat_session)(buffer, offset)
              case 59: return (ctx.chat_session)(buffer, offset)
              case 62: return (ctx.chat_session)(buffer, offset)
              case 63: return (ctx.chat_session)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize)
          let { value: gamemode, size: gamemodeSize } = ((buffer, offset) => {
            switch (action) {
              case 4: return (ctx.varint)(buffer, offset)
              case 5: return (ctx.varint)(buffer, offset)
              case 6: return (ctx.varint)(buffer, offset)
              case 7: return (ctx.varint)(buffer, offset)
              case 12: return (ctx.varint)(buffer, offset)
              case 13: return (ctx.varint)(buffer, offset)
              case 14: return (ctx.varint)(buffer, offset)
              case 15: return (ctx.varint)(buffer, offset)
              case 20: return (ctx.varint)(buffer, offset)
              case 21: return (ctx.varint)(buffer, offset)
              case 22: return (ctx.varint)(buffer, offset)
              case 23: return (ctx.varint)(buffer, offset)
              case 28: return (ctx.varint)(buffer, offset)
              case 29: return (ctx.varint)(buffer, offset)
              case 30: return (ctx.varint)(buffer, offset)
              case 31: return (ctx.varint)(buffer, offset)
              case 36: return (ctx.varint)(buffer, offset)
              case 37: return (ctx.varint)(buffer, offset)
              case 38: return (ctx.varint)(buffer, offset)
              case 39: return (ctx.varint)(buffer, offset)
              case 44: return (ctx.varint)(buffer, offset)
              case 45: return (ctx.varint)(buffer, offset)
              case 46: return (ctx.varint)(buffer, offset)
              case 47: return (ctx.varint)(buffer, offset)
              case 52: return (ctx.varint)(buffer, offset)
              case 53: return (ctx.varint)(buffer, offset)
              case 54: return (ctx.varint)(buffer, offset)
              case 55: return (ctx.varint)(buffer, offset)
              case 60: return (ctx.varint)(buffer, offset)
              case 61: return (ctx.varint)(buffer, offset)
              case 62: return (ctx.varint)(buffer, offset)
              case 63: return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize)
          let { value: listed, size: listedSize } = ((buffer, offset) => {
            switch (action) {
              case 8: return (ctx.bool)(buffer, offset)
              case 9: return (ctx.bool)(buffer, offset)
              case 10: return (ctx.bool)(buffer, offset)
              case 11: return (ctx.bool)(buffer, offset)
              case 12: return (ctx.bool)(buffer, offset)
              case 13: return (ctx.bool)(buffer, offset)
              case 14: return (ctx.bool)(buffer, offset)
              case 15: return (ctx.bool)(buffer, offset)
              case 24: return (ctx.bool)(buffer, offset)
              case 25: return (ctx.bool)(buffer, offset)
              case 26: return (ctx.bool)(buffer, offset)
              case 27: return (ctx.bool)(buffer, offset)
              case 28: return (ctx.bool)(buffer, offset)
              case 29: return (ctx.bool)(buffer, offset)
              case 30: return (ctx.bool)(buffer, offset)
              case 31: return (ctx.bool)(buffer, offset)
              case 40: return (ctx.bool)(buffer, offset)
              case 41: return (ctx.bool)(buffer, offset)
              case 42: return (ctx.bool)(buffer, offset)
              case 43: return (ctx.bool)(buffer, offset)
              case 44: return (ctx.bool)(buffer, offset)
              case 45: return (ctx.bool)(buffer, offset)
              case 46: return (ctx.bool)(buffer, offset)
              case 47: return (ctx.bool)(buffer, offset)
              case 56: return (ctx.bool)(buffer, offset)
              case 57: return (ctx.bool)(buffer, offset)
              case 58: return (ctx.bool)(buffer, offset)
              case 59: return (ctx.bool)(buffer, offset)
              case 60: return (ctx.bool)(buffer, offset)
              case 61: return (ctx.bool)(buffer, offset)
              case 62: return (ctx.bool)(buffer, offset)
              case 63: return (ctx.bool)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize)
          let { value: latency, size: latencySize } = ((buffer, offset) => {
            switch (action) {
              case 16: return (ctx.varint)(buffer, offset)
              case 17: return (ctx.varint)(buffer, offset)
              case 18: return (ctx.varint)(buffer, offset)
              case 19: return (ctx.varint)(buffer, offset)
              case 20: return (ctx.varint)(buffer, offset)
              case 21: return (ctx.varint)(buffer, offset)
              case 22: return (ctx.varint)(buffer, offset)
              case 23: return (ctx.varint)(buffer, offset)
              case 24: return (ctx.varint)(buffer, offset)
              case 25: return (ctx.varint)(buffer, offset)
              case 26: return (ctx.varint)(buffer, offset)
              case 27: return (ctx.varint)(buffer, offset)
              case 28: return (ctx.varint)(buffer, offset)
              case 29: return (ctx.varint)(buffer, offset)
              case 30: return (ctx.varint)(buffer, offset)
              case 31: return (ctx.varint)(buffer, offset)
              case 48: return (ctx.varint)(buffer, offset)
              case 49: return (ctx.varint)(buffer, offset)
              case 50: return (ctx.varint)(buffer, offset)
              case 51: return (ctx.varint)(buffer, offset)
              case 52: return (ctx.varint)(buffer, offset)
              case 53: return (ctx.varint)(buffer, offset)
              case 54: return (ctx.varint)(buffer, offset)
              case 55: return (ctx.varint)(buffer, offset)
              case 56: return (ctx.varint)(buffer, offset)
              case 57: return (ctx.varint)(buffer, offset)
              case 58: return (ctx.varint)(buffer, offset)
              case 59: return (ctx.varint)(buffer, offset)
              case 60: return (ctx.varint)(buffer, offset)
              case 61: return (ctx.varint)(buffer, offset)
              case 62: return (ctx.varint)(buffer, offset)
              case 63: return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize)
          let { value: displayName, size: displayNameSize } = ((buffer, offset) => {
            switch (action) {
              case 32: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 33: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 34: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 35: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 36: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 37: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 38: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 39: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 40: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 41: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 42: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 43: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 44: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 45: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 46: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 47: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 48: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 49: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 50: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 51: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 52: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 53: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 54: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 55: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 56: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 57: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 58: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 59: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 60: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 61: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 62: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              case 63: return ((buffer, offset) => {
                const {value} = ctx.bool(buffer, offset)
                if (value) {
                  const { value, size } = (ctx.string)(buffer, offset + 1)
                  return { value, size: size + 1 }
                }
                return { value: undefined, size: 1}
              })(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize + latencySize)
          return { value: { uuid, player, chatSession, gamemode, listed, latency, displayName }, size: uuidSize + playerSize + chatSessionSize + gamemodeSize + listedSize + latencySize + displayNameSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize)
      return { value: { action, data }, size: actionSize + dataSize}
    },
    packet_position: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset + xSize + ySize + zSize + yawSize + pitchSize)
      let { value: teleportId, size: teleportIdSize } = (ctx.varint)(buffer, offset + xSize + ySize + zSize + yawSize + pitchSize + flagsSize)
      return { value: { x, y, z, yaw, pitch, flags, teleportId }, size: xSize + ySize + zSize + yawSize + pitchSize + flagsSize + teleportIdSize}
    },
    packet_unlock_recipes: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset)
      let { value: craftingBookOpen, size: craftingBookOpenSize } = (ctx.bool)(buffer, offset + actionSize)
      let { value: filteringCraftable, size: filteringCraftableSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize)
      let { value: smeltingBookOpen, size: smeltingBookOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize)
      let { value: filteringSmeltable, size: filteringSmeltableSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize)
      let { value: blastFurnaceOpen, size: blastFurnaceOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize)
      let { value: filteringBlastFurnace, size: filteringBlastFurnaceSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize)
      let { value: smokerBookOpen, size: smokerBookOpenSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize)
      let { value: filteringSmoker, size: filteringSmokerSize } = (ctx.bool)(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize)
      let { value: recipes1, size: recipes1Size } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize)
      let { value: recipes2, size: recipes2Size } = ((buffer, offset) => {
        switch (action) {
          case 0: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize + recipes1Size)
      return { value: { action, craftingBookOpen, filteringCraftable, smeltingBookOpen, filteringSmeltable, blastFurnaceOpen, filteringBlastFurnace, smokerBookOpen, filteringSmoker, recipes1, recipes2 }, size: actionSize + craftingBookOpenSize + filteringCraftableSize + smeltingBookOpenSize + filteringSmeltableSize + blastFurnaceOpenSize + filteringBlastFurnaceSize + smokerBookOpenSize + filteringSmokerSize + recipes1Size + recipes2Size}
    },
    packet_entity_destroy: (buffer, offset) => {
      let { value: entityIds, size: entityIdsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { entityIds }, size: entityIdsSize}
    },
    packet_remove_entity_effect: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: effectId, size: effectIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      return { value: { entityId, effectId }, size: entityIdSize + effectIdSize}
    },
    packet_resource_pack_send: (buffer, offset) => {
      let { value: url, size: urlSize } = (ctx.string)(buffer, offset)
      let { value: hash, size: hashSize } = (ctx.string)(buffer, offset + urlSize)
      let { value: forced, size: forcedSize } = (ctx.bool)(buffer, offset + urlSize + hashSize)
      let { value: promptMessage, size: promptMessageSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + urlSize + hashSize + forcedSize)
      return { value: { url, hash, forced, promptMessage }, size: urlSize + hashSize + forcedSize + promptMessageSize}
    },
    packet_respawn: (buffer, offset) => {
      let { value: dimension, size: dimensionSize } = (ctx.string)(buffer, offset)
      let { value: worldName, size: worldNameSize } = (ctx.string)(buffer, offset + dimensionSize)
      let { value: hashedSeed, size: hashedSeedSize } = (ctx.i64)(buffer, offset + dimensionSize + worldNameSize)
      let { value: gamemode, size: gamemodeSize } = (ctx.i8)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize)
      let { value: previousGamemode, size: previousGamemodeSize } = (ctx.u8)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize)
      let { value: isDebug, size: isDebugSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize)
      let { value: isFlat, size: isFlatSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize)
      let { value: copyMetadata, size: copyMetadataSize } = (ctx.bool)(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize)
      let { value: death, size: deathSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          let { value: dimensionName, size: dimensionNameSize } = (ctx.string)(buffer, offset)
          let { value: location1, size: location1Size } = (ctx.position)(buffer, offset + dimensionNameSize)
          return { value: { dimensionName, location: location1 }, size: dimensionNameSize + location1Size}
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize + copyMetadataSize)
      return { value: { dimension, worldName, hashedSeed, gamemode, previousGamemode, isDebug, isFlat, copyMetadata, death }, size: dimensionSize + worldNameSize + hashedSeedSize + gamemodeSize + previousGamemodeSize + isDebugSize + isFlatSize + copyMetadataSize + deathSize}
    },
    packet_entity_head_rotation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: headYaw, size: headYawSize } = (ctx.i8)(buffer, offset + entityIdSize)
      return { value: { entityId, headYaw }, size: entityIdSize + headYawSize}
    },
    packet_camera: (buffer, offset) => {
      let { value: cameraId, size: cameraIdSize } = (ctx.varint)(buffer, offset)
      return { value: { cameraId }, size: cameraIdSize}
    },
    packet_held_item_slot: (buffer, offset) => {
      let { value: slot, size: slotSize } = (ctx.i8)(buffer, offset)
      return { value: { slot }, size: slotSize}
    },
    packet_update_view_position: (buffer, offset) => {
      let { value: chunkX, size: chunkXSize } = (ctx.varint)(buffer, offset)
      let { value: chunkZ, size: chunkZSize } = (ctx.varint)(buffer, offset + chunkXSize)
      return { value: { chunkX, chunkZ }, size: chunkXSize + chunkZSize}
    },
    packet_update_view_distance: (buffer, offset) => {
      let { value: viewDistance, size: viewDistanceSize } = (ctx.varint)(buffer, offset)
      return { value: { viewDistance }, size: viewDistanceSize}
    },
    packet_scoreboard_display_objective: (buffer, offset) => {
      let { value: position, size: positionSize } = (ctx.i8)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + positionSize)
      return { value: { position, name }, size: positionSize + nameSize}
    },
    packet_entity_metadata: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: metadata, size: metadataSize } = (ctx.entityMetadata)(buffer, offset + entityIdSize)
      return { value: { entityId, metadata }, size: entityIdSize + metadataSize}
    },
    packet_attach_entity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.i32)(buffer, offset)
      let { value: vehicleId, size: vehicleIdSize } = (ctx.i32)(buffer, offset + entityIdSize)
      return { value: { entityId, vehicleId }, size: entityIdSize + vehicleIdSize}
    },
    packet_entity_velocity: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: velocityX, size: velocityXSize } = (ctx.i16)(buffer, offset + entityIdSize)
      let { value: velocityY, size: velocityYSize } = (ctx.i16)(buffer, offset + entityIdSize + velocityXSize)
      let { value: velocityZ, size: velocityZSize } = (ctx.i16)(buffer, offset + entityIdSize + velocityXSize + velocityYSize)
      return { value: { entityId, velocityX, velocityY, velocityZ }, size: entityIdSize + velocityXSize + velocityYSize + velocityZSize}
    },
    packet_entity_equipment: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: equipments, size: equipmentsSize } = ((buffer, offset) => {
        let cursor = offset
        const data = []
        while (true) {
          const item = ctx.u8(buffer, cursor).value
          buffer[cursor] = buffer[cursor] & 127
          const elem = ((buffer, offset) => {
          let { value: slot1, size: slot1Size } = (ctx.i8)(buffer, offset)
          let { value: item1, size: item1Size } = (ctx.slot)(buffer, offset + slot1Size)
          return { value: { slot: slot1, item: item1 }, size: slot1Size + item1Size}
        })(buffer, cursor)
          data.push(elem.value)
          cursor += elem.size
          if ((item & 128) === 0) return { value: data, size: cursor - offset }
        }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, equipments }, size: entityIdSize + equipmentsSize}
    },
    packet_experience: (buffer, offset) => {
      let { value: experienceBar, size: experienceBarSize } = (ctx.f32)(buffer, offset)
      let { value: totalExperience, size: totalExperienceSize } = (ctx.varint)(buffer, offset + experienceBarSize)
      let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + experienceBarSize + totalExperienceSize)
      return { value: { experienceBar, totalExperience, level }, size: experienceBarSize + totalExperienceSize + levelSize}
    },
    packet_update_health: (buffer, offset) => {
      let { value: health, size: healthSize } = (ctx.f32)(buffer, offset)
      let { value: food, size: foodSize } = (ctx.varint)(buffer, offset + healthSize)
      let { value: foodSaturation, size: foodSaturationSize } = (ctx.f32)(buffer, offset + healthSize + foodSize)
      return { value: { health, food, foodSaturation }, size: healthSize + foodSize + foodSaturationSize}
    },
    packet_scoreboard_objective: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.i8)(buffer, offset + nameSize)
      let { value: displayText, size: displayTextSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize + actionSize)
      let { value: type, size: typeSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.varint)(buffer, offset)
          case 2: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize + actionSize + displayTextSize)
      return { value: { name, action, displayText, type }, size: nameSize + actionSize + displayTextSize + typeSize}
    },
    packet_set_passengers: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: passengers, size: passengersSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, passengers }, size: entityIdSize + passengersSize}
    },
    packet_teams: (buffer, offset) => {
      let { value: team, size: teamSize } = (ctx.string)(buffer, offset)
      let { value: mode, size: modeSize } = (ctx.i8)(buffer, offset + teamSize)
      let { value: name, size: nameSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize)
      let { value: friendlyFire, size: friendlyFireSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.i8)(buffer, offset)
          case 2: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize)
      let { value: nameTagVisibility, size: nameTagVisibilitySize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize)
      let { value: collisionRule, size: collisionRuleSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize)
      let { value: formatting, size: formattingSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.varint)(buffer, offset)
          case 2: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize)
      let { value: prefix, size: prefixSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize)
      let { value: suffix, size: suffixSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return (ctx.string)(buffer, offset)
          case 2: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize)
      let { value: players, size: playersSize } = ((buffer, offset) => {
        switch (mode) {
          case 0: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          case 3: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          case 4: return ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = (ctx.string)(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize + suffixSize)
      return { value: { team, mode, name, friendlyFire, nameTagVisibility, collisionRule, formatting, prefix, suffix, players }, size: teamSize + modeSize + nameSize + friendlyFireSize + nameTagVisibilitySize + collisionRuleSize + formattingSize + prefixSize + suffixSize + playersSize}
    },
    packet_scoreboard_score: (buffer, offset) => {
      let { value: itemName, size: itemNameSize } = (ctx.string)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + itemNameSize)
      let { value: scoreName, size: scoreNameSize } = (ctx.string)(buffer, offset + itemNameSize + actionSize)
      let { value: value1, size: value1Size } = ((buffer, offset) => {
        switch (action) {
          case 1: return (ctx.void)(buffer, offset)
          default: return (ctx.varint)(buffer, offset)
        }
      })(buffer, offset + itemNameSize + actionSize + scoreNameSize)
      return { value: { itemName, action, scoreName, value: value1 }, size: itemNameSize + actionSize + scoreNameSize + value1Size}
    },
    packet_spawn_position: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: angle, size: angleSize } = (ctx.f32)(buffer, offset + locationSize)
      return { value: { location, angle }, size: locationSize + angleSize}
    },
    packet_update_time: (buffer, offset) => {
      let { value: age, size: ageSize } = (ctx.i64)(buffer, offset)
      let { value: time, size: timeSize } = (ctx.i64)(buffer, offset + ageSize)
      return { value: { age, time }, size: ageSize + timeSize}
    },
    packet_entity_sound_effect: (buffer, offset) => {
      let { value: soundId, size: soundIdSize } = (ctx.varint)(buffer, offset)
      let { value: soundEvent, size: soundEventSize } = ((buffer, offset) => {
        switch (soundId) {
          case 0: return ((buffer, offset) => {
            let { value: resource, size: resourceSize } = (ctx.string)(buffer, offset)
            let { value: range, size: rangeSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.f32)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + resourceSize)
            return { value: { resource, range }, size: resourceSize + rangeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + soundIdSize)
      let { value: soundCategory, size: soundCategorySize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize)
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize)
      let { value: volume, size: volumeSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize)
      let { value: seed, size: seedSize } = (ctx.i64)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize + pitchSize)
      return { value: { soundId, soundEvent, soundCategory, entityId, volume, pitch, seed }, size: soundIdSize + soundEventSize + soundCategorySize + entityIdSize + volumeSize + pitchSize + seedSize}
    },
    packet_stop_sound: (buffer, offset) => {
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset)
      let { value: source, size: sourceSize } = ((buffer, offset) => {
        switch (flags) {
          case 1: return (ctx.varint)(buffer, offset)
          case 3: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize)
      let { value: sound, size: soundSize } = ((buffer, offset) => {
        switch (flags) {
          case 2: return (ctx.string)(buffer, offset)
          case 3: return (ctx.string)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + sourceSize)
      return { value: { flags, source, sound }, size: flagsSize + sourceSize + soundSize}
    },
    packet_sound_effect: (buffer, offset) => {
      let { value: soundId, size: soundIdSize } = (ctx.varint)(buffer, offset)
      let { value: soundEvent, size: soundEventSize } = ((buffer, offset) => {
        switch (soundId) {
          case 0: return ((buffer, offset) => {
            let { value: resource, size: resourceSize } = (ctx.string)(buffer, offset)
            let { value: range, size: rangeSize } = ((buffer, offset) => {
              const {value} = ctx.bool(buffer, offset)
              if (value) {
                const { value, size } = (ctx.f32)(buffer, offset + 1)
                return { value, size: size + 1 }
              }
              return { value: undefined, size: 1}
            })(buffer, offset + resourceSize)
            return { value: { resource, range }, size: resourceSize + rangeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + soundIdSize)
      let { value: soundCategory, size: soundCategorySize } = (ctx.varint)(buffer, offset + soundIdSize + soundEventSize)
      let { value: x, size: xSize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize)
      let { value: y, size: ySize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize)
      let { value: z, size: zSize } = (ctx.i32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize)
      let { value: volume, size: volumeSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize)
      let { value: seed, size: seedSize } = (ctx.i64)(buffer, offset + soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize + pitchSize)
      return { value: { soundId, soundEvent, soundCategory, x, y, z, volume, pitch, seed }, size: soundIdSize + soundEventSize + soundCategorySize + xSize + ySize + zSize + volumeSize + pitchSize + seedSize}
    },
    packet_system_chat: (buffer, offset) => {
      let { value: content, size: contentSize } = (ctx.string)(buffer, offset)
      let { value: isActionBar, size: isActionBarSize } = (ctx.bool)(buffer, offset + contentSize)
      return { value: { content, isActionBar }, size: contentSize + isActionBarSize}
    },
    packet_playerlist_header: (buffer, offset) => {
      let { value: header, size: headerSize } = (ctx.string)(buffer, offset)
      let { value: footer, size: footerSize } = (ctx.string)(buffer, offset + headerSize)
      return { value: { header, footer }, size: headerSize + footerSize}
    },
    packet_collect: (buffer, offset) => {
      let { value: collectedEntityId, size: collectedEntityIdSize } = (ctx.varint)(buffer, offset)
      let { value: collectorEntityId, size: collectorEntityIdSize } = (ctx.varint)(buffer, offset + collectedEntityIdSize)
      let { value: pickupItemCount, size: pickupItemCountSize } = (ctx.varint)(buffer, offset + collectedEntityIdSize + collectorEntityIdSize)
      return { value: { collectedEntityId, collectorEntityId, pickupItemCount }, size: collectedEntityIdSize + collectorEntityIdSize + pickupItemCountSize}
    },
    packet_entity_teleport: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset + entityIdSize)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + entityIdSize + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + entityIdSize + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.i8)(buffer, offset + entityIdSize + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.i8)(buffer, offset + entityIdSize + xSize + ySize + zSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + entityIdSize + xSize + ySize + zSize + yawSize + pitchSize)
      return { value: { entityId, x, y, z, yaw, pitch, onGround }, size: entityIdSize + xSize + ySize + zSize + yawSize + pitchSize + onGroundSize}
    },
    packet_entity_update_attributes: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value2, size: value2Size } = (ctx.f64)(buffer, offset + keySize)
          let { value: modifiers, size: modifiersSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
            const data = []
            let size = countSize
            for (let i = 0; i < count; i++) {
              const elem = ((buffer, offset) => {
              let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
              let { value: amount, size: amountSize } = (ctx.f64)(buffer, offset + uuidSize)
              let { value: operation, size: operationSize } = (ctx.i8)(buffer, offset + uuidSize + amountSize)
              return { value: { uuid, amount, operation }, size: uuidSize + amountSize + operationSize}
            })(buffer, offset + size)
              data.push(elem.value)
              size += elem.size
            }
            return { value: data, size }
          })(buffer, offset + keySize + value2Size)
          return { value: { key, value: value2, modifiers }, size: keySize + value2Size + modifiersSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + entityIdSize)
      return { value: { entityId, properties }, size: entityIdSize + propertiesSize}
    },
    packet_feature_flags: (buffer, offset) => {
      let { value: features, size: featuresSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { features }, size: featuresSize}
    },
    packet_entity_effect: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: effectId, size: effectIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      let { value: amplifier, size: amplifierSize } = (ctx.i8)(buffer, offset + entityIdSize + effectIdSize)
      let { value: duration, size: durationSize } = (ctx.varint)(buffer, offset + entityIdSize + effectIdSize + amplifierSize)
      let { value: hideParticles, size: hideParticlesSize } = (ctx.i8)(buffer, offset + entityIdSize + effectIdSize + amplifierSize + durationSize)
      let { value: factorCodec, size: factorCodecSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.nbt)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + effectIdSize + amplifierSize + durationSize + hideParticlesSize)
      return { value: { entityId, effectId, amplifier, duration, hideParticles, factorCodec }, size: entityIdSize + effectIdSize + amplifierSize + durationSize + hideParticlesSize + factorCodecSize}
    },
    packet_select_advancement_tab: (buffer, offset) => {
      let { value: id, size: idSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset)
      return { value: { id }, size: idSize}
    },
    packet_server_data: (buffer, offset) => {
      let { value: motd, size: motdSize } = (ctx.string)(buffer, offset)
      let { value: iconBytes, size: iconBytesSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          offset += countSize
          if (offset + count > buffer.length) {
            throw new PartialReadError()
          }
          return { value: buffer.slice(offset, offset + count), size: count + countSize }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + motdSize)
      let { value: enforcesSecureChat, size: enforcesSecureChatSize } = (ctx.bool)(buffer, offset + motdSize + iconBytesSize)
      return { value: { motd, iconBytes, enforcesSecureChat }, size: motdSize + iconBytesSize + enforcesSecureChatSize}
    },
    packet_declare_recipes: (buffer, offset) => {
      let { value: recipes, size: recipesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: type1, size: type1Size } = (ctx.string)(buffer, offset)
          let { value: recipeId, size: recipeIdSize } = (ctx.string)(buffer, offset + type1Size)
          let { value: data1, size: data1Size } = ((buffer, offset) => {
            switch (type1) {
              case "minecraft:crafting_shapeless": return ((buffer, offset) => {
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset)
                let { value: category1, size: category1Size } = (ctx.varint)(buffer, offset + group1Size)
                let { value: ingredients, size: ingredientsSize } = ((buffer, offset) => {
                  const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
                  if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                  const data = []
                  let size = countSize
                  for (let i = 0; i < count; i++) {
                    const elem = (ctx.ingredient)(buffer, offset + size)
                    data.push(elem.value)
                    size += elem.size
                  }
                  return { value: data, size }
                })(buffer, offset + group1Size + category1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + group1Size + category1Size + ingredientsSize)
                return { value: { group: group1, category: category1, ingredients, result: result1 }, size: group1Size + category1Size + ingredientsSize + result1Size}
              })(buffer, offset)
              case "minecraft:crafting_shaped": return ((buffer, offset) => {
                let { value: width, size: widthSize } = (ctx.varint)(buffer, offset)
                let { value: height, size: heightSize } = (ctx.varint)(buffer, offset + widthSize)
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset + widthSize + heightSize)
                let { value: category1, size: category1Size } = (ctx.varint)(buffer, offset + widthSize + heightSize + group1Size)
                let { value: ingredients, size: ingredientsSize } = ((buffer, offset) => {
                  const count = width
                  const countSize = 0
                  if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                  const data = []
                  let size = countSize
                  for (let i = 0; i < count; i++) {
                    const elem = ((buffer, offset) => {
                    const count = height
                    const countSize = 0
                    if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
                    const data = []
                    let size = countSize
                    for (let i = 0; i < count; i++) {
                      const elem = (ctx.ingredient)(buffer, offset + size)
                      data.push(elem.value)
                      size += elem.size
                    }
                    return { value: data, size }
                  })(buffer, offset + size)
                    data.push(elem.value)
                    size += elem.size
                  }
                  return { value: data, size }
                })(buffer, offset + widthSize + heightSize + group1Size + category1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + widthSize + heightSize + group1Size + category1Size + ingredientsSize)
                let { value: showNotification, size: showNotificationSize } = (ctx.bool)(buffer, offset + widthSize + heightSize + group1Size + category1Size + ingredientsSize + result1Size)
                return { value: { width, height, group: group1, category: category1, ingredients, result: result1, showNotification }, size: widthSize + heightSize + group1Size + category1Size + ingredientsSize + result1Size + showNotificationSize}
              })(buffer, offset)
              case "minecraft:crafting_special_armordye": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_bookcloning": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_mapcloning": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_mapextending": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_rocket": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_star": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_firework_star_fade": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_repairitem": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_tippedarrow": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_bannerduplicate": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_banneraddpattern": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_shielddecoration": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_shulkerboxcoloring": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:crafting_special_suspiciousstew": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              case "minecraft:smelting": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:blasting": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:smoking": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:campfire_cooking": return (ctx.minecraft_smelting_format)(buffer, offset)
              case "minecraft:stonecutting": return ((buffer, offset) => {
                let { value: group1, size: group1Size } = (ctx.string)(buffer, offset)
                let { value: ingredient1, size: ingredient1Size } = (ctx.ingredient)(buffer, offset + group1Size)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + group1Size + ingredient1Size)
                return { value: { group: group1, ingredient: ingredient1, result: result1 }, size: group1Size + ingredient1Size + result1Size}
              })(buffer, offset)
              case "minecraft:smithing": return ((buffer, offset) => {
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + baseSize + additionSize)
                return { value: { base, addition, result: result1 }, size: baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:smithing_transform": return ((buffer, offset) => {
                let { value: template, size: templateSize } = (ctx.ingredient)(buffer, offset)
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset + templateSize)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + templateSize + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + templateSize + baseSize + additionSize)
                return { value: { template, base, addition, result: result1 }, size: templateSize + baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:smithing_trim": return ((buffer, offset) => {
                let { value: base, size: baseSize } = (ctx.ingredient)(buffer, offset)
                let { value: addition, size: additionSize } = (ctx.ingredient)(buffer, offset + baseSize)
                let { value: result1, size: result1Size } = (ctx.slot)(buffer, offset + baseSize + additionSize)
                return { value: { base, addition, result: result1 }, size: baseSize + additionSize + result1Size}
              })(buffer, offset)
              case "minecraft:crafting_decorated_pot": return (ctx.minecraft_simple_recipe_format)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + type1Size + recipeIdSize)
          return { value: { type: type1, recipeId, data: data1 }, size: type1Size + recipeIdSize + data1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { recipes }, size: recipesSize}
    },
    packet_tags: (buffer, offset) => {
      let { value: tags, size: tagsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: tagType, size: tagTypeSize } = (ctx.string)(buffer, offset)
          let { value: tags1, size: tags1Size } = (ctx.tags)(buffer, offset + tagTypeSize)
          return { value: { tagType, tags: tags1 }, size: tagTypeSize + tags1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { tags }, size: tagsSize}
    },
    packet_acknowledge_player_digging: (buffer, offset) => {
      let { value: sequenceId, size: sequenceIdSize } = (ctx.varint)(buffer, offset)
      return { value: { sequenceId }, size: sequenceIdSize}
    },
    packet_clear_titles: (buffer, offset) => {
      let { value: reset, size: resetSize } = (ctx.bool)(buffer, offset)
      return { value: { reset }, size: resetSize}
    },
    packet_initialize_world_border: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize)
      let { value: oldDiameter, size: oldDiameterSize } = (ctx.f64)(buffer, offset + xSize + zSize)
      let { value: newDiameter, size: newDiameterSize } = (ctx.f64)(buffer, offset + xSize + zSize + oldDiameterSize)
      let { value: speed, size: speedSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize)
      let { value: portalTeleportBoundary, size: portalTeleportBoundarySize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize)
      let { value: warningBlocks, size: warningBlocksSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize)
      let { value: warningTime, size: warningTimeSize } = (ctx.varint)(buffer, offset + xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize + warningBlocksSize)
      return { value: { x, z, oldDiameter, newDiameter, speed, portalTeleportBoundary, warningBlocks, warningTime }, size: xSize + zSize + oldDiameterSize + newDiameterSize + speedSize + portalTeleportBoundarySize + warningBlocksSize + warningTimeSize}
    },
    packet_action_bar: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_world_border_center: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize)
      return { value: { x, z }, size: xSize + zSize}
    },
    packet_world_border_lerp_size: (buffer, offset) => {
      let { value: oldDiameter, size: oldDiameterSize } = (ctx.f64)(buffer, offset)
      let { value: newDiameter, size: newDiameterSize } = (ctx.f64)(buffer, offset + oldDiameterSize)
      let { value: speed, size: speedSize } = (ctx.varint)(buffer, offset + oldDiameterSize + newDiameterSize)
      return { value: { oldDiameter, newDiameter, speed }, size: oldDiameterSize + newDiameterSize + speedSize}
    },
    packet_world_border_size: (buffer, offset) => {
      let { value: diameter, size: diameterSize } = (ctx.f64)(buffer, offset)
      return { value: { diameter }, size: diameterSize}
    },
    packet_world_border_warning_delay: (buffer, offset) => {
      let { value: warningTime, size: warningTimeSize } = (ctx.varint)(buffer, offset)
      return { value: { warningTime }, size: warningTimeSize}
    },
    packet_world_border_warning_reach: (buffer, offset) => {
      let { value: warningBlocks, size: warningBlocksSize } = (ctx.varint)(buffer, offset)
      return { value: { warningBlocks }, size: warningBlocksSize}
    },
    packet_ping: (buffer, offset) => {
      let { value: id, size: idSize } = (ctx.i32)(buffer, offset)
      return { value: { id }, size: idSize}
    },
    packet_set_title_subtitle: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_set_title_text: (buffer, offset) => {
      let { value: text, size: textSize } = (ctx.string)(buffer, offset)
      return { value: { text }, size: textSize}
    },
    packet_set_title_time: (buffer, offset) => {
      let { value: fadeIn, size: fadeInSize } = (ctx.i32)(buffer, offset)
      let { value: stay, size: staySize } = (ctx.i32)(buffer, offset + fadeInSize)
      let { value: fadeOut, size: fadeOutSize } = (ctx.i32)(buffer, offset + fadeInSize + staySize)
      return { value: { fadeIn, stay, fadeOut }, size: fadeInSize + staySize + fadeOutSize}
    },
    packet_simulation_distance: (buffer, offset) => {
      let { value: distance, size: distanceSize } = (ctx.varint)(buffer, offset)
      return { value: { distance }, size: distanceSize}
    },
    packet_chunk_biomes: (buffer, offset) => {
      let { value: biomes, size: biomesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: position1, size: position1Size } = (ctx.position)(buffer, offset)
          let { value: data1, size: data1Size } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + position1Size)
          return { value: { position: position1, data: data1 }, size: position1Size + data1Size}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset)
      return { value: { biomes }, size: biomesSize}
    },
    packet_damage_event: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: sourceTypeId, size: sourceTypeIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      let { value: sourceCauseId, size: sourceCauseIdSize } = (ctx.varint)(buffer, offset + entityIdSize + sourceTypeIdSize)
      let { value: sourceDirectId, size: sourceDirectIdSize } = (ctx.varint)(buffer, offset + entityIdSize + sourceTypeIdSize + sourceCauseIdSize)
      let { value: sourcePosition, size: sourcePositionSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.vec3f64)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + entityIdSize + sourceTypeIdSize + sourceCauseIdSize + sourceDirectIdSize)
      return { value: { entityId, sourceTypeId, sourceCauseId, sourceDirectId, sourcePosition }, size: entityIdSize + sourceTypeIdSize + sourceCauseIdSize + sourceDirectIdSize + sourcePositionSize}
    },
    packet_hurt_animation: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + entityIdSize)
      return { value: { entityId, yaw }, size: entityIdSize + yawSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"bundle_delimiter","1":"spawn_entity","2":"spawn_entity_experience_orb","3":"named_entity_spawn","4":"animation","5":"statistics","6":"acknowledge_player_digging","7":"block_break_animation","8":"tile_entity_data","9":"block_action","10":"block_change","11":"boss_bar","12":"difficulty","13":"chunk_biomes","14":"clear_titles","15":"tab_complete","16":"declare_commands","17":"close_window","18":"window_items","19":"craft_progress_bar","20":"set_slot","21":"set_cooldown","22":"chat_suggestions","23":"custom_payload","24":"damage_event","25":"hide_message","26":"kick_disconnect","27":"profileless_chat","28":"entity_status","29":"explosion","30":"unload_chunk","31":"game_state_change","32":"open_horse_window","33":"hurt_animation","34":"initialize_world_border","35":"keep_alive","36":"map_chunk","37":"world_event","38":"world_particles","39":"update_light","40":"login","41":"map","42":"trade_list","43":"rel_entity_move","44":"entity_move_look","45":"entity_look","46":"vehicle_move","47":"open_book","48":"open_window","49":"open_sign_entity","50":"ping","51":"craft_recipe_response","52":"abilities","53":"player_chat","54":"end_combat_event","55":"enter_combat_event","56":"death_combat_event","57":"player_remove","58":"player_info","59":"face_player","60":"position","61":"unlock_recipes","62":"entity_destroy","63":"remove_entity_effect","64":"resource_pack_send","65":"respawn","66":"entity_head_rotation","67":"multi_block_change","68":"select_advancement_tab","69":"server_data","70":"action_bar","71":"world_border_center","72":"world_border_lerp_size","73":"world_border_size","74":"world_border_warning_delay","75":"world_border_warning_reach","76":"camera","77":"held_item_slot","78":"update_view_position","79":"update_view_distance","80":"spawn_position","81":"scoreboard_display_objective","82":"entity_metadata","83":"attach_entity","84":"entity_velocity","85":"entity_equipment","86":"experience","87":"update_health","88":"scoreboard_objective","89":"set_passengers","90":"teams","91":"scoreboard_score","92":"simulation_distance","93":"set_title_subtitle","94":"update_time","95":"set_title_text","96":"set_title_time","97":"entity_sound_effect","98":"sound_effect","99":"stop_sound","100":"system_chat","101":"playerlist_header","102":"nbt_query_response","103":"collect","104":"entity_teleport","105":"advancements","106":"entity_update_attributes","107":"feature_flags","108":"entity_effect","109":"declare_recipes","110":"tags"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "bundle_delimiter": return (ctx.void)(buffer, offset)
          case "spawn_entity": return (ctx.packet_spawn_entity)(buffer, offset)
          case "spawn_entity_experience_orb": return (ctx.packet_spawn_entity_experience_orb)(buffer, offset)
          case "named_entity_spawn": return (ctx.packet_named_entity_spawn)(buffer, offset)
          case "animation": return (ctx.packet_animation)(buffer, offset)
          case "statistics": return (ctx.packet_statistics)(buffer, offset)
          case "acknowledge_player_digging": return (ctx.packet_acknowledge_player_digging)(buffer, offset)
          case "block_break_animation": return (ctx.packet_block_break_animation)(buffer, offset)
          case "tile_entity_data": return (ctx.packet_tile_entity_data)(buffer, offset)
          case "block_action": return (ctx.packet_block_action)(buffer, offset)
          case "block_change": return (ctx.packet_block_change)(buffer, offset)
          case "boss_bar": return (ctx.packet_boss_bar)(buffer, offset)
          case "difficulty": return (ctx.packet_difficulty)(buffer, offset)
          case "chunk_biomes": return (ctx.packet_chunk_biomes)(buffer, offset)
          case "clear_titles": return (ctx.packet_clear_titles)(buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(buffer, offset)
          case "declare_commands": return (ctx.packet_declare_commands)(buffer, offset)
          case "close_window": return (ctx.packet_close_window)(buffer, offset)
          case "window_items": return (ctx.packet_window_items)(buffer, offset)
          case "craft_progress_bar": return (ctx.packet_craft_progress_bar)(buffer, offset)
          case "set_slot": return (ctx.packet_set_slot)(buffer, offset)
          case "set_cooldown": return (ctx.packet_set_cooldown)(buffer, offset)
          case "chat_suggestions": return (ctx.packet_chat_suggestions)(buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(buffer, offset)
          case "damage_event": return (ctx.packet_damage_event)(buffer, offset)
          case "hide_message": return (ctx.packet_hide_message)(buffer, offset)
          case "kick_disconnect": return (ctx.packet_kick_disconnect)(buffer, offset)
          case "profileless_chat": return (ctx.packet_profileless_chat)(buffer, offset)
          case "entity_status": return (ctx.packet_entity_status)(buffer, offset)
          case "explosion": return (ctx.packet_explosion)(buffer, offset)
          case "unload_chunk": return (ctx.packet_unload_chunk)(buffer, offset)
          case "game_state_change": return (ctx.packet_game_state_change)(buffer, offset)
          case "open_horse_window": return (ctx.packet_open_horse_window)(buffer, offset)
          case "hurt_animation": return (ctx.packet_hurt_animation)(buffer, offset)
          case "initialize_world_border": return (ctx.packet_initialize_world_border)(buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(buffer, offset)
          case "map_chunk": return (ctx.packet_map_chunk)(buffer, offset)
          case "world_event": return (ctx.packet_world_event)(buffer, offset)
          case "world_particles": return (ctx.packet_world_particles)(buffer, offset)
          case "update_light": return (ctx.packet_update_light)(buffer, offset)
          case "login": return (ctx.packet_login)(buffer, offset)
          case "map": return (ctx.packet_map)(buffer, offset)
          case "trade_list": return (ctx.packet_trade_list)(buffer, offset)
          case "rel_entity_move": return (ctx.packet_rel_entity_move)(buffer, offset)
          case "entity_move_look": return (ctx.packet_entity_move_look)(buffer, offset)
          case "entity_look": return (ctx.packet_entity_look)(buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(buffer, offset)
          case "open_book": return (ctx.packet_open_book)(buffer, offset)
          case "open_window": return (ctx.packet_open_window)(buffer, offset)
          case "open_sign_entity": return (ctx.packet_open_sign_entity)(buffer, offset)
          case "ping": return (ctx.packet_ping)(buffer, offset)
          case "craft_recipe_response": return (ctx.packet_craft_recipe_response)(buffer, offset)
          case "abilities": return (ctx.packet_abilities)(buffer, offset)
          case "player_chat": return (ctx.packet_player_chat)(buffer, offset)
          case "end_combat_event": return (ctx.packet_end_combat_event)(buffer, offset)
          case "enter_combat_event": return (ctx.packet_enter_combat_event)(buffer, offset)
          case "death_combat_event": return (ctx.packet_death_combat_event)(buffer, offset)
          case "player_remove": return (ctx.packet_player_remove)(buffer, offset)
          case "player_info": return (ctx.packet_player_info)(buffer, offset)
          case "face_player": return (ctx.packet_face_player)(buffer, offset)
          case "position": return (ctx.packet_position)(buffer, offset)
          case "unlock_recipes": return (ctx.packet_unlock_recipes)(buffer, offset)
          case "entity_destroy": return (ctx.packet_entity_destroy)(buffer, offset)
          case "remove_entity_effect": return (ctx.packet_remove_entity_effect)(buffer, offset)
          case "resource_pack_send": return (ctx.packet_resource_pack_send)(buffer, offset)
          case "respawn": return (ctx.packet_respawn)(buffer, offset)
          case "entity_head_rotation": return (ctx.packet_entity_head_rotation)(buffer, offset)
          case "multi_block_change": return (ctx.packet_multi_block_change)(buffer, offset)
          case "select_advancement_tab": return (ctx.packet_select_advancement_tab)(buffer, offset)
          case "server_data": return (ctx.packet_server_data)(buffer, offset)
          case "action_bar": return (ctx.packet_action_bar)(buffer, offset)
          case "world_border_center": return (ctx.packet_world_border_center)(buffer, offset)
          case "world_border_lerp_size": return (ctx.packet_world_border_lerp_size)(buffer, offset)
          case "world_border_size": return (ctx.packet_world_border_size)(buffer, offset)
          case "world_border_warning_delay": return (ctx.packet_world_border_warning_delay)(buffer, offset)
          case "world_border_warning_reach": return (ctx.packet_world_border_warning_reach)(buffer, offset)
          case "camera": return (ctx.packet_camera)(buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(buffer, offset)
          case "update_view_position": return (ctx.packet_update_view_position)(buffer, offset)
          case "update_view_distance": return (ctx.packet_update_view_distance)(buffer, offset)
          case "spawn_position": return (ctx.packet_spawn_position)(buffer, offset)
          case "scoreboard_display_objective": return (ctx.packet_scoreboard_display_objective)(buffer, offset)
          case "entity_metadata": return (ctx.packet_entity_metadata)(buffer, offset)
          case "attach_entity": return (ctx.packet_attach_entity)(buffer, offset)
          case "entity_velocity": return (ctx.packet_entity_velocity)(buffer, offset)
          case "entity_equipment": return (ctx.packet_entity_equipment)(buffer, offset)
          case "experience": return (ctx.packet_experience)(buffer, offset)
          case "update_health": return (ctx.packet_update_health)(buffer, offset)
          case "scoreboard_objective": return (ctx.packet_scoreboard_objective)(buffer, offset)
          case "set_passengers": return (ctx.packet_set_passengers)(buffer, offset)
          case "teams": return (ctx.packet_teams)(buffer, offset)
          case "scoreboard_score": return (ctx.packet_scoreboard_score)(buffer, offset)
          case "simulation_distance": return (ctx.packet_simulation_distance)(buffer, offset)
          case "set_title_subtitle": return (ctx.packet_set_title_subtitle)(buffer, offset)
          case "update_time": return (ctx.packet_update_time)(buffer, offset)
          case "set_title_text": return (ctx.packet_set_title_text)(buffer, offset)
          case "set_title_time": return (ctx.packet_set_title_time)(buffer, offset)
          case "entity_sound_effect": return (ctx.packet_entity_sound_effect)(buffer, offset)
          case "sound_effect": return (ctx.packet_sound_effect)(buffer, offset)
          case "stop_sound": return (ctx.packet_stop_sound)(buffer, offset)
          case "system_chat": return (ctx.packet_system_chat)(buffer, offset)
          case "playerlist_header": return (ctx.packet_playerlist_header)(buffer, offset)
          case "nbt_query_response": return (ctx.packet_nbt_query_response)(buffer, offset)
          case "collect": return (ctx.packet_collect)(buffer, offset)
          case "entity_teleport": return (ctx.packet_entity_teleport)(buffer, offset)
          case "advancements": return (ctx.packet_advancements)(buffer, offset)
          case "entity_update_attributes": return (ctx.packet_entity_update_attributes)(buffer, offset)
          case "feature_flags": return (ctx.packet_feature_flags)(buffer, offset)
          case "entity_effect": return (ctx.packet_entity_effect)(buffer, offset)
          case "declare_recipes": return (ctx.packet_declare_recipes)(buffer, offset)
          case "tags": return (ctx.packet_tags)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_login_start: (value) => {
      let size = 0
      let username = value.username
      size += (ctx.string)(username)
      let playerUUID = value.playerUUID
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.UUID)(value)
        }
        return 1
      })(playerUUID)
      return size
    },
    packet_encryption_begin: (value) => {
      let size = 0
      let sharedSecret = value.sharedSecret
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(sharedSecret)
      let verifyToken = value.verifyToken
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(verifyToken)
      return size
    },
    packet_login_plugin_response: (value) => {
      let size = 0
      let messageId = value.messageId
      size += (ctx.varint)(messageId)
      let data = value.data
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.restBuffer)(value)
        }
        return 1
      })(data)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"login_start":0,"encryption_begin":1,"login_plugin_response":2}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "login_start": return (ctx.packet_login_start)(value)
          case "encryption_begin": return (ctx.packet_encryption_begin)(value)
          case "login_plugin_response": return (ctx.packet_login_plugin_response)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_login_start: (value, buffer, offset) => {
      let username = value.username
      offset = (ctx.string)(username, buffer, offset)
      let playerUUID = value.playerUUID
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.UUID)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(playerUUID, buffer, offset)
      return offset
    },
    packet_encryption_begin: (value, buffer, offset) => {
      let sharedSecret = value.sharedSecret
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(sharedSecret, buffer, offset)
      let verifyToken = value.verifyToken
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(verifyToken, buffer, offset)
      return offset
    },
    packet_login_plugin_response: (value, buffer, offset) => {
      let messageId = value.messageId
      offset = (ctx.varint)(messageId, buffer, offset)
      let data = value.data
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.restBuffer)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(data, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"login_start":0,"encryption_begin":1,"login_plugin_response":2}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "login_start": return (ctx.packet_login_start)(value, buffer, offset)
          case "encryption_begin": return (ctx.packet_encryption_begin)(value, buffer, offset)
          case "login_plugin_response": return (ctx.packet_login_plugin_response)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_login_start: (buffer, offset) => {
      let { value: username, size: usernameSize } = (ctx.string)(buffer, offset)
      let { value: playerUUID, size: playerUUIDSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.UUID)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + usernameSize)
      return { value: { username, playerUUID }, size: usernameSize + playerUUIDSize}
    },
    packet_encryption_begin: (buffer, offset) => {
      let { value: sharedSecret, size: sharedSecretSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset)
      let { value: verifyToken, size: verifyTokenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + sharedSecretSize)
      return { value: { sharedSecret, verifyToken }, size: sharedSecretSize + verifyTokenSize}
    },
    packet_login_plugin_response: (buffer, offset) => {
      let { value: messageId, size: messageIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.restBuffer)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + messageIdSize)
      return { value: { messageId, data }, size: messageIdSize + dataSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"login_start","1":"encryption_begin","2":"login_plugin_response"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "login_start": return (ctx.packet_login_start)(buffer, offset)
          case "encryption_begin": return (ctx.packet_encryption_begin)(buffer, offset)
          case "login_plugin_response": return (ctx.packet_login_plugin_response)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_disconnect: (value) => {
      let size = 0
      let reason = value.reason
      size += (ctx.string)(reason)
      return size
    },
    packet_encryption_begin: (value) => {
      let size = 0
      let serverId = value.serverId
      size += (ctx.string)(serverId)
      let publicKey = value.publicKey
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(publicKey)
      let verifyToken = value.verifyToken
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(verifyToken)
      return size
    },
    packet_success: (value) => {
      let size = 0
      let uuid = value.uuid
      size += (ctx.UUID)(uuid)
      let username = value.username
      size += (ctx.string)(username)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let name1 = value.name
          size += (ctx.string)(name1)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    packet_compress: (value) => {
      let size = 0
      let threshold = value.threshold
      size += (ctx.varint)(threshold)
      return size
    },
    packet_login_plugin_request: (value) => {
      let size = 0
      let messageId = value.messageId
      size += (ctx.varint)(messageId)
      let channel = value.channel
      size += (ctx.string)(channel)
      let data = value.data
      size += (ctx.restBuffer)(data)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"disconnect":0,"encryption_begin":1,"success":2,"compress":3,"login_plugin_request":4}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "disconnect": return (ctx.packet_disconnect)(value)
          case "encryption_begin": return (ctx.packet_encryption_begin)(value)
          case "success": return (ctx.packet_success)(value)
          case "compress": return (ctx.packet_compress)(value)
          case "login_plugin_request": return (ctx.packet_login_plugin_request)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_disconnect: (value, buffer, offset) => {
      let reason = value.reason
      offset = (ctx.string)(reason, buffer, offset)
      return offset
    },
    packet_encryption_begin: (value, buffer, offset) => {
      let serverId = value.serverId
      offset = (ctx.string)(serverId, buffer, offset)
      let publicKey = value.publicKey
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(publicKey, buffer, offset)
      let verifyToken = value.verifyToken
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(verifyToken, buffer, offset)
      return offset
    },
    packet_success: (value, buffer, offset) => {
      let uuid = value.uuid
      offset = (ctx.UUID)(uuid, buffer, offset)
      let username = value.username
      offset = (ctx.string)(username, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let name1 = value.name
          offset = (ctx.string)(name1, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    packet_compress: (value, buffer, offset) => {
      let threshold = value.threshold
      offset = (ctx.varint)(threshold, buffer, offset)
      return offset
    },
    packet_login_plugin_request: (value, buffer, offset) => {
      let messageId = value.messageId
      offset = (ctx.varint)(messageId, buffer, offset)
      let channel = value.channel
      offset = (ctx.string)(channel, buffer, offset)
      let data = value.data
      offset = (ctx.restBuffer)(data, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"disconnect":0,"encryption_begin":1,"success":2,"compress":3,"login_plugin_request":4}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "disconnect": return (ctx.packet_disconnect)(value, buffer, offset)
          case "encryption_begin": return (ctx.packet_encryption_begin)(value, buffer, offset)
          case "success": return (ctx.packet_success)(value, buffer, offset)
          case "compress": return (ctx.packet_compress)(value, buffer, offset)
          case "login_plugin_request": return (ctx.packet_login_plugin_request)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_disconnect: (buffer, offset) => {
      let { value: reason, size: reasonSize } = (ctx.string)(buffer, offset)
      return { value: { reason }, size: reasonSize}
    },
    packet_encryption_begin: (buffer, offset) => {
      let { value: serverId, size: serverIdSize } = (ctx.string)(buffer, offset)
      let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + serverIdSize)
      let { value: verifyToken, size: verifyTokenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + serverIdSize + publicKeySize)
      return { value: { serverId, publicKey, verifyToken }, size: serverIdSize + publicKeySize + verifyTokenSize}
    },
    packet_success: (buffer, offset) => {
      let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
      let { value: username, size: usernameSize } = (ctx.string)(buffer, offset + uuidSize)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + name1Size)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + name1Size + value1Size)
          return { value: { name: name1, value: value1, signature }, size: name1Size + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + uuidSize + usernameSize)
      return { value: { uuid, username, properties }, size: uuidSize + usernameSize + propertiesSize}
    },
    packet_compress: (buffer, offset) => {
      let { value: threshold, size: thresholdSize } = (ctx.varint)(buffer, offset)
      return { value: { threshold }, size: thresholdSize}
    },
    packet_login_plugin_request: (buffer, offset) => {
      let { value: messageId, size: messageIdSize } = (ctx.varint)(buffer, offset)
      let { value: channel, size: channelSize } = (ctx.string)(buffer, offset + messageIdSize)
      let { value: data, size: dataSize } = (ctx.restBuffer)(buffer, offset + messageIdSize + channelSize)
      return { value: { messageId, channel, data }, size: messageIdSize + channelSize + dataSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"disconnect","1":"encryption_begin","2":"success","3":"compress","4":"login_plugin_request"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "disconnect": return (ctx.packet_disconnect)(buffer, offset)
          case "encryption_begin": return (ctx.packet_encryption_begin)(buffer, offset)
          case "success": return (ctx.packet_success)(buffer, offset)
          case "compress": return (ctx.packet_compress)(buffer, offset)
          case "login_plugin_request": return (ctx.packet_login_plugin_request)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value) => {
      let size = Buffer.byteLength(value, "utf8")
      size += (ctx.varint)(size)
      return size
    },
    vec3f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      return size
    },
    vec4f: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f32)(x)
      let y = value.y
      size += (ctx.f32)(y)
      let z = value.z
      size += (ctx.f32)(z)
      let w = value.w
      size += (ctx.f32)(w)
      return size
    },
    vec3f64: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      return size
    },
    slot: (value) => {
      let size = 0
      let present = value.present
      size += (ctx.bool)(present)
      let itemId = value.itemId
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(itemId)
      let itemCount = value.itemCount
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.i8)(value)
          default: return (ctx.void)(value)
        }
      })(itemCount)
      let nbtData = value.nbtData
      size += ((value) => {
        switch (present) {
          case false: return (ctx.void)(value)
          case true: return (ctx.optionalNbt)(value)
          default: return (ctx.void)(value)
        }
      })(nbtData)
      return size
    },
    particle: (value) => {
      let size = 0
      let particleId = value.particleId
      size += (ctx.varint)(particleId)
      let data = value.data
      size += (ctx.particleData)(data, particleId)
      return size
    },
    particleData: (value, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 3: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 14: return ((value) => {
          let size = 0
          let red = value.red
          size += (ctx.f32)(red)
          let green = value.green
          size += (ctx.f32)(green)
          let blue = value.blue
          size += (ctx.f32)(blue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          return size
        })(value)
        case 15: return ((value) => {
          let size = 0
          let fromRed = value.fromRed
          size += (ctx.f32)(fromRed)
          let fromGreen = value.fromGreen
          size += (ctx.f32)(fromGreen)
          let fromBlue = value.fromBlue
          size += (ctx.f32)(fromBlue)
          let scale = value.scale
          size += (ctx.f32)(scale)
          let toRed = value.toRed
          size += (ctx.f32)(toRed)
          let toGreen = value.toGreen
          size += (ctx.f32)(toGreen)
          let toBlue = value.toBlue
          size += (ctx.f32)(toBlue)
          return size
        })(value)
        case 25: return ((value) => {
          let size = 0
          let blockState = value.blockState
          size += (ctx.varint)(blockState)
          return size
        })(value)
        case 33: return ((value) => {
          let size = 0
          let rotation = value.rotation
          size += (ctx.f32)(rotation)
          return size
        })(value)
        case 42: return ((value) => {
          let size = 0
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value)
        case 43: return ((value) => {
          let size = 0
          let positionType = value.positionType
          size += (ctx.string)(positionType)
          let entityId = value.entityId
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityId)
          let entityEyeHeight = value.entityEyeHeight
          size += ((value) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(entityEyeHeight)
          let destination = value.destination
          size += ((value) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value)
              case "minecraft:entity": return (ctx.varint)(value)
              default: return (ctx.void)(value)
            }
          })(destination)
          let ticks = value.ticks
          size += (ctx.varint)(ticks)
          return size
        })(value)
        case 95: return ((value) => {
          let size = 0
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          size += (ctx.varint)(delayInTicksBeforeShown)
          return size
        })(value)
        default: return (ctx.void)(value)
      }
    },
    ingredient: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += (ctx.slot)(value[i])
      }
      return size
    },
    position: (value) => {
        return 8
    },
    previousMessages: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let id = value.id
        size += (ctx.varint)(id)
        let signature = value.signature
        size += ((value) => {
          switch (id) {
            case 0: return ((value) => {
              let size = value instanceof Buffer ? value.length : Buffer.from(value).length
              return size
            })(value)
            default: return (ctx.void)(value)
          }
        })(signature)
        return size
      })(value[i])
      }
      return size
    },
    entityMetadataItem: (value, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value)
        case "int": return (ctx.varint)(value)
        case "long": return (ctx.varlong)(value)
        case "float": return (ctx.f32)(value)
        case "string": return (ctx.string)(value)
        case "component": return (ctx.string)(value)
        case "optional_component": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "item_stack": return (ctx.slot)(value)
        case "boolean": return (ctx.bool)(value)
        case "rotations": return ((value) => {
          let size = 0
          let pitch = value.pitch
          size += (ctx.f32)(pitch)
          let yaw = value.yaw
          size += (ctx.f32)(yaw)
          let roll = value.roll
          size += (ctx.f32)(roll)
          return size
        })(value)
        case "block_pos": return (ctx.position)(value)
        case "optional_block_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.position)(value)
          }
          return 1
        })(value)
        case "direction": return (ctx.varint)(value)
        case "optional_uuid": return ((value) => {
          if (value != null) {
            return 1 + (ctx.UUID)(value)
          }
          return 1
        })(value)
        case "block_state": return (ctx.varint)(value)
        case "optional_block_state": return (ctx.optvarint)(value)
        case "compound_tag": return (ctx.nbt)(value)
        case "particle": return (ctx.particle)(value)
        case "villager_data": return ((value) => {
          let size = 0
          let villagerType = value.villagerType
          size += (ctx.varint)(villagerType)
          let villagerProfession = value.villagerProfession
          size += (ctx.varint)(villagerProfession)
          let level = value.level
          size += (ctx.varint)(level)
          return size
        })(value)
        case "optional_unsigned_int": return (ctx.optvarint)(value)
        case "pose": return (ctx.varint)(value)
        case "cat_variant": return (ctx.varint)(value)
        case "frog_variant": return (ctx.varint)(value)
        case "optional_global_pos": return ((value) => {
          if (value != null) {
            return 1 + (ctx.string)(value)
          }
          return 1
        })(value)
        case "painting_variant": return (ctx.varint)(value)
        case "sniffer_state": return (ctx.varint)(value)
        case "vector3": return (ctx.vec3f)(value)
        case "quaternion": return (ctx.vec4f)(value)
        default: return (ctx.void)(value)
      }
    },
    entityMetadata: (value) => {
      let size = 1
      for (const i in value) {
        size += ((value) => {
        let size = 0
        let key = value.key
        size += (ctx.u8)(key)
        let type = value.type
        size += ((value) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value)
        })(type)
        let value1 = value.value
        size += (ctx.entityMetadataItem)(value1, type)
        return size
      })(value[i])
      }
      return size
    },
    minecraft_simple_recipe_format: (value) => {
      let size = 0
      let category = value.category
      size += (ctx.varint)(category)
      return size
    },
    minecraft_smelting_format: (value) => {
      let size = 0
      let group = value.group
      size += (ctx.string)(group)
      let category = value.category
      size += (ctx.varint)(category)
      let ingredient = value.ingredient
      size += (ctx.ingredient)(ingredient)
      let result = value.result
      size += (ctx.slot)(result)
      let experience = value.experience
      size += (ctx.f32)(experience)
      let cookTime = value.cookTime
      size += (ctx.varint)(cookTime)
      return size
    },
    tags: (value) => {
      let size = (ctx.varint)(value.length)
      for (let i = 0; i < value.length; i++) {
        size += ((value) => {
        let size = 0
        let tagName = value.tagName
        size += (ctx.string)(tagName)
        let entries = value.entries
        size += ((value) => {
          let size = (ctx.varint)(value.length)
          for (let i = 0; i < value.length; i++) {
            size += (ctx.varint)(value[i])
          }
          return size
        })(entries)
        return size
      })(value[i])
      }
      return size
    },
    chunkBlockEntity: (value) => {
      let size = 0
      const x = value.x
      const z = value.z
      size += 1
      let y = value.y
      size += (ctx.i16)(y)
      let type = value.type
      size += (ctx.varint)(type)
      let nbtData = value.nbtData
      size += (ctx.optionalNbt)(nbtData)
      return size
    },
    chat_session: (value) => {
      if (value != null) {
        return 1 + ((value) => {
        let size = 0
        let uuid = value.uuid
        size += (ctx.UUID)(uuid)
        let publicKey = value.publicKey
        size += ((value) => {
          let size = 0
          let expireTime = value.expireTime
          size += (ctx.i64)(expireTime)
          let keyBytes = value.keyBytes
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keyBytes)
          let keySignature = value.keySignature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            size += (ctx.varint)(size)
            return size
          })(keySignature)
          return size
        })(publicKey)
        return size
      })(value)
      }
      return 1
    },
    game_profile: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      let properties = value.properties
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let key = value.key
          size += (ctx.string)(key)
          let value1 = value.value
          size += (ctx.string)(value1)
          let signature = value.signature
          size += ((value) => {
            if (value != null) {
              return 1 + (ctx.string)(value)
            }
            return 1
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(properties)
      return size
    },
    command_node: (value) => {
      let size = 0
      let flags = value.flags
      size += 1
      let children = value.children
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.varint)(value[i])
        }
        return size
      })(children)
      let redirectNode = value.redirectNode
      size += ((value) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(redirectNode)
      let extraNodeData = value.extraNodeData
      size += ((value) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value)
          case 1: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            return size
          })(value)
          case 2: return ((value) => {
            let size = 0
            let name1 = value.name
            size += (ctx.string)(name1)
            let parser = value.parser
            size += ((value) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value)
            })(parser)
            let properties1 = value.properties
            size += ((value) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value)
                case "brigadier:float": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:double": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:integer": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:long": return ((value) => {
                  let size = 0
                  let flags1 = value.flags
                  size += 1
                  let min = value.min
                  size += ((value) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(min)
                  let max = value.max
                  size += ((value) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value)
                      default: return (ctx.void)(value)
                    }
                  })(max)
                  return size
                })(value)
                case "brigadier:string": return ((value) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value)
                })(value)
                case "minecraft:entity": return 1
                case "minecraft:game_profile": return (ctx.void)(value)
                case "minecraft:block_pos": return (ctx.void)(value)
                case "minecraft:column_pos": return (ctx.void)(value)
                case "minecraft:vec3": return (ctx.void)(value)
                case "minecraft:vec2": return (ctx.void)(value)
                case "minecraft:block_state": return (ctx.void)(value)
                case "minecraft:block_predicate": return (ctx.void)(value)
                case "minecraft:item_stack": return (ctx.void)(value)
                case "minecraft:item_predicate": return (ctx.void)(value)
                case "minecraft:color": return (ctx.void)(value)
                case "minecraft:component": return (ctx.void)(value)
                case "minecraft:message": return (ctx.void)(value)
                case "minecraft:nbt": return (ctx.void)(value)
                case "minecraft:nbt_path": return (ctx.void)(value)
                case "minecraft:objective": return (ctx.void)(value)
                case "minecraft:objective_criteria": return (ctx.void)(value)
                case "minecraft:operation": return (ctx.void)(value)
                case "minecraft:particle": return (ctx.void)(value)
                case "minecraft:angle": return (ctx.void)(value)
                case "minecraft:rotation": return (ctx.void)(value)
                case "minecraft:scoreboard_slot": return (ctx.void)(value)
                case "minecraft:score_holder": return 1
                case "minecraft:swizzle": return (ctx.void)(value)
                case "minecraft:team": return (ctx.void)(value)
                case "minecraft:item_slot": return (ctx.void)(value)
                case "minecraft:resource_location": return (ctx.void)(value)
                case "minecraft:function": return (ctx.void)(value)
                case "minecraft:entity_anchor": return (ctx.void)(value)
                case "minecraft:int_range": return (ctx.void)(value)
                case "minecraft:float_range": return (ctx.void)(value)
                case "minecraft:dimension": return (ctx.void)(value)
                case "minecraft:gamemode": return (ctx.void)(value)
                case "minecraft:time": return ((value) => {
                  let size = 0
                  let min = value.min
                  size += (ctx.i32)(min)
                  return size
                })(value)
                case "minecraft:resource_or_tag": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_or_tag_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:resource_key": return ((value) => {
                  let size = 0
                  let registry = value.registry
                  size += (ctx.string)(registry)
                  return size
                })(value)
                case "minecraft:template_mirror": return (ctx.void)(value)
                case "minecraft:template_rotation": return (ctx.void)(value)
                case "minecraft:heightmap": return (ctx.void)(value)
                case "minecraft:uuid": return (ctx.void)(value)
                default: return (ctx.void)(value)
              }
            })(properties1)
            let suggestionType = value.suggestionType
            size += ((value) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value)
                default: return (ctx.void)(value)
              }
            })(suggestionType)
            return size
          })(value)
          default: return (ctx.void)(value)
        }
      })(extraNodeData)
      return size
    },
    packet_teleport_confirm: (value) => {
      let size = 0
      let teleportId = value.teleportId
      size += (ctx.varint)(teleportId)
      return size
    },
    packet_query_block_nbt: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let location = value.location
      size += (ctx.position)(location)
      return size
    },
    packet_chat_command: (value) => {
      let size = 0
      let command = value.command
      size += (ctx.string)(command)
      let timestamp = value.timestamp
      size += (ctx.i64)(timestamp)
      let salt = value.salt
      size += (ctx.i64)(salt)
      let argumentSignatures = value.argumentSignatures
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let argumentName = value.argumentName
          size += (ctx.string)(argumentName)
          let signature = value.signature
          size += ((value) => {
            let size = value instanceof Buffer ? value.length : Buffer.from(value).length
            return size
          })(signature)
          return size
        })(value[i])
        }
        return size
      })(argumentSignatures)
      let messageCount = value.messageCount
      size += (ctx.varint)(messageCount)
      let acknowledged = value.acknowledged
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        return size
      })(acknowledged)
      return size
    },
    packet_chat_message: (value) => {
      let size = 0
      let message = value.message
      size += (ctx.string)(message)
      let timestamp = value.timestamp
      size += (ctx.i64)(timestamp)
      let salt = value.salt
      size += (ctx.i64)(salt)
      let signature = value.signature
      size += ((value) => {
        if (value != null) {
          return 1 + ((value) => {
          let size = value instanceof Buffer ? value.length : Buffer.from(value).length
          return size
        })(value)
        }
        return 1
      })(signature)
      let offset1 = value.offset
      size += (ctx.varint)(offset1)
      let acknowledged = value.acknowledged
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        return size
      })(acknowledged)
      return size
    },
    packet_set_difficulty: (value) => {
      let size = 0
      let newDifficulty = value.newDifficulty
      size += (ctx.u8)(newDifficulty)
      return size
    },
    packet_message_acknowledgement: (value) => {
      let size = 0
      let count = value.count
      size += (ctx.varint)(count)
      return size
    },
    packet_edit_book: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      let pages = value.pages
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += (ctx.string)(value[i])
        }
        return size
      })(pages)
      let title = value.title
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.string)(value)
        }
        return 1
      })(title)
      return size
    },
    packet_query_entity_nbt: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      return size
    },
    packet_pick_item: (value) => {
      let size = 0
      let slot = value.slot
      size += (ctx.varint)(slot)
      return size
    },
    packet_name_item: (value) => {
      let size = 0
      let name = value.name
      size += (ctx.string)(name)
      return size
    },
    packet_select_trade: (value) => {
      let size = 0
      let slot = value.slot
      size += (ctx.varint)(slot)
      return size
    },
    packet_set_beacon_effect: (value) => {
      let size = 0
      let primary_effect = value.primary_effect
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.varint)(value)
        }
        return 1
      })(primary_effect)
      let secondary_effect = value.secondary_effect
      size += ((value) => {
        if (value != null) {
          return 1 + (ctx.varint)(value)
        }
        return 1
      })(secondary_effect)
      return size
    },
    packet_update_command_block: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let command = value.command
      size += (ctx.string)(command)
      let mode = value.mode
      size += (ctx.varint)(mode)
      let flags = value.flags
      size += (ctx.u8)(flags)
      return size
    },
    packet_update_command_block_minecart: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let command = value.command
      size += (ctx.string)(command)
      let track_output = value.track_output
      size += (ctx.bool)(track_output)
      return size
    },
    packet_update_structure_block: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let action = value.action
      size += (ctx.varint)(action)
      let mode = value.mode
      size += (ctx.varint)(mode)
      let name = value.name
      size += (ctx.string)(name)
      let offset_x = value.offset_x
      size += (ctx.i8)(offset_x)
      let offset_y = value.offset_y
      size += (ctx.i8)(offset_y)
      let offset_z = value.offset_z
      size += (ctx.i8)(offset_z)
      let size_x = value.size_x
      size += (ctx.i8)(size_x)
      let size_y = value.size_y
      size += (ctx.i8)(size_y)
      let size_z = value.size_z
      size += (ctx.i8)(size_z)
      let mirror = value.mirror
      size += (ctx.varint)(mirror)
      let rotation = value.rotation
      size += (ctx.varint)(rotation)
      let metadata = value.metadata
      size += (ctx.string)(metadata)
      let integrity = value.integrity
      size += (ctx.f32)(integrity)
      let seed = value.seed
      size += (ctx.varint)(seed)
      let flags = value.flags
      size += (ctx.u8)(flags)
      return size
    },
    packet_tab_complete: (value) => {
      let size = 0
      let transactionId = value.transactionId
      size += (ctx.varint)(transactionId)
      let text = value.text
      size += (ctx.string)(text)
      return size
    },
    packet_client_command: (value) => {
      let size = 0
      let actionId = value.actionId
      size += (ctx.varint)(actionId)
      return size
    },
    packet_settings: (value) => {
      let size = 0
      let locale = value.locale
      size += (ctx.string)(locale)
      let viewDistance = value.viewDistance
      size += (ctx.i8)(viewDistance)
      let chatFlags = value.chatFlags
      size += (ctx.varint)(chatFlags)
      let chatColors = value.chatColors
      size += (ctx.bool)(chatColors)
      let skinParts = value.skinParts
      size += (ctx.u8)(skinParts)
      let mainHand = value.mainHand
      size += (ctx.varint)(mainHand)
      let enableTextFiltering = value.enableTextFiltering
      size += (ctx.bool)(enableTextFiltering)
      let enableServerListing = value.enableServerListing
      size += (ctx.bool)(enableServerListing)
      return size
    },
    packet_enchant_item: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let enchantment = value.enchantment
      size += (ctx.i8)(enchantment)
      return size
    },
    packet_window_click: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      let stateId = value.stateId
      size += (ctx.varint)(stateId)
      let slot = value.slot
      size += (ctx.i16)(slot)
      let mouseButton = value.mouseButton
      size += (ctx.i8)(mouseButton)
      let mode = value.mode
      size += (ctx.varint)(mode)
      let changedSlots = value.changedSlots
      size += ((value) => {
        let size = (ctx.varint)(value.length)
        for (let i = 0; i < value.length; i++) {
          size += ((value) => {
          let size = 0
          let location1 = value.location
          size += (ctx.i16)(location1)
          let item = value.item
          size += (ctx.slot)(item)
          return size
        })(value[i])
        }
        return size
      })(changedSlots)
      let cursorItem = value.cursorItem
      size += (ctx.slot)(cursorItem)
      return size
    },
    packet_close_window: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.u8)(windowId)
      return size
    },
    packet_custom_payload: (value) => {
      let size = 0
      let channel = value.channel
      size += (ctx.string)(channel)
      let data = value.data
      size += (ctx.restBuffer)(data)
      return size
    },
    packet_use_entity: (value) => {
      let size = 0
      let target = value.target
      size += (ctx.varint)(target)
      let mouse = value.mouse
      size += (ctx.varint)(mouse)
      let x = value.x
      size += ((value) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value)
          default: return (ctx.void)(value)
        }
      })(x)
      let y = value.y
      size += ((value) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value)
          default: return (ctx.void)(value)
        }
      })(y)
      let z = value.z
      size += ((value) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value)
          default: return (ctx.void)(value)
        }
      })(z)
      let hand = value.hand
      size += ((value) => {
        switch (mouse) {
          case 0: return (ctx.varint)(value)
          case 2: return (ctx.varint)(value)
          default: return (ctx.void)(value)
        }
      })(hand)
      let sneaking = value.sneaking
      size += (ctx.bool)(sneaking)
      return size
    },
    packet_generate_structure: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let levels = value.levels
      size += (ctx.varint)(levels)
      let keepJigsaws = value.keepJigsaws
      size += (ctx.bool)(keepJigsaws)
      return size
    },
    packet_keep_alive: (value) => {
      let size = 0
      let keepAliveId = value.keepAliveId
      size += (ctx.i64)(keepAliveId)
      return size
    },
    packet_lock_difficulty: (value) => {
      let size = 0
      let locked = value.locked
      size += (ctx.bool)(locked)
      return size
    },
    packet_position: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_position_look: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_look: (value) => {
      let size = 0
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_flying: (value) => {
      let size = 0
      let onGround = value.onGround
      size += (ctx.bool)(onGround)
      return size
    },
    packet_vehicle_move: (value) => {
      let size = 0
      let x = value.x
      size += (ctx.f64)(x)
      let y = value.y
      size += (ctx.f64)(y)
      let z = value.z
      size += (ctx.f64)(z)
      let yaw = value.yaw
      size += (ctx.f32)(yaw)
      let pitch = value.pitch
      size += (ctx.f32)(pitch)
      return size
    },
    packet_steer_boat: (value) => {
      let size = 0
      let leftPaddle = value.leftPaddle
      size += (ctx.bool)(leftPaddle)
      let rightPaddle = value.rightPaddle
      size += (ctx.bool)(rightPaddle)
      return size
    },
    packet_craft_recipe_request: (value) => {
      let size = 0
      let windowId = value.windowId
      size += (ctx.i8)(windowId)
      let recipe = value.recipe
      size += (ctx.string)(recipe)
      let makeAll = value.makeAll
      size += (ctx.bool)(makeAll)
      return size
    },
    packet_abilities: (value) => {
      let size = 0
      let flags = value.flags
      size += (ctx.i8)(flags)
      return size
    },
    packet_block_dig: (value) => {
      let size = 0
      let status = value.status
      size += (ctx.varint)(status)
      let location = value.location
      size += (ctx.position)(location)
      let face = value.face
      size += (ctx.i8)(face)
      let sequence = value.sequence
      size += (ctx.varint)(sequence)
      return size
    },
    packet_entity_action: (value) => {
      let size = 0
      let entityId = value.entityId
      size += (ctx.varint)(entityId)
      let actionId = value.actionId
      size += (ctx.varint)(actionId)
      let jumpBoost = value.jumpBoost
      size += (ctx.varint)(jumpBoost)
      return size
    },
    packet_steer_vehicle: (value) => {
      let size = 0
      let sideways = value.sideways
      size += (ctx.f32)(sideways)
      let forward = value.forward
      size += (ctx.f32)(forward)
      let jump = value.jump
      size += (ctx.u8)(jump)
      return size
    },
    packet_displayed_recipe: (value) => {
      let size = 0
      let recipeId = value.recipeId
      size += (ctx.string)(recipeId)
      return size
    },
    packet_recipe_book: (value) => {
      let size = 0
      let bookId = value.bookId
      size += (ctx.varint)(bookId)
      let bookOpen = value.bookOpen
      size += (ctx.bool)(bookOpen)
      let filterActive = value.filterActive
      size += (ctx.bool)(filterActive)
      return size
    },
    packet_resource_pack_receive: (value) => {
      let size = 0
      let result = value.result
      size += (ctx.varint)(result)
      return size
    },
    packet_held_item_slot: (value) => {
      let size = 0
      let slotId = value.slotId
      size += (ctx.i16)(slotId)
      return size
    },
    packet_set_creative_slot: (value) => {
      let size = 0
      let slot = value.slot
      size += (ctx.i16)(slot)
      let item = value.item
      size += (ctx.slot)(item)
      return size
    },
    packet_update_jigsaw_block: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let name = value.name
      size += (ctx.string)(name)
      let target = value.target
      size += (ctx.string)(target)
      let pool = value.pool
      size += (ctx.string)(pool)
      let finalState = value.finalState
      size += (ctx.string)(finalState)
      let jointType = value.jointType
      size += (ctx.string)(jointType)
      return size
    },
    packet_update_sign: (value) => {
      let size = 0
      let location = value.location
      size += (ctx.position)(location)
      let text1 = value.text1
      size += (ctx.string)(text1)
      let text2 = value.text2
      size += (ctx.string)(text2)
      let text3 = value.text3
      size += (ctx.string)(text3)
      let text4 = value.text4
      size += (ctx.string)(text4)
      return size
    },
    packet_arm_animation: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      return size
    },
    packet_spectate: (value) => {
      let size = 0
      let target = value.target
      size += (ctx.UUID)(target)
      return size
    },
    packet_block_place: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      let location = value.location
      size += (ctx.position)(location)
      let direction = value.direction
      size += (ctx.varint)(direction)
      let cursorX = value.cursorX
      size += (ctx.f32)(cursorX)
      let cursorY = value.cursorY
      size += (ctx.f32)(cursorY)
      let cursorZ = value.cursorZ
      size += (ctx.f32)(cursorZ)
      let insideBlock = value.insideBlock
      size += (ctx.bool)(insideBlock)
      let sequence = value.sequence
      size += (ctx.varint)(sequence)
      return size
    },
    packet_use_item: (value) => {
      let size = 0
      let hand = value.hand
      size += (ctx.varint)(hand)
      let sequence = value.sequence
      size += (ctx.varint)(sequence)
      return size
    },
    packet_advancement_tab: (value) => {
      let size = 0
      let action = value.action
      size += (ctx.varint)(action)
      let tabId = value.tabId
      size += ((value) => {
        switch (action) {
          case 0: return (ctx.string)(value)
          case 1: return (ctx.void)(value)
          default: return (ctx.void)(value)
        }
      })(tabId)
      return size
    },
    packet_pong: (value) => {
      let size = 0
      let id = value.id
      size += (ctx.i32)(id)
      return size
    },
    packet_chat_session_update: (value) => {
      let size = 0
      let sessionUUID = value.sessionUUID
      size += (ctx.UUID)(sessionUUID)
      let expireTime = value.expireTime
      size += (ctx.i64)(expireTime)
      let publicKey = value.publicKey
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(publicKey)
      let signature = value.signature
      size += ((value) => {
        let size = value instanceof Buffer ? value.length : Buffer.from(value).length
        size += (ctx.varint)(size)
        return size
      })(signature)
      return size
    },
    packet: (value) => {
      let size = 0
      let name = value.name
      size += ((value) => {
        return (ctx.varint)({"teleport_confirm":0,"query_block_nbt":1,"set_difficulty":2,"message_acknowledgement":3,"chat_command":4,"chat_message":5,"chat_session_update":6,"client_command":7,"settings":8,"tab_complete":9,"enchant_item":10,"window_click":11,"close_window":12,"custom_payload":13,"edit_book":14,"query_entity_nbt":15,"use_entity":16,"generate_structure":17,"keep_alive":18,"lock_difficulty":19,"position":20,"position_look":21,"look":22,"flying":23,"vehicle_move":24,"steer_boat":25,"pick_item":26,"craft_recipe_request":27,"abilities":28,"block_dig":29,"entity_action":30,"steer_vehicle":31,"pong":32,"recipe_book":33,"displayed_recipe":34,"name_item":35,"resource_pack_receive":36,"advancement_tab":37,"select_trade":38,"set_beacon_effect":39,"held_item_slot":40,"update_command_block":41,"update_command_block_minecart":42,"set_creative_slot":43,"update_jigsaw_block":44,"update_structure_block":45,"update_sign":46,"arm_animation":47,"spectate":48,"block_place":49,"use_item":50}[value] || value)
      })(name)
      let params = value.params
      size += ((value) => {
        switch (name) {
          case "teleport_confirm": return (ctx.packet_teleport_confirm)(value)
          case "query_block_nbt": return (ctx.packet_query_block_nbt)(value)
          case "set_difficulty": return (ctx.packet_set_difficulty)(value)
          case "message_acknowledgement": return (ctx.packet_message_acknowledgement)(value)
          case "chat_command": return (ctx.packet_chat_command)(value)
          case "chat_message": return (ctx.packet_chat_message)(value)
          case "client_command": return (ctx.packet_client_command)(value)
          case "settings": return (ctx.packet_settings)(value)
          case "tab_complete": return (ctx.packet_tab_complete)(value)
          case "enchant_item": return (ctx.packet_enchant_item)(value)
          case "window_click": return (ctx.packet_window_click)(value)
          case "close_window": return (ctx.packet_close_window)(value)
          case "custom_payload": return (ctx.packet_custom_payload)(value)
          case "edit_book": return (ctx.packet_edit_book)(value)
          case "query_entity_nbt": return (ctx.packet_query_entity_nbt)(value)
          case "use_entity": return (ctx.packet_use_entity)(value)
          case "generate_structure": return (ctx.packet_generate_structure)(value)
          case "keep_alive": return (ctx.packet_keep_alive)(value)
          case "lock_difficulty": return (ctx.packet_lock_difficulty)(value)
          case "position": return (ctx.packet_position)(value)
          case "position_look": return (ctx.packet_position_look)(value)
          case "look": return (ctx.packet_look)(value)
          case "flying": return (ctx.packet_flying)(value)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value)
          case "steer_boat": return (ctx.packet_steer_boat)(value)
          case "pick_item": return (ctx.packet_pick_item)(value)
          case "craft_recipe_request": return (ctx.packet_craft_recipe_request)(value)
          case "abilities": return (ctx.packet_abilities)(value)
          case "block_dig": return (ctx.packet_block_dig)(value)
          case "entity_action": return (ctx.packet_entity_action)(value)
          case "steer_vehicle": return (ctx.packet_steer_vehicle)(value)
          case "pong": return (ctx.packet_pong)(value)
          case "chat_session_update": return (ctx.packet_chat_session_update)(value)
          case "recipe_book": return (ctx.packet_recipe_book)(value)
          case "displayed_recipe": return (ctx.packet_displayed_recipe)(value)
          case "name_item": return (ctx.packet_name_item)(value)
          case "resource_pack_receive": return (ctx.packet_resource_pack_receive)(value)
          case "advancement_tab": return (ctx.packet_advancement_tab)(value)
          case "select_trade": return (ctx.packet_select_trade)(value)
          case "set_beacon_effect": return (ctx.packet_set_beacon_effect)(value)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value)
          case "update_command_block": return (ctx.packet_update_command_block)(value)
          case "update_command_block_minecart": return (ctx.packet_update_command_block_minecart)(value)
          case "set_creative_slot": return (ctx.packet_set_creative_slot)(value)
          case "update_jigsaw_block": return (ctx.packet_update_jigsaw_block)(value)
          case "update_structure_block": return (ctx.packet_update_structure_block)(value)
          case "update_sign": return (ctx.packet_update_sign)(value)
          case "arm_animation": return (ctx.packet_arm_animation)(value)
          case "spectate": return (ctx.packet_spectate)(value)
          case "block_place": return (ctx.packet_block_place)(value)
          case "use_item": return (ctx.packet_use_item)(value)
          default: return (ctx.void)(value)
        }
      })(params)
      return size
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (value, buffer, offset) => {
      const length = Buffer.byteLength(value, "utf8")
      offset = (ctx.varint)(length, buffer, offset)
      buffer.write(value, offset, length, "utf8")
      return offset + length
    },
    vec3f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      return offset
    },
    vec4f: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f32)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f32)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f32)(z, buffer, offset)
      let w = value.w
      offset = (ctx.f32)(w, buffer, offset)
      return offset
    },
    vec3f64: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      return offset
    },
    slot: (value, buffer, offset) => {
      let present = value.present
      offset = (ctx.bool)(present, buffer, offset)
      let itemId = value.itemId
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemId, buffer, offset)
      let itemCount = value.itemCount
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.i8)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(itemCount, buffer, offset)
      let nbtData = value.nbtData
      offset = ((value, buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(value, buffer, offset)
          case true: return (ctx.optionalNbt)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(nbtData, buffer, offset)
      return offset
    },
    particle: (value, buffer, offset) => {
      let particleId = value.particleId
      offset = (ctx.varint)(particleId, buffer, offset)
      let data = value.data
      offset = (ctx.particleData)(data, buffer, offset, particleId)
      return offset
    },
    particleData: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 3: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 14: return ((value, buffer, offset) => {
          let red = value.red
          offset = (ctx.f32)(red, buffer, offset)
          let green = value.green
          offset = (ctx.f32)(green, buffer, offset)
          let blue = value.blue
          offset = (ctx.f32)(blue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 15: return ((value, buffer, offset) => {
          let fromRed = value.fromRed
          offset = (ctx.f32)(fromRed, buffer, offset)
          let fromGreen = value.fromGreen
          offset = (ctx.f32)(fromGreen, buffer, offset)
          let fromBlue = value.fromBlue
          offset = (ctx.f32)(fromBlue, buffer, offset)
          let scale = value.scale
          offset = (ctx.f32)(scale, buffer, offset)
          let toRed = value.toRed
          offset = (ctx.f32)(toRed, buffer, offset)
          let toGreen = value.toGreen
          offset = (ctx.f32)(toGreen, buffer, offset)
          let toBlue = value.toBlue
          offset = (ctx.f32)(toBlue, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 25: return ((value, buffer, offset) => {
          let blockState = value.blockState
          offset = (ctx.varint)(blockState, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 33: return ((value, buffer, offset) => {
          let rotation = value.rotation
          offset = (ctx.f32)(rotation, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 42: return ((value, buffer, offset) => {
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 43: return ((value, buffer, offset) => {
          let positionType = value.positionType
          offset = (ctx.string)(positionType, buffer, offset)
          let entityId = value.entityId
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityId, buffer, offset)
          let entityEyeHeight = value.entityEyeHeight
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(entityEyeHeight, buffer, offset)
          let destination = value.destination
          offset = ((value, buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(value, buffer, offset)
              case "minecraft:entity": return (ctx.varint)(value, buffer, offset)
              default: return (ctx.void)(value, buffer, offset)
            }
          })(destination, buffer, offset)
          let ticks = value.ticks
          offset = (ctx.varint)(ticks, buffer, offset)
          return offset
        })(value, buffer, offset)
        case 95: return ((value, buffer, offset) => {
          let delayInTicksBeforeShown = value.delayInTicksBeforeShown
          offset = (ctx.varint)(delayInTicksBeforeShown, buffer, offset)
          return offset
        })(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    ingredient: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = (ctx.slot)(value[i], buffer, offset)
      }
      return offset
    },
    position: (value, buffer, offset) => {
      let x = value.x
      buffer[offset++] = ((x >> 18) & 0xff)
      buffer[offset++] = ((x >> 10) & 0xff)
      buffer[offset++] = ((x >> 2) & 0xff)
      let z = value.z
      buffer[offset++] = ((((x >> 0) & 0x3)) << 6) | ((z >> 20) & 0x3f)
      buffer[offset++] = ((z >> 12) & 0xff)
      buffer[offset++] = ((z >> 4) & 0xff)
      let y = value.y
      buffer[offset++] = ((((z >> 0) & 0xf)) << 4) | ((y >> 8) & 0xf)
      buffer[offset++] = ((y >> 0) & 0xff)
      return offset
    },
    previousMessages: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let id = value.id
        offset = (ctx.varint)(id, buffer, offset)
        let signature = value.signature
        offset = ((value, buffer, offset) => {
          switch (id) {
            case 0: return ((value, buffer, offset) => {
              if (!(value instanceof Buffer)) value = Buffer.from(value)
              value.copy(buffer, offset)
              return offset + value.length
            })(value, buffer, offset)
            default: return (ctx.void)(value, buffer, offset)
          }
        })(signature, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    entityMetadataItem: (value, buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(value, buffer, offset)
        case "int": return (ctx.varint)(value, buffer, offset)
        case "long": return (ctx.varlong)(value, buffer, offset)
        case "float": return (ctx.f32)(value, buffer, offset)
        case "string": return (ctx.string)(value, buffer, offset)
        case "component": return (ctx.string)(value, buffer, offset)
        case "optional_component": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "item_stack": return (ctx.slot)(value, buffer, offset)
        case "boolean": return (ctx.bool)(value, buffer, offset)
        case "rotations": return ((value, buffer, offset) => {
          let pitch = value.pitch
          offset = (ctx.f32)(pitch, buffer, offset)
          let yaw = value.yaw
          offset = (ctx.f32)(yaw, buffer, offset)
          let roll = value.roll
          offset = (ctx.f32)(roll, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "block_pos": return (ctx.position)(value, buffer, offset)
        case "optional_block_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.position)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "direction": return (ctx.varint)(value, buffer, offset)
        case "optional_uuid": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.UUID)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "block_state": return (ctx.varint)(value, buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(value, buffer, offset)
        case "compound_tag": return (ctx.nbt)(value, buffer, offset)
        case "particle": return (ctx.particle)(value, buffer, offset)
        case "villager_data": return ((value, buffer, offset) => {
          let villagerType = value.villagerType
          offset = (ctx.varint)(villagerType, buffer, offset)
          let villagerProfession = value.villagerProfession
          offset = (ctx.varint)(villagerProfession, buffer, offset)
          let level = value.level
          offset = (ctx.varint)(level, buffer, offset)
          return offset
        })(value, buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(value, buffer, offset)
        case "pose": return (ctx.varint)(value, buffer, offset)
        case "cat_variant": return (ctx.varint)(value, buffer, offset)
        case "frog_variant": return (ctx.varint)(value, buffer, offset)
        case "optional_global_pos": return ((value, buffer, offset) => {
          if (value != null) {
            offset = ctx.bool(1, buffer, offset)
            offset = (ctx.string)(value, buffer, offset)
          } else {
            offset = ctx.bool(0, buffer, offset)
          }
          return offset
        })(value, buffer, offset)
        case "painting_variant": return (ctx.varint)(value, buffer, offset)
        case "sniffer_state": return (ctx.varint)(value, buffer, offset)
        case "vector3": return (ctx.vec3f)(value, buffer, offset)
        case "quaternion": return (ctx.vec4f)(value, buffer, offset)
        default: return (ctx.void)(value, buffer, offset)
      }
    },
    entityMetadata: (value, buffer, offset) => {
      for (const i in value) {
        offset = ((value, buffer, offset) => {
        let key = value.key
        offset = (ctx.u8)(key, buffer, offset)
        let type = value.type
        offset = ((value, buffer, offset) => {
          return (ctx.varint)({"byte":0,"int":1,"long":2,"float":3,"string":4,"component":5,"optional_component":6,"item_stack":7,"boolean":8,"rotations":9,"block_pos":10,"optional_block_pos":11,"direction":12,"optional_uuid":13,"block_state":14,"optional_block_state":15,"compound_tag":16,"particle":17,"villager_data":18,"optional_unsigned_int":19,"pose":20,"cat_variant":21,"frog_variant":22,"optional_global_pos":23,"painting_variant":24,"sniffer_state":25,"vector3":26,"quaternion":27}[value] || value, buffer, offset)
        })(type, buffer, offset)
        let value1 = value.value
        offset = (ctx.entityMetadataItem)(value1, buffer, offset, type)
        return offset
      })(value[i], buffer, offset)
      }
      return offset + ctx.u8(255, buffer, offset)
    },
    minecraft_simple_recipe_format: (value, buffer, offset) => {
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      return offset
    },
    minecraft_smelting_format: (value, buffer, offset) => {
      let group = value.group
      offset = (ctx.string)(group, buffer, offset)
      let category = value.category
      offset = (ctx.varint)(category, buffer, offset)
      let ingredient = value.ingredient
      offset = (ctx.ingredient)(ingredient, buffer, offset)
      let result = value.result
      offset = (ctx.slot)(result, buffer, offset)
      let experience = value.experience
      offset = (ctx.f32)(experience, buffer, offset)
      let cookTime = value.cookTime
      offset = (ctx.varint)(cookTime, buffer, offset)
      return offset
    },
    tags: (value, buffer, offset) => {
      offset = (ctx.varint)(value.length, buffer, offset)
      for (let i = 0; i < value.length; i++) {
        offset = ((value, buffer, offset) => {
        let tagName = value.tagName
        offset = (ctx.string)(tagName, buffer, offset)
        let entries = value.entries
        offset = ((value, buffer, offset) => {
          offset = (ctx.varint)(value.length, buffer, offset)
          for (let i = 0; i < value.length; i++) {
            offset = (ctx.varint)(value[i], buffer, offset)
          }
          return offset
        })(entries, buffer, offset)
        return offset
      })(value[i], buffer, offset)
      }
      return offset
    },
    chunkBlockEntity: (value, buffer, offset) => {
      const x = value.x
      const z = value.z
      offset = ((value, buffer, offset) => {
        let x = value.x
        let z = value.z
        buffer[offset++] = ((((x >> 0) & 0xf)) << 4) | ((z >> 0) & 0xf)
        return offset
      })({x, z}, buffer, offset)
      let y = value.y
      offset = (ctx.i16)(y, buffer, offset)
      let type = value.type
      offset = (ctx.varint)(type, buffer, offset)
      let nbtData = value.nbtData
      offset = (ctx.optionalNbt)(nbtData, buffer, offset)
      return offset
    },
    chat_session: (value, buffer, offset) => {
      if (value != null) {
        offset = ctx.bool(1, buffer, offset)
        offset = ((value, buffer, offset) => {
        let uuid = value.uuid
        offset = (ctx.UUID)(uuid, buffer, offset)
        let publicKey = value.publicKey
        offset = ((value, buffer, offset) => {
          let expireTime = value.expireTime
          offset = (ctx.i64)(expireTime, buffer, offset)
          let keyBytes = value.keyBytes
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keyBytes, buffer, offset)
          let keySignature = value.keySignature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            offset = (ctx.varint)(value.length, buffer, offset)
            value.copy(buffer, offset)
            return offset + value.length
          })(keySignature, buffer, offset)
          return offset
        })(publicKey, buffer, offset)
        return offset
      })(value, buffer, offset)
      } else {
        offset = ctx.bool(0, buffer, offset)
      }
      return offset
    },
    game_profile: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let properties = value.properties
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let key = value.key
          offset = (ctx.string)(key, buffer, offset)
          let value1 = value.value
          offset = (ctx.string)(value1, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (value != null) {
              offset = ctx.bool(1, buffer, offset)
              offset = (ctx.string)(value, buffer, offset)
            } else {
              offset = ctx.bool(0, buffer, offset)
            }
            return offset
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(properties, buffer, offset)
      return offset
    },
    command_node: (value, buffer, offset) => {
      let flags = value.flags
      offset = ((value, buffer, offset) => {
        let unused = value.unused
        let has_custom_suggestions = value.has_custom_suggestions
        let has_redirect_node = value.has_redirect_node
        let has_command = value.has_command
        let command_node_type = value.command_node_type
        buffer[offset++] = ((((((((((unused >> 0) & 0x7)) << 1) | ((has_custom_suggestions >> 0) & 0x1)) << 1) | ((has_redirect_node >> 0) & 0x1)) << 1) | ((has_command >> 0) & 0x1)) << 2) | ((command_node_type >> 0) & 0x3)
        return offset
      })(flags, buffer, offset)
      let children = value.children
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.varint)(value[i], buffer, offset)
        }
        return offset
      })(children, buffer, offset)
      let redirectNode = value.redirectNode
      offset = ((value, buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(redirectNode, buffer, offset)
      let extraNodeData = value.extraNodeData
      offset = ((value, buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(value, buffer, offset)
          case 1: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            return offset
          })(value, buffer, offset)
          case 2: return ((value, buffer, offset) => {
            let name1 = value.name
            offset = (ctx.string)(name1, buffer, offset)
            let parser = value.parser
            offset = ((value, buffer, offset) => {
              return (ctx.varint)({"brigadier:bool":0,"brigadier:float":1,"brigadier:double":2,"brigadier:integer":3,"brigadier:long":4,"brigadier:string":5,"minecraft:entity":6,"minecraft:game_profile":7,"minecraft:block_pos":8,"minecraft:column_pos":9,"minecraft:vec3":10,"minecraft:vec2":11,"minecraft:block_state":12,"minecraft:block_predicate":13,"minecraft:item_stack":14,"minecraft:item_predicate":15,"minecraft:color":16,"minecraft:component":17,"minecraft:message":18,"minecraft:nbt":19,"minecraft:nbt_tag":20,"minecraft:nbt_path":21,"minecraft:objective":22,"minecraft:objective_criteria":23,"minecraft:operation":24,"minecraft:particle":25,"minecraft:angle":26,"minecraft:rotation":27,"minecraft:scoreboard_slot":28,"minecraft:score_holder":29,"minecraft:swizzle":30,"minecraft:team":31,"minecraft:item_slot":32,"minecraft:resource_location":33,"minecraft:function":34,"minecraft:entity_anchor":35,"minecraft:int_range":36,"minecraft:float_range":37,"minecraft:dimension":38,"minecraft:gamemode":39,"minecraft:time":40,"minecraft:resource_or_tag":41,"minecraft:resource_or_tag_key":42,"minecraft:resource":43,"minecraft:resource_key":44,"minecraft:template_mirror":45,"minecraft:template_rotation":46,"minecraft:heightmap":47,"minecraft:uuid":48}[value] || value, buffer, offset)
            })(parser, buffer, offset)
            let properties1 = value.properties
            offset = ((value, buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(value, buffer, offset)
                case "brigadier:float": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:double": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:integer": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:long": return ((value, buffer, offset) => {
                  let flags1 = value.flags
                  offset = ((value, buffer, offset) => {
                    let unused1 = value.unused
                    let max_present = value.max_present
                    let min_present = value.min_present
                    buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((max_present >> 0) & 0x1)) << 1) | ((min_present >> 0) & 0x1)
                    return offset
                  })(flags1, buffer, offset)
                  let min = value.min
                  offset = ((value, buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(min, buffer, offset)
                  let max = value.max
                  offset = ((value, buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(value, buffer, offset)
                      default: return (ctx.void)(value, buffer, offset)
                    }
                  })(max, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "brigadier:string": return ((value, buffer, offset) => {
                  return (ctx.varint)({"SINGLE_WORD":0,"QUOTABLE_PHRASE":1,"GREEDY_PHRASE":2}[value] || value, buffer, offset)
                })(value, buffer, offset)
                case "minecraft:entity": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let onlyAllowPlayers = value.onlyAllowPlayers
                  let onlyAllowEntities = value.onlyAllowEntities
                  buffer[offset++] = ((((((unused1 >> 0) & 0x3f)) << 1) | ((onlyAllowPlayers >> 0) & 0x1)) << 1) | ((onlyAllowEntities >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec3": return (ctx.void)(value, buffer, offset)
                case "minecraft:vec2": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_state": return (ctx.void)(value, buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(value, buffer, offset)
                case "minecraft:color": return (ctx.void)(value, buffer, offset)
                case "minecraft:component": return (ctx.void)(value, buffer, offset)
                case "minecraft:message": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt": return (ctx.void)(value, buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective": return (ctx.void)(value, buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(value, buffer, offset)
                case "minecraft:operation": return (ctx.void)(value, buffer, offset)
                case "minecraft:particle": return (ctx.void)(value, buffer, offset)
                case "minecraft:angle": return (ctx.void)(value, buffer, offset)
                case "minecraft:rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:score_holder": return ((value, buffer, offset) => {
                  let unused1 = value.unused
                  let allowMultiple = value.allowMultiple
                  buffer[offset++] = ((((unused1 >> 0) & 0x7f)) << 1) | ((allowMultiple >> 0) & 0x1)
                  return offset
                })(value, buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(value, buffer, offset)
                case "minecraft:team": return (ctx.void)(value, buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(value, buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(value, buffer, offset)
                case "minecraft:function": return (ctx.void)(value, buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(value, buffer, offset)
                case "minecraft:int_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:float_range": return (ctx.void)(value, buffer, offset)
                case "minecraft:dimension": return (ctx.void)(value, buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(value, buffer, offset)
                case "minecraft:time": return ((value, buffer, offset) => {
                  let min = value.min
                  offset = (ctx.i32)(min, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_or_tag_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:resource_key": return ((value, buffer, offset) => {
                  let registry = value.registry
                  offset = (ctx.string)(registry, buffer, offset)
                  return offset
                })(value, buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(value, buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(value, buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(value, buffer, offset)
                case "minecraft:uuid": return (ctx.void)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(properties1, buffer, offset)
            let suggestionType = value.suggestionType
            offset = ((value, buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(value, buffer, offset)
                default: return (ctx.void)(value, buffer, offset)
              }
            })(suggestionType, buffer, offset)
            return offset
          })(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(extraNodeData, buffer, offset)
      return offset
    },
    packet_teleport_confirm: (value, buffer, offset) => {
      let teleportId = value.teleportId
      offset = (ctx.varint)(teleportId, buffer, offset)
      return offset
    },
    packet_query_block_nbt: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      return offset
    },
    packet_chat_command: (value, buffer, offset) => {
      let command = value.command
      offset = (ctx.string)(command, buffer, offset)
      let timestamp = value.timestamp
      offset = (ctx.i64)(timestamp, buffer, offset)
      let salt = value.salt
      offset = (ctx.i64)(salt, buffer, offset)
      let argumentSignatures = value.argumentSignatures
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let argumentName = value.argumentName
          offset = (ctx.string)(argumentName, buffer, offset)
          let signature = value.signature
          offset = ((value, buffer, offset) => {
            if (!(value instanceof Buffer)) value = Buffer.from(value)
            value.copy(buffer, offset)
            return offset + value.length
          })(signature, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(argumentSignatures, buffer, offset)
      let messageCount = value.messageCount
      offset = (ctx.varint)(messageCount, buffer, offset)
      let acknowledged = value.acknowledged
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        value.copy(buffer, offset)
        return offset + value.length
      })(acknowledged, buffer, offset)
      return offset
    },
    packet_chat_message: (value, buffer, offset) => {
      let message = value.message
      offset = (ctx.string)(message, buffer, offset)
      let timestamp = value.timestamp
      offset = (ctx.i64)(timestamp, buffer, offset)
      let salt = value.salt
      offset = (ctx.i64)(salt, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = ((value, buffer, offset) => {
          if (!(value instanceof Buffer)) value = Buffer.from(value)
          value.copy(buffer, offset)
          return offset + value.length
        })(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(signature, buffer, offset)
      let offset1 = value.offset
      offset = (ctx.varint)(offset1, buffer, offset)
      let acknowledged = value.acknowledged
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        value.copy(buffer, offset)
        return offset + value.length
      })(acknowledged, buffer, offset)
      return offset
    },
    packet_set_difficulty: (value, buffer, offset) => {
      let newDifficulty = value.newDifficulty
      offset = (ctx.u8)(newDifficulty, buffer, offset)
      return offset
    },
    packet_message_acknowledgement: (value, buffer, offset) => {
      let count = value.count
      offset = (ctx.varint)(count, buffer, offset)
      return offset
    },
    packet_edit_book: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      let pages = value.pages
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = (ctx.string)(value[i], buffer, offset)
        }
        return offset
      })(pages, buffer, offset)
      let title = value.title
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.string)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(title, buffer, offset)
      return offset
    },
    packet_query_entity_nbt: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      return offset
    },
    packet_pick_item: (value, buffer, offset) => {
      let slot = value.slot
      offset = (ctx.varint)(slot, buffer, offset)
      return offset
    },
    packet_name_item: (value, buffer, offset) => {
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      return offset
    },
    packet_select_trade: (value, buffer, offset) => {
      let slot = value.slot
      offset = (ctx.varint)(slot, buffer, offset)
      return offset
    },
    packet_set_beacon_effect: (value, buffer, offset) => {
      let primary_effect = value.primary_effect
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.varint)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(primary_effect, buffer, offset)
      let secondary_effect = value.secondary_effect
      offset = ((value, buffer, offset) => {
        if (value != null) {
          offset = ctx.bool(1, buffer, offset)
          offset = (ctx.varint)(value, buffer, offset)
        } else {
          offset = ctx.bool(0, buffer, offset)
        }
        return offset
      })(secondary_effect, buffer, offset)
      return offset
    },
    packet_update_command_block: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let command = value.command
      offset = (ctx.string)(command, buffer, offset)
      let mode = value.mode
      offset = (ctx.varint)(mode, buffer, offset)
      let flags = value.flags
      offset = (ctx.u8)(flags, buffer, offset)
      return offset
    },
    packet_update_command_block_minecart: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let command = value.command
      offset = (ctx.string)(command, buffer, offset)
      let track_output = value.track_output
      offset = (ctx.bool)(track_output, buffer, offset)
      return offset
    },
    packet_update_structure_block: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let mode = value.mode
      offset = (ctx.varint)(mode, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let offset_x = value.offset_x
      offset = (ctx.i8)(offset_x, buffer, offset)
      let offset_y = value.offset_y
      offset = (ctx.i8)(offset_y, buffer, offset)
      let offset_z = value.offset_z
      offset = (ctx.i8)(offset_z, buffer, offset)
      let size_x = value.size_x
      offset = (ctx.i8)(size_x, buffer, offset)
      let size_y = value.size_y
      offset = (ctx.i8)(size_y, buffer, offset)
      let size_z = value.size_z
      offset = (ctx.i8)(size_z, buffer, offset)
      let mirror = value.mirror
      offset = (ctx.varint)(mirror, buffer, offset)
      let rotation = value.rotation
      offset = (ctx.varint)(rotation, buffer, offset)
      let metadata = value.metadata
      offset = (ctx.string)(metadata, buffer, offset)
      let integrity = value.integrity
      offset = (ctx.f32)(integrity, buffer, offset)
      let seed = value.seed
      offset = (ctx.varint)(seed, buffer, offset)
      let flags = value.flags
      offset = (ctx.u8)(flags, buffer, offset)
      return offset
    },
    packet_tab_complete: (value, buffer, offset) => {
      let transactionId = value.transactionId
      offset = (ctx.varint)(transactionId, buffer, offset)
      let text = value.text
      offset = (ctx.string)(text, buffer, offset)
      return offset
    },
    packet_client_command: (value, buffer, offset) => {
      let actionId = value.actionId
      offset = (ctx.varint)(actionId, buffer, offset)
      return offset
    },
    packet_settings: (value, buffer, offset) => {
      let locale = value.locale
      offset = (ctx.string)(locale, buffer, offset)
      let viewDistance = value.viewDistance
      offset = (ctx.i8)(viewDistance, buffer, offset)
      let chatFlags = value.chatFlags
      offset = (ctx.varint)(chatFlags, buffer, offset)
      let chatColors = value.chatColors
      offset = (ctx.bool)(chatColors, buffer, offset)
      let skinParts = value.skinParts
      offset = (ctx.u8)(skinParts, buffer, offset)
      let mainHand = value.mainHand
      offset = (ctx.varint)(mainHand, buffer, offset)
      let enableTextFiltering = value.enableTextFiltering
      offset = (ctx.bool)(enableTextFiltering, buffer, offset)
      let enableServerListing = value.enableServerListing
      offset = (ctx.bool)(enableServerListing, buffer, offset)
      return offset
    },
    packet_enchant_item: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let enchantment = value.enchantment
      offset = (ctx.i8)(enchantment, buffer, offset)
      return offset
    },
    packet_window_click: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      let stateId = value.stateId
      offset = (ctx.varint)(stateId, buffer, offset)
      let slot = value.slot
      offset = (ctx.i16)(slot, buffer, offset)
      let mouseButton = value.mouseButton
      offset = (ctx.i8)(mouseButton, buffer, offset)
      let mode = value.mode
      offset = (ctx.varint)(mode, buffer, offset)
      let changedSlots = value.changedSlots
      offset = ((value, buffer, offset) => {
        offset = (ctx.varint)(value.length, buffer, offset)
        for (let i = 0; i < value.length; i++) {
          offset = ((value, buffer, offset) => {
          let location1 = value.location
          offset = (ctx.i16)(location1, buffer, offset)
          let item = value.item
          offset = (ctx.slot)(item, buffer, offset)
          return offset
        })(value[i], buffer, offset)
        }
        return offset
      })(changedSlots, buffer, offset)
      let cursorItem = value.cursorItem
      offset = (ctx.slot)(cursorItem, buffer, offset)
      return offset
    },
    packet_close_window: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.u8)(windowId, buffer, offset)
      return offset
    },
    packet_custom_payload: (value, buffer, offset) => {
      let channel = value.channel
      offset = (ctx.string)(channel, buffer, offset)
      let data = value.data
      offset = (ctx.restBuffer)(data, buffer, offset)
      return offset
    },
    packet_use_entity: (value, buffer, offset) => {
      let target = value.target
      offset = (ctx.varint)(target, buffer, offset)
      let mouse = value.mouse
      offset = (ctx.varint)(mouse, buffer, offset)
      let x = value.x
      offset = ((value, buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(x, buffer, offset)
      let y = value.y
      offset = ((value, buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(y, buffer, offset)
      let z = value.z
      offset = ((value, buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(z, buffer, offset)
      let hand = value.hand
      offset = ((value, buffer, offset) => {
        switch (mouse) {
          case 0: return (ctx.varint)(value, buffer, offset)
          case 2: return (ctx.varint)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(hand, buffer, offset)
      let sneaking = value.sneaking
      offset = (ctx.bool)(sneaking, buffer, offset)
      return offset
    },
    packet_generate_structure: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let levels = value.levels
      offset = (ctx.varint)(levels, buffer, offset)
      let keepJigsaws = value.keepJigsaws
      offset = (ctx.bool)(keepJigsaws, buffer, offset)
      return offset
    },
    packet_keep_alive: (value, buffer, offset) => {
      let keepAliveId = value.keepAliveId
      offset = (ctx.i64)(keepAliveId, buffer, offset)
      return offset
    },
    packet_lock_difficulty: (value, buffer, offset) => {
      let locked = value.locked
      offset = (ctx.bool)(locked, buffer, offset)
      return offset
    },
    packet_position: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_position_look: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_look: (value, buffer, offset) => {
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_flying: (value, buffer, offset) => {
      let onGround = value.onGround
      offset = (ctx.bool)(onGround, buffer, offset)
      return offset
    },
    packet_vehicle_move: (value, buffer, offset) => {
      let x = value.x
      offset = (ctx.f64)(x, buffer, offset)
      let y = value.y
      offset = (ctx.f64)(y, buffer, offset)
      let z = value.z
      offset = (ctx.f64)(z, buffer, offset)
      let yaw = value.yaw
      offset = (ctx.f32)(yaw, buffer, offset)
      let pitch = value.pitch
      offset = (ctx.f32)(pitch, buffer, offset)
      return offset
    },
    packet_steer_boat: (value, buffer, offset) => {
      let leftPaddle = value.leftPaddle
      offset = (ctx.bool)(leftPaddle, buffer, offset)
      let rightPaddle = value.rightPaddle
      offset = (ctx.bool)(rightPaddle, buffer, offset)
      return offset
    },
    packet_craft_recipe_request: (value, buffer, offset) => {
      let windowId = value.windowId
      offset = (ctx.i8)(windowId, buffer, offset)
      let recipe = value.recipe
      offset = (ctx.string)(recipe, buffer, offset)
      let makeAll = value.makeAll
      offset = (ctx.bool)(makeAll, buffer, offset)
      return offset
    },
    packet_abilities: (value, buffer, offset) => {
      let flags = value.flags
      offset = (ctx.i8)(flags, buffer, offset)
      return offset
    },
    packet_block_dig: (value, buffer, offset) => {
      let status = value.status
      offset = (ctx.varint)(status, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let face = value.face
      offset = (ctx.i8)(face, buffer, offset)
      let sequence = value.sequence
      offset = (ctx.varint)(sequence, buffer, offset)
      return offset
    },
    packet_entity_action: (value, buffer, offset) => {
      let entityId = value.entityId
      offset = (ctx.varint)(entityId, buffer, offset)
      let actionId = value.actionId
      offset = (ctx.varint)(actionId, buffer, offset)
      let jumpBoost = value.jumpBoost
      offset = (ctx.varint)(jumpBoost, buffer, offset)
      return offset
    },
    packet_steer_vehicle: (value, buffer, offset) => {
      let sideways = value.sideways
      offset = (ctx.f32)(sideways, buffer, offset)
      let forward = value.forward
      offset = (ctx.f32)(forward, buffer, offset)
      let jump = value.jump
      offset = (ctx.u8)(jump, buffer, offset)
      return offset
    },
    packet_displayed_recipe: (value, buffer, offset) => {
      let recipeId = value.recipeId
      offset = (ctx.string)(recipeId, buffer, offset)
      return offset
    },
    packet_recipe_book: (value, buffer, offset) => {
      let bookId = value.bookId
      offset = (ctx.varint)(bookId, buffer, offset)
      let bookOpen = value.bookOpen
      offset = (ctx.bool)(bookOpen, buffer, offset)
      let filterActive = value.filterActive
      offset = (ctx.bool)(filterActive, buffer, offset)
      return offset
    },
    packet_resource_pack_receive: (value, buffer, offset) => {
      let result = value.result
      offset = (ctx.varint)(result, buffer, offset)
      return offset
    },
    packet_held_item_slot: (value, buffer, offset) => {
      let slotId = value.slotId
      offset = (ctx.i16)(slotId, buffer, offset)
      return offset
    },
    packet_set_creative_slot: (value, buffer, offset) => {
      let slot = value.slot
      offset = (ctx.i16)(slot, buffer, offset)
      let item = value.item
      offset = (ctx.slot)(item, buffer, offset)
      return offset
    },
    packet_update_jigsaw_block: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let name = value.name
      offset = (ctx.string)(name, buffer, offset)
      let target = value.target
      offset = (ctx.string)(target, buffer, offset)
      let pool = value.pool
      offset = (ctx.string)(pool, buffer, offset)
      let finalState = value.finalState
      offset = (ctx.string)(finalState, buffer, offset)
      let jointType = value.jointType
      offset = (ctx.string)(jointType, buffer, offset)
      return offset
    },
    packet_update_sign: (value, buffer, offset) => {
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let text1 = value.text1
      offset = (ctx.string)(text1, buffer, offset)
      let text2 = value.text2
      offset = (ctx.string)(text2, buffer, offset)
      let text3 = value.text3
      offset = (ctx.string)(text3, buffer, offset)
      let text4 = value.text4
      offset = (ctx.string)(text4, buffer, offset)
      return offset
    },
    packet_arm_animation: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      return offset
    },
    packet_spectate: (value, buffer, offset) => {
      let target = value.target
      offset = (ctx.UUID)(target, buffer, offset)
      return offset
    },
    packet_block_place: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      let location = value.location
      offset = (ctx.position)(location, buffer, offset)
      let direction = value.direction
      offset = (ctx.varint)(direction, buffer, offset)
      let cursorX = value.cursorX
      offset = (ctx.f32)(cursorX, buffer, offset)
      let cursorY = value.cursorY
      offset = (ctx.f32)(cursorY, buffer, offset)
      let cursorZ = value.cursorZ
      offset = (ctx.f32)(cursorZ, buffer, offset)
      let insideBlock = value.insideBlock
      offset = (ctx.bool)(insideBlock, buffer, offset)
      let sequence = value.sequence
      offset = (ctx.varint)(sequence, buffer, offset)
      return offset
    },
    packet_use_item: (value, buffer, offset) => {
      let hand = value.hand
      offset = (ctx.varint)(hand, buffer, offset)
      let sequence = value.sequence
      offset = (ctx.varint)(sequence, buffer, offset)
      return offset
    },
    packet_advancement_tab: (value, buffer, offset) => {
      let action = value.action
      offset = (ctx.varint)(action, buffer, offset)
      let tabId = value.tabId
      offset = ((value, buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(value, buffer, offset)
          case 1: return (ctx.void)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(tabId, buffer, offset)
      return offset
    },
    packet_pong: (value, buffer, offset) => {
      let id = value.id
      offset = (ctx.i32)(id, buffer, offset)
      return offset
    },
    packet_chat_session_update: (value, buffer, offset) => {
      let sessionUUID = value.sessionUUID
      offset = (ctx.UUID)(sessionUUID, buffer, offset)
      let expireTime = value.expireTime
      offset = (ctx.i64)(expireTime, buffer, offset)
      let publicKey = value.publicKey
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(publicKey, buffer, offset)
      let signature = value.signature
      offset = ((value, buffer, offset) => {
        if (!(value instanceof Buffer)) value = Buffer.from(value)
        offset = (ctx.varint)(value.length, buffer, offset)
        value.copy(buffer, offset)
        return offset + value.length
      })(signature, buffer, offset)
      return offset
    },
    packet: (value, buffer, offset) => {
      let name = value.name
      offset = ((value, buffer, offset) => {
        return (ctx.varint)({"teleport_confirm":0,"query_block_nbt":1,"set_difficulty":2,"message_acknowledgement":3,"chat_command":4,"chat_message":5,"chat_session_update":6,"client_command":7,"settings":8,"tab_complete":9,"enchant_item":10,"window_click":11,"close_window":12,"custom_payload":13,"edit_book":14,"query_entity_nbt":15,"use_entity":16,"generate_structure":17,"keep_alive":18,"lock_difficulty":19,"position":20,"position_look":21,"look":22,"flying":23,"vehicle_move":24,"steer_boat":25,"pick_item":26,"craft_recipe_request":27,"abilities":28,"block_dig":29,"entity_action":30,"steer_vehicle":31,"pong":32,"recipe_book":33,"displayed_recipe":34,"name_item":35,"resource_pack_receive":36,"advancement_tab":37,"select_trade":38,"set_beacon_effect":39,"held_item_slot":40,"update_command_block":41,"update_command_block_minecart":42,"set_creative_slot":43,"update_jigsaw_block":44,"update_structure_block":45,"update_sign":46,"arm_animation":47,"spectate":48,"block_place":49,"use_item":50}[value] || value, buffer, offset)
      })(name, buffer, offset)
      let params = value.params
      offset = ((value, buffer, offset) => {
        switch (name) {
          case "teleport_confirm": return (ctx.packet_teleport_confirm)(value, buffer, offset)
          case "query_block_nbt": return (ctx.packet_query_block_nbt)(value, buffer, offset)
          case "set_difficulty": return (ctx.packet_set_difficulty)(value, buffer, offset)
          case "message_acknowledgement": return (ctx.packet_message_acknowledgement)(value, buffer, offset)
          case "chat_command": return (ctx.packet_chat_command)(value, buffer, offset)
          case "chat_message": return (ctx.packet_chat_message)(value, buffer, offset)
          case "client_command": return (ctx.packet_client_command)(value, buffer, offset)
          case "settings": return (ctx.packet_settings)(value, buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(value, buffer, offset)
          case "enchant_item": return (ctx.packet_enchant_item)(value, buffer, offset)
          case "window_click": return (ctx.packet_window_click)(value, buffer, offset)
          case "close_window": return (ctx.packet_close_window)(value, buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(value, buffer, offset)
          case "edit_book": return (ctx.packet_edit_book)(value, buffer, offset)
          case "query_entity_nbt": return (ctx.packet_query_entity_nbt)(value, buffer, offset)
          case "use_entity": return (ctx.packet_use_entity)(value, buffer, offset)
          case "generate_structure": return (ctx.packet_generate_structure)(value, buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(value, buffer, offset)
          case "lock_difficulty": return (ctx.packet_lock_difficulty)(value, buffer, offset)
          case "position": return (ctx.packet_position)(value, buffer, offset)
          case "position_look": return (ctx.packet_position_look)(value, buffer, offset)
          case "look": return (ctx.packet_look)(value, buffer, offset)
          case "flying": return (ctx.packet_flying)(value, buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(value, buffer, offset)
          case "steer_boat": return (ctx.packet_steer_boat)(value, buffer, offset)
          case "pick_item": return (ctx.packet_pick_item)(value, buffer, offset)
          case "craft_recipe_request": return (ctx.packet_craft_recipe_request)(value, buffer, offset)
          case "abilities": return (ctx.packet_abilities)(value, buffer, offset)
          case "block_dig": return (ctx.packet_block_dig)(value, buffer, offset)
          case "entity_action": return (ctx.packet_entity_action)(value, buffer, offset)
          case "steer_vehicle": return (ctx.packet_steer_vehicle)(value, buffer, offset)
          case "pong": return (ctx.packet_pong)(value, buffer, offset)
          case "chat_session_update": return (ctx.packet_chat_session_update)(value, buffer, offset)
          case "recipe_book": return (ctx.packet_recipe_book)(value, buffer, offset)
          case "displayed_recipe": return (ctx.packet_displayed_recipe)(value, buffer, offset)
          case "name_item": return (ctx.packet_name_item)(value, buffer, offset)
          case "resource_pack_receive": return (ctx.packet_resource_pack_receive)(value, buffer, offset)
          case "advancement_tab": return (ctx.packet_advancement_tab)(value, buffer, offset)
          case "select_trade": return (ctx.packet_select_trade)(value, buffer, offset)
          case "set_beacon_effect": return (ctx.packet_set_beacon_effect)(value, buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(value, buffer, offset)
          case "update_command_block": return (ctx.packet_update_command_block)(value, buffer, offset)
          case "update_command_block_minecart": return (ctx.packet_update_command_block_minecart)(value, buffer, offset)
          case "set_creative_slot": return (ctx.packet_set_creative_slot)(value, buffer, offset)
          case "update_jigsaw_block": return (ctx.packet_update_jigsaw_block)(value, buffer, offset)
          case "update_structure_block": return (ctx.packet_update_structure_block)(value, buffer, offset)
          case "update_sign": return (ctx.packet_update_sign)(value, buffer, offset)
          case "arm_animation": return (ctx.packet_arm_animation)(value, buffer, offset)
          case "spectate": return (ctx.packet_spectate)(value, buffer, offset)
          case "block_place": return (ctx.packet_block_place)(value, buffer, offset)
          case "use_item": return (ctx.packet_use_item)(value, buffer, offset)
          default: return (ctx.void)(value, buffer, offset)
        }
      })(params, buffer, offset)
      return offset
    }
  }
  return ctx
}() => {
  const ctx = {
    i8: native.i8,
    u8: native.u8,
    i16: native.i16,
    u16: native.u16,
    i32: native.i32,
    u32: native.u32,
    f32: native.f32,
    f64: native.f64,
    li8: native.li8,
    lu8: native.lu8,
    li16: native.li16,
    lu16: native.lu16,
    li32: native.li32,
    lu32: native.lu32,
    lf32: native.lf32,
    lf64: native.lf64,
    i64: native.i64,
    li64: native.li64,
    u64: native.u64,
    lu64: native.lu64,
    varint: native.varint,
    bool: native.bool,
    pstring: native.pstring,
    buffer: native.buffer,
    void: native.void,
    bitfield: native.bitfield,
    cstring: native.cstring,
    mapper: native.mapper,
    varlong: native.varlong,
    UUID: native.UUID,
    restBuffer: native.restBuffer,
    nbt: native.nbt,
    optionalNbt: native.optionalNbt,
    compressedNbt: native.compressedNbt,
    optvarint: function () { return ctx.varint(...arguments) },
    option: native.option,
    entityMetadataLoop: native.entityMetadataLoop,
    topBitSetTerminatedArray: native.topBitSetTerminatedArray,
    container: native.container,
    switch: native.switch,
    array: native.array,
    string: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      offset += countSize
      if (offset + count > buffer.length) {
        throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))
      }
      return { value: buffer.toString("utf8", offset, offset + count), size: count + countSize }
    },
    vec3f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    vec4f: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f32)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f32)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f32)(buffer, offset + xSize + ySize)
      let { value: w, size: wSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, w }, size: xSize + ySize + zSize + wSize}
    },
    vec3f64: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      return { value: { x, y, z }, size: xSize + ySize + zSize}
    },
    slot: (buffer, offset) => {
      let { value: present, size: presentSize } = (ctx.bool)(buffer, offset)
      let { value: itemId, size: itemIdSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize)
      let { value: itemCount, size: itemCountSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.i8)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize)
      let { value: nbtData, size: nbtDataSize } = ((buffer, offset) => {
        switch (present) {
          case false: return (ctx.void)(buffer, offset)
          case true: return (ctx.optionalNbt)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + presentSize + itemIdSize + itemCountSize)
      return { value: { present, itemId, itemCount, nbtData }, size: presentSize + itemIdSize + itemCountSize + nbtDataSize}
    },
    particle: (buffer, offset) => {
      let { value: particleId, size: particleIdSize } = (ctx.varint)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.particleData)(buffer, offset + particleIdSize, particleId)
      return { value: { particleId, data }, size: particleIdSize + dataSize}
    },
    particleData: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case 2: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 3: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 14: return ((buffer, offset) => {
          let { value: red, size: redSize } = (ctx.f32)(buffer, offset)
          let { value: green, size: greenSize } = (ctx.f32)(buffer, offset + redSize)
          let { value: blue, size: blueSize } = (ctx.f32)(buffer, offset + redSize + greenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + redSize + greenSize + blueSize)
          return { value: { red, green, blue, scale }, size: redSize + greenSize + blueSize + scaleSize}
        })(buffer, offset)
        case 15: return ((buffer, offset) => {
          let { value: fromRed, size: fromRedSize } = (ctx.f32)(buffer, offset)
          let { value: fromGreen, size: fromGreenSize } = (ctx.f32)(buffer, offset + fromRedSize)
          let { value: fromBlue, size: fromBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize)
          let { value: scale, size: scaleSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize)
          let { value: toRed, size: toRedSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize)
          let { value: toGreen, size: toGreenSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize)
          let { value: toBlue, size: toBlueSize } = (ctx.f32)(buffer, offset + fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize)
          return { value: { fromRed, fromGreen, fromBlue, scale, toRed, toGreen, toBlue }, size: fromRedSize + fromGreenSize + fromBlueSize + scaleSize + toRedSize + toGreenSize + toBlueSize}
        })(buffer, offset)
        case 25: return ((buffer, offset) => {
          let { value: blockState, size: blockStateSize } = (ctx.varint)(buffer, offset)
          return { value: { blockState }, size: blockStateSize}
        })(buffer, offset)
        case 33: return ((buffer, offset) => {
          let { value: rotation, size: rotationSize } = (ctx.f32)(buffer, offset)
          return { value: { rotation }, size: rotationSize}
        })(buffer, offset)
        case 42: return ((buffer, offset) => {
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset)
          return { value: { item }, size: itemSize}
        })(buffer, offset)
        case 43: return ((buffer, offset) => {
          let { value: positionType, size: positionTypeSize } = (ctx.string)(buffer, offset)
          let { value: entityId, size: entityIdSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize)
          let { value: entityEyeHeight, size: entityEyeHeightSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize)
          let { value: destination, size: destinationSize } = ((buffer, offset) => {
            switch (positionType) {
              case "minecraft:block": return (ctx.position)(buffer, offset)
              case "minecraft:entity": return (ctx.varint)(buffer, offset)
              default: return (ctx.void)(buffer, offset)
            }
          })(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize)
          let { value: ticks, size: ticksSize } = (ctx.varint)(buffer, offset + positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize)
          return { value: { positionType, entityId, entityEyeHeight, destination, ticks }, size: positionTypeSize + entityIdSize + entityEyeHeightSize + destinationSize + ticksSize}
        })(buffer, offset)
        case 95: return ((buffer, offset) => {
          let { value: delayInTicksBeforeShown, size: delayInTicksBeforeShownSize } = (ctx.varint)(buffer, offset)
          return { value: { delayInTicksBeforeShown }, size: delayInTicksBeforeShownSize}
        })(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    ingredient: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = (ctx.slot)(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    position: (buffer, offset) => {
      if ( offset + 8 > buffer.length) { throw new PartialReadError() }
      let bits = buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let x = (bits >> 6) & 0x3ffffff
      x -= (x & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      bits = (bits << 8) | buffer[offset++]
      let z = (bits >> 4) & 0x3ffffff
      z -= (z & 0x2000000) << 1
      bits = (bits << 8) | buffer[offset++]
      let y = (bits >> 0) & 0xfff
      y -= (y & 0x800) << 1
      return { value: { x, z, y }, size: 8 }
    },
    previousMessages: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: id, size: idSize } = (ctx.varint)(buffer, offset)
        let { value: signature, size: signatureSize } = ((buffer, offset) => {
          switch (id) {
            case 0: return ((buffer, offset) => {
              const count = 256
              const countSize = 0
              offset += countSize
              if (offset + count > buffer.length) {
                throw new PartialReadError()
              }
              return { value: buffer.slice(offset, offset + count), size: count + countSize }
            })(buffer, offset)
            default: return (ctx.void)(buffer, offset)
          }
        })(buffer, offset + idSize)
        return { value: { id, signature }, size: idSize + signatureSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    entityMetadataItem: (buffer, offset, $compareTo) => {
      switch ($compareTo) {
        case "byte": return (ctx.i8)(buffer, offset)
        case "int": return (ctx.varint)(buffer, offset)
        case "long": return (ctx.varlong)(buffer, offset)
        case "float": return (ctx.f32)(buffer, offset)
        case "string": return (ctx.string)(buffer, offset)
        case "component": return (ctx.string)(buffer, offset)
        case "optional_component": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "item_stack": return (ctx.slot)(buffer, offset)
        case "boolean": return (ctx.bool)(buffer, offset)
        case "rotations": return ((buffer, offset) => {
          let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset)
          let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + pitchSize)
          let { value: roll, size: rollSize } = (ctx.f32)(buffer, offset + pitchSize + yawSize)
          return { value: { pitch, yaw, roll }, size: pitchSize + yawSize + rollSize}
        })(buffer, offset)
        case "block_pos": return (ctx.position)(buffer, offset)
        case "optional_block_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.position)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "direction": return (ctx.varint)(buffer, offset)
        case "optional_uuid": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.UUID)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "block_state": return (ctx.varint)(buffer, offset)
        case "optional_block_state": return (ctx.optvarint)(buffer, offset)
        case "compound_tag": return (ctx.nbt)(buffer, offset)
        case "particle": return (ctx.particle)(buffer, offset)
        case "villager_data": return ((buffer, offset) => {
          let { value: villagerType, size: villagerTypeSize } = (ctx.varint)(buffer, offset)
          let { value: villagerProfession, size: villagerProfessionSize } = (ctx.varint)(buffer, offset + villagerTypeSize)
          let { value: level, size: levelSize } = (ctx.varint)(buffer, offset + villagerTypeSize + villagerProfessionSize)
          return { value: { villagerType, villagerProfession, level }, size: villagerTypeSize + villagerProfessionSize + levelSize}
        })(buffer, offset)
        case "optional_unsigned_int": return (ctx.optvarint)(buffer, offset)
        case "pose": return (ctx.varint)(buffer, offset)
        case "cat_variant": return (ctx.varint)(buffer, offset)
        case "frog_variant": return (ctx.varint)(buffer, offset)
        case "optional_global_pos": return ((buffer, offset) => {
          const {value} = ctx.bool(buffer, offset)
          if (value) {
            const { value, size } = (ctx.string)(buffer, offset + 1)
            return { value, size: size + 1 }
          }
          return { value: undefined, size: 1}
        })(buffer, offset)
        case "painting_variant": return (ctx.varint)(buffer, offset)
        case "sniffer_state": return (ctx.varint)(buffer, offset)
        case "vector3": return (ctx.vec3f)(buffer, offset)
        case "quaternion": return (ctx.vec4f)(buffer, offset)
        default: return (ctx.void)(buffer, offset)
      }
    },
    entityMetadata: (buffer, offset) => {
      let cursor = offset
      const data = []
      while (true) {
        if (ctx.u8(buffer, cursor).value === 255) return { value: data, size: cursor + 1 - offset }
        const elem = ((buffer, offset) => {
        let { value: key, size: keySize } = (ctx.u8)(buffer, offset)
        let { value: type, size: typeSize } = ((buffer, offset) => {
          const { value, size } = (ctx.varint)(buffer, offset)
          return { value: {"0":"byte","1":"int","2":"long","3":"float","4":"string","5":"component","6":"optional_component","7":"item_stack","8":"boolean","9":"rotations","10":"block_pos","11":"optional_block_pos","12":"direction","13":"optional_uuid","14":"block_state","15":"optional_block_state","16":"compound_tag","17":"particle","18":"villager_data","19":"optional_unsigned_int","20":"pose","21":"cat_variant","22":"frog_variant","23":"optional_global_pos","24":"painting_variant","25":"sniffer_state","26":"vector3","27":"quaternion"}[value] || value, size }
        })(buffer, offset + keySize)
        let { value: value1, size: value1Size } = (ctx.entityMetadataItem)(buffer, offset + keySize + typeSize, type)
        return { value: { key, type, value: value1 }, size: keySize + typeSize + value1Size}
      })(buffer, cursor)
        data.push(elem.value)
        cursor += elem.size
      }
    },
    minecraft_simple_recipe_format: (buffer, offset) => {
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset)
      return { value: { category }, size: categorySize}
    },
    minecraft_smelting_format: (buffer, offset) => {
      let { value: group, size: groupSize } = (ctx.string)(buffer, offset)
      let { value: category, size: categorySize } = (ctx.varint)(buffer, offset + groupSize)
      let { value: ingredient, size: ingredientSize } = (ctx.ingredient)(buffer, offset + groupSize + categorySize)
      let { value: result, size: resultSize } = (ctx.slot)(buffer, offset + groupSize + categorySize + ingredientSize)
      let { value: experience, size: experienceSize } = (ctx.f32)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize)
      let { value: cookTime, size: cookTimeSize } = (ctx.varint)(buffer, offset + groupSize + categorySize + ingredientSize + resultSize + experienceSize)
      return { value: { group, category, ingredient, result, experience, cookTime }, size: groupSize + categorySize + ingredientSize + resultSize + experienceSize + cookTimeSize}
    },
    tags: (buffer, offset) => {
      const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
      const data = []
      let size = countSize
      for (let i = 0; i < count; i++) {
        const elem = ((buffer, offset) => {
        let { value: tagName, size: tagNameSize } = (ctx.string)(buffer, offset)
        let { value: entries, size: entriesSize } = ((buffer, offset) => {
          const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
          if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
          const data = []
          let size = countSize
          for (let i = 0; i < count; i++) {
            const elem = (ctx.varint)(buffer, offset + size)
            data.push(elem.value)
            size += elem.size
          }
          return { value: data, size }
        })(buffer, offset + tagNameSize)
        return { value: { tagName, entries }, size: tagNameSize + entriesSize}
      })(buffer, offset + size)
        data.push(elem.value)
        size += elem.size
      }
      return { value: data, size }
    },
    chunkBlockEntity: (buffer, offset) => {
      let { value: {x, z}, size: anon0Size } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let x = (bits >> 4) & 0xf
        let z = (bits >> 0) & 0xf
        return { value: { x, z }, size: 1 }
      })(buffer, offset)
      let { value: y, size: ySize } = (ctx.i16)(buffer, offset + anon0Size)
      let { value: type, size: typeSize } = (ctx.varint)(buffer, offset + anon0Size + ySize)
      let { value: nbtData, size: nbtDataSize } = (ctx.optionalNbt)(buffer, offset + anon0Size + ySize + typeSize)
      return { value: { x, z, y, type, nbtData }, size: anon0Size + ySize + typeSize + nbtDataSize}
    },
    chat_session: (buffer, offset) => {
      const {value} = ctx.bool(buffer, offset)
      if (value) {
        const { value, size } = ((buffer, offset) => {
        let { value: uuid, size: uuidSize } = (ctx.UUID)(buffer, offset)
        let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
          let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset)
          let { value: keyBytes, size: keyBytesSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize)
          let { value: keySignature, size: keySignatureSize } = ((buffer, offset) => {
            const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + expireTimeSize + keyBytesSize)
          return { value: { expireTime, keyBytes, keySignature }, size: expireTimeSize + keyBytesSize + keySignatureSize}
        })(buffer, offset + uuidSize)
        return { value: { uuid, publicKey }, size: uuidSize + publicKeySize}
      })(buffer, offset + 1)
        return { value, size: size + 1 }
      }
      return { value: undefined, size: 1}
    },
    game_profile: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      let { value: properties, size: propertiesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: key, size: keySize } = (ctx.string)(buffer, offset)
          let { value: value1, size: value1Size } = (ctx.string)(buffer, offset + keySize)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const {value} = ctx.bool(buffer, offset)
            if (value) {
              const { value, size } = (ctx.string)(buffer, offset + 1)
              return { value, size: size + 1 }
            }
            return { value: undefined, size: 1}
          })(buffer, offset + keySize + value1Size)
          return { value: { key, value: value1, signature }, size: keySize + value1Size + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + nameSize)
      return { value: { name, properties }, size: nameSize + propertiesSize}
    },
    command_node: (buffer, offset) => {
      let { value: flags, size: flagsSize } = ((buffer, offset) => {
        if ( offset + 1 > buffer.length) { throw new PartialReadError() }
        let bits = buffer[offset++]
        let unused = (bits >> 5) & 0x7
        let has_custom_suggestions = (bits >> 4) & 0x1
        let has_redirect_node = (bits >> 3) & 0x1
        let has_command = (bits >> 2) & 0x1
        let command_node_type = (bits >> 0) & 0x3
        return { value: { unused, has_custom_suggestions, has_redirect_node, has_command, command_node_type }, size: 1 }
      })(buffer, offset)
      let { value: children, size: childrenSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.varint)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + flagsSize)
      let { value: redirectNode, size: redirectNodeSize } = ((buffer, offset) => {
        switch (flags.has_redirect_node) {
          case 1: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize)
      let { value: extraNodeData, size: extraNodeDataSize } = ((buffer, offset) => {
        switch (flags.command_node_type) {
          case 0: return (ctx.void)(buffer, offset)
          case 1: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            return { value: { name: name1 }, size: name1Size}
          })(buffer, offset)
          case 2: return ((buffer, offset) => {
            let { value: name1, size: name1Size } = (ctx.string)(buffer, offset)
            let { value: parser, size: parserSize } = ((buffer, offset) => {
              const { value, size } = (ctx.varint)(buffer, offset)
              return { value: {"0":"brigadier:bool","1":"brigadier:float","2":"brigadier:double","3":"brigadier:integer","4":"brigadier:long","5":"brigadier:string","6":"minecraft:entity","7":"minecraft:game_profile","8":"minecraft:block_pos","9":"minecraft:column_pos","10":"minecraft:vec3","11":"minecraft:vec2","12":"minecraft:block_state","13":"minecraft:block_predicate","14":"minecraft:item_stack","15":"minecraft:item_predicate","16":"minecraft:color","17":"minecraft:component","18":"minecraft:message","19":"minecraft:nbt","20":"minecraft:nbt_tag","21":"minecraft:nbt_path","22":"minecraft:objective","23":"minecraft:objective_criteria","24":"minecraft:operation","25":"minecraft:particle","26":"minecraft:angle","27":"minecraft:rotation","28":"minecraft:scoreboard_slot","29":"minecraft:score_holder","30":"minecraft:swizzle","31":"minecraft:team","32":"minecraft:item_slot","33":"minecraft:resource_location","34":"minecraft:function","35":"minecraft:entity_anchor","36":"minecraft:int_range","37":"minecraft:float_range","38":"minecraft:dimension","39":"minecraft:gamemode","40":"minecraft:time","41":"minecraft:resource_or_tag","42":"minecraft:resource_or_tag_key","43":"minecraft:resource","44":"minecraft:resource_key","45":"minecraft:template_mirror","46":"minecraft:template_rotation","47":"minecraft:heightmap","48":"minecraft:uuid"}[value] || value, size }
            })(buffer, offset + name1Size)
            let { value: properties1, size: properties1Size } = ((buffer, offset) => {
              switch (parser) {
                case "brigadier:bool": return (ctx.void)(buffer, offset)
                case "brigadier:float": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:double": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.f64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:integer": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i32)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:long": return ((buffer, offset) => {
                  let { value: flags1, size: flags1Size } = ((buffer, offset) => {
                    if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                    let bits = buffer[offset++]
                    let unused1 = (bits >> 2) & 0x3f
                    let max_present = (bits >> 1) & 0x1
                    let min_present = (bits >> 0) & 0x1
                    return { value: { unused: unused1, max_present, min_present }, size: 1 }
                  })(buffer, offset)
                  let { value: min, size: minSize } = ((buffer, offset) => {
                    switch (flags1.min_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size)
                  let { value: max, size: maxSize } = ((buffer, offset) => {
                    switch (flags1.max_present) {
                      case 1: return (ctx.i64)(buffer, offset)
                      default: return (ctx.void)(buffer, offset)
                    }
                  })(buffer, offset + flags1Size + minSize)
                  return { value: { flags: flags1, min, max }, size: flags1Size + minSize + maxSize}
                })(buffer, offset)
                case "brigadier:string": return ((buffer, offset) => {
                  const { value, size } = (ctx.varint)(buffer, offset)
                  return { value: {"0":"SINGLE_WORD","1":"QUOTABLE_PHRASE","2":"GREEDY_PHRASE"}[value] || value, size }
                })(buffer, offset)
                case "minecraft:entity": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 2) & 0x3f
                  let onlyAllowPlayers = (bits >> 1) & 0x1
                  let onlyAllowEntities = (bits >> 0) & 0x1
                  return { value: { unused: unused1, onlyAllowPlayers, onlyAllowEntities }, size: 1 }
                })(buffer, offset)
                case "minecraft:game_profile": return (ctx.void)(buffer, offset)
                case "minecraft:block_pos": return (ctx.void)(buffer, offset)
                case "minecraft:column_pos": return (ctx.void)(buffer, offset)
                case "minecraft:vec3": return (ctx.void)(buffer, offset)
                case "minecraft:vec2": return (ctx.void)(buffer, offset)
                case "minecraft:block_state": return (ctx.void)(buffer, offset)
                case "minecraft:block_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:item_stack": return (ctx.void)(buffer, offset)
                case "minecraft:item_predicate": return (ctx.void)(buffer, offset)
                case "minecraft:color": return (ctx.void)(buffer, offset)
                case "minecraft:component": return (ctx.void)(buffer, offset)
                case "minecraft:message": return (ctx.void)(buffer, offset)
                case "minecraft:nbt": return (ctx.void)(buffer, offset)
                case "minecraft:nbt_path": return (ctx.void)(buffer, offset)
                case "minecraft:objective": return (ctx.void)(buffer, offset)
                case "minecraft:objective_criteria": return (ctx.void)(buffer, offset)
                case "minecraft:operation": return (ctx.void)(buffer, offset)
                case "minecraft:particle": return (ctx.void)(buffer, offset)
                case "minecraft:angle": return (ctx.void)(buffer, offset)
                case "minecraft:rotation": return (ctx.void)(buffer, offset)
                case "minecraft:scoreboard_slot": return (ctx.void)(buffer, offset)
                case "minecraft:score_holder": return ((buffer, offset) => {
                  if ( offset + 1 > buffer.length) { throw new PartialReadError() }
                  let bits = buffer[offset++]
                  let unused1 = (bits >> 1) & 0x7f
                  let allowMultiple = (bits >> 0) & 0x1
                  return { value: { unused: unused1, allowMultiple }, size: 1 }
                })(buffer, offset)
                case "minecraft:swizzle": return (ctx.void)(buffer, offset)
                case "minecraft:team": return (ctx.void)(buffer, offset)
                case "minecraft:item_slot": return (ctx.void)(buffer, offset)
                case "minecraft:resource_location": return (ctx.void)(buffer, offset)
                case "minecraft:function": return (ctx.void)(buffer, offset)
                case "minecraft:entity_anchor": return (ctx.void)(buffer, offset)
                case "minecraft:int_range": return (ctx.void)(buffer, offset)
                case "minecraft:float_range": return (ctx.void)(buffer, offset)
                case "minecraft:dimension": return (ctx.void)(buffer, offset)
                case "minecraft:gamemode": return (ctx.void)(buffer, offset)
                case "minecraft:time": return ((buffer, offset) => {
                  let { value: min, size: minSize } = (ctx.i32)(buffer, offset)
                  return { value: { min }, size: minSize}
                })(buffer, offset)
                case "minecraft:resource_or_tag": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_or_tag_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:resource_key": return ((buffer, offset) => {
                  let { value: registry, size: registrySize } = (ctx.string)(buffer, offset)
                  return { value: { registry }, size: registrySize}
                })(buffer, offset)
                case "minecraft:template_mirror": return (ctx.void)(buffer, offset)
                case "minecraft:template_rotation": return (ctx.void)(buffer, offset)
                case "minecraft:heightmap": return (ctx.void)(buffer, offset)
                case "minecraft:uuid": return (ctx.void)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize)
            let { value: suggestionType, size: suggestionTypeSize } = ((buffer, offset) => {
              switch (flags.has_custom_suggestions) {
                case 1: return (ctx.string)(buffer, offset)
                default: return (ctx.void)(buffer, offset)
              }
            })(buffer, offset + name1Size + parserSize + properties1Size)
            return { value: { name: name1, parser, properties: properties1, suggestionType }, size: name1Size + parserSize + properties1Size + suggestionTypeSize}
          })(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + flagsSize + childrenSize + redirectNodeSize)
      return { value: { flags, children, redirectNode, extraNodeData }, size: flagsSize + childrenSize + redirectNodeSize + extraNodeDataSize}
    },
    packet_teleport_confirm: (buffer, offset) => {
      let { value: teleportId, size: teleportIdSize } = (ctx.varint)(buffer, offset)
      return { value: { teleportId }, size: teleportIdSize}
    },
    packet_query_block_nbt: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + transactionIdSize)
      return { value: { transactionId, location }, size: transactionIdSize + locationSize}
    },
    packet_chat_command: (buffer, offset) => {
      let { value: command, size: commandSize } = (ctx.string)(buffer, offset)
      let { value: timestamp, size: timestampSize } = (ctx.i64)(buffer, offset + commandSize)
      let { value: salt, size: saltSize } = (ctx.i64)(buffer, offset + commandSize + timestampSize)
      let { value: argumentSignatures, size: argumentSignaturesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: argumentName, size: argumentNameSize } = (ctx.string)(buffer, offset)
          let { value: signature, size: signatureSize } = ((buffer, offset) => {
            const count = 256
            const countSize = 0
            offset += countSize
            if (offset + count > buffer.length) {
              throw new PartialReadError()
            }
            return { value: buffer.slice(offset, offset + count), size: count + countSize }
          })(buffer, offset + argumentNameSize)
          return { value: { argumentName, signature }, size: argumentNameSize + signatureSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + commandSize + timestampSize + saltSize)
      let { value: messageCount, size: messageCountSize } = (ctx.varint)(buffer, offset + commandSize + timestampSize + saltSize + argumentSignaturesSize)
      let { value: acknowledged, size: acknowledgedSize } = ((buffer, offset) => {
        const count = 3
        const countSize = 0
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + commandSize + timestampSize + saltSize + argumentSignaturesSize + messageCountSize)
      return { value: { command, timestamp, salt, argumentSignatures, messageCount, acknowledged }, size: commandSize + timestampSize + saltSize + argumentSignaturesSize + messageCountSize + acknowledgedSize}
    },
    packet_chat_message: (buffer, offset) => {
      let { value: message, size: messageSize } = (ctx.string)(buffer, offset)
      let { value: timestamp, size: timestampSize } = (ctx.i64)(buffer, offset + messageSize)
      let { value: salt, size: saltSize } = (ctx.i64)(buffer, offset + messageSize + timestampSize)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = ((buffer, offset) => {
          const count = 256
          const countSize = 0
          offset += countSize
          if (offset + count > buffer.length) {
            throw new PartialReadError()
          }
          return { value: buffer.slice(offset, offset + count), size: count + countSize }
        })(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + messageSize + timestampSize + saltSize)
      let { value: offset1, size: offset1Size } = (ctx.varint)(buffer, offset + messageSize + timestampSize + saltSize + signatureSize)
      let { value: acknowledged, size: acknowledgedSize } = ((buffer, offset) => {
        const count = 3
        const countSize = 0
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + messageSize + timestampSize + saltSize + signatureSize + offset1Size)
      return { value: { message, timestamp, salt, signature, offset: offset1, acknowledged }, size: messageSize + timestampSize + saltSize + signatureSize + offset1Size + acknowledgedSize}
    },
    packet_set_difficulty: (buffer, offset) => {
      let { value: newDifficulty, size: newDifficultySize } = (ctx.u8)(buffer, offset)
      return { value: { newDifficulty }, size: newDifficultySize}
    },
    packet_message_acknowledgement: (buffer, offset) => {
      let { value: count, size: countSize } = (ctx.varint)(buffer, offset)
      return { value: { count }, size: countSize}
    },
    packet_edit_book: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      let { value: pages, size: pagesSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = (ctx.string)(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + handSize)
      let { value: title, size: titleSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.string)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + handSize + pagesSize)
      return { value: { hand, pages, title }, size: handSize + pagesSize + titleSize}
    },
    packet_query_entity_nbt: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset + transactionIdSize)
      return { value: { transactionId, entityId }, size: transactionIdSize + entityIdSize}
    },
    packet_pick_item: (buffer, offset) => {
      let { value: slot, size: slotSize } = (ctx.varint)(buffer, offset)
      return { value: { slot }, size: slotSize}
    },
    packet_name_item: (buffer, offset) => {
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset)
      return { value: { name }, size: nameSize}
    },
    packet_select_trade: (buffer, offset) => {
      let { value: slot, size: slotSize } = (ctx.varint)(buffer, offset)
      return { value: { slot }, size: slotSize}
    },
    packet_set_beacon_effect: (buffer, offset) => {
      let { value: primary_effect, size: primary_effectSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.varint)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset)
      let { value: secondary_effect, size: secondary_effectSize } = ((buffer, offset) => {
        const {value} = ctx.bool(buffer, offset)
        if (value) {
          const { value, size } = (ctx.varint)(buffer, offset + 1)
          return { value, size: size + 1 }
        }
        return { value: undefined, size: 1}
      })(buffer, offset + primary_effectSize)
      return { value: { primary_effect, secondary_effect }, size: primary_effectSize + secondary_effectSize}
    },
    packet_update_command_block: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: command, size: commandSize } = (ctx.string)(buffer, offset + locationSize)
      let { value: mode, size: modeSize } = (ctx.varint)(buffer, offset + locationSize + commandSize)
      let { value: flags, size: flagsSize } = (ctx.u8)(buffer, offset + locationSize + commandSize + modeSize)
      return { value: { location, command, mode, flags }, size: locationSize + commandSize + modeSize + flagsSize}
    },
    packet_update_command_block_minecart: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: command, size: commandSize } = (ctx.string)(buffer, offset + entityIdSize)
      let { value: track_output, size: track_outputSize } = (ctx.bool)(buffer, offset + entityIdSize + commandSize)
      return { value: { entityId, command, track_output }, size: entityIdSize + commandSize + track_outputSize}
    },
    packet_update_structure_block: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset + locationSize)
      let { value: mode, size: modeSize } = (ctx.varint)(buffer, offset + locationSize + actionSize)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + locationSize + actionSize + modeSize)
      let { value: offset_x, size: offset_xSize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize)
      let { value: offset_y, size: offset_ySize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize)
      let { value: offset_z, size: offset_zSize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize)
      let { value: size_x, size: size_xSize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize)
      let { value: size_y, size: size_ySize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize)
      let { value: size_z, size: size_zSize } = (ctx.i8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize)
      let { value: mirror, size: mirrorSize } = (ctx.varint)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize)
      let { value: rotation, size: rotationSize } = (ctx.varint)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize)
      let { value: metadata, size: metadataSize } = (ctx.string)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize + rotationSize)
      let { value: integrity, size: integritySize } = (ctx.f32)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize + rotationSize + metadataSize)
      let { value: seed, size: seedSize } = (ctx.varint)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize + rotationSize + metadataSize + integritySize)
      let { value: flags, size: flagsSize } = (ctx.u8)(buffer, offset + locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize + rotationSize + metadataSize + integritySize + seedSize)
      return { value: { location, action, mode, name, offset_x, offset_y, offset_z, size_x, size_y, size_z, mirror, rotation, metadata, integrity, seed, flags }, size: locationSize + actionSize + modeSize + nameSize + offset_xSize + offset_ySize + offset_zSize + size_xSize + size_ySize + size_zSize + mirrorSize + rotationSize + metadataSize + integritySize + seedSize + flagsSize}
    },
    packet_tab_complete: (buffer, offset) => {
      let { value: transactionId, size: transactionIdSize } = (ctx.varint)(buffer, offset)
      let { value: text, size: textSize } = (ctx.string)(buffer, offset + transactionIdSize)
      return { value: { transactionId, text }, size: transactionIdSize + textSize}
    },
    packet_client_command: (buffer, offset) => {
      let { value: actionId, size: actionIdSize } = (ctx.varint)(buffer, offset)
      return { value: { actionId }, size: actionIdSize}
    },
    packet_settings: (buffer, offset) => {
      let { value: locale, size: localeSize } = (ctx.string)(buffer, offset)
      let { value: viewDistance, size: viewDistanceSize } = (ctx.i8)(buffer, offset + localeSize)
      let { value: chatFlags, size: chatFlagsSize } = (ctx.varint)(buffer, offset + localeSize + viewDistanceSize)
      let { value: chatColors, size: chatColorsSize } = (ctx.bool)(buffer, offset + localeSize + viewDistanceSize + chatFlagsSize)
      let { value: skinParts, size: skinPartsSize } = (ctx.u8)(buffer, offset + localeSize + viewDistanceSize + chatFlagsSize + chatColorsSize)
      let { value: mainHand, size: mainHandSize } = (ctx.varint)(buffer, offset + localeSize + viewDistanceSize + chatFlagsSize + chatColorsSize + skinPartsSize)
      let { value: enableTextFiltering, size: enableTextFilteringSize } = (ctx.bool)(buffer, offset + localeSize + viewDistanceSize + chatFlagsSize + chatColorsSize + skinPartsSize + mainHandSize)
      let { value: enableServerListing, size: enableServerListingSize } = (ctx.bool)(buffer, offset + localeSize + viewDistanceSize + chatFlagsSize + chatColorsSize + skinPartsSize + mainHandSize + enableTextFilteringSize)
      return { value: { locale, viewDistance, chatFlags, chatColors, skinParts, mainHand, enableTextFiltering, enableServerListing }, size: localeSize + viewDistanceSize + chatFlagsSize + chatColorsSize + skinPartsSize + mainHandSize + enableTextFilteringSize + enableServerListingSize}
    },
    packet_enchant_item: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: enchantment, size: enchantmentSize } = (ctx.i8)(buffer, offset + windowIdSize)
      return { value: { windowId, enchantment }, size: windowIdSize + enchantmentSize}
    },
    packet_window_click: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      let { value: stateId, size: stateIdSize } = (ctx.varint)(buffer, offset + windowIdSize)
      let { value: slot, size: slotSize } = (ctx.i16)(buffer, offset + windowIdSize + stateIdSize)
      let { value: mouseButton, size: mouseButtonSize } = (ctx.i8)(buffer, offset + windowIdSize + stateIdSize + slotSize)
      let { value: mode, size: modeSize } = (ctx.varint)(buffer, offset + windowIdSize + stateIdSize + slotSize + mouseButtonSize)
      let { value: changedSlots, size: changedSlotsSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)
        const data = []
        let size = countSize
        for (let i = 0; i < count; i++) {
          const elem = ((buffer, offset) => {
          let { value: location1, size: location1Size } = (ctx.i16)(buffer, offset)
          let { value: item, size: itemSize } = (ctx.slot)(buffer, offset + location1Size)
          return { value: { location: location1, item }, size: location1Size + itemSize}
        })(buffer, offset + size)
          data.push(elem.value)
          size += elem.size
        }
        return { value: data, size }
      })(buffer, offset + windowIdSize + stateIdSize + slotSize + mouseButtonSize + modeSize)
      let { value: cursorItem, size: cursorItemSize } = (ctx.slot)(buffer, offset + windowIdSize + stateIdSize + slotSize + mouseButtonSize + modeSize + changedSlotsSize)
      return { value: { windowId, stateId, slot, mouseButton, mode, changedSlots, cursorItem }, size: windowIdSize + stateIdSize + slotSize + mouseButtonSize + modeSize + changedSlotsSize + cursorItemSize}
    },
    packet_close_window: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.u8)(buffer, offset)
      return { value: { windowId }, size: windowIdSize}
    },
    packet_custom_payload: (buffer, offset) => {
      let { value: channel, size: channelSize } = (ctx.string)(buffer, offset)
      let { value: data, size: dataSize } = (ctx.restBuffer)(buffer, offset + channelSize)
      return { value: { channel, data }, size: channelSize + dataSize}
    },
    packet_use_entity: (buffer, offset) => {
      let { value: target, size: targetSize } = (ctx.varint)(buffer, offset)
      let { value: mouse, size: mouseSize } = (ctx.varint)(buffer, offset + targetSize)
      let { value: x, size: xSize } = ((buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + targetSize + mouseSize)
      let { value: y, size: ySize } = ((buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + targetSize + mouseSize + xSize)
      let { value: z, size: zSize } = ((buffer, offset) => {
        switch (mouse) {
          case 2: return (ctx.f32)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + targetSize + mouseSize + xSize + ySize)
      let { value: hand, size: handSize } = ((buffer, offset) => {
        switch (mouse) {
          case 0: return (ctx.varint)(buffer, offset)
          case 2: return (ctx.varint)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + targetSize + mouseSize + xSize + ySize + zSize)
      let { value: sneaking, size: sneakingSize } = (ctx.bool)(buffer, offset + targetSize + mouseSize + xSize + ySize + zSize + handSize)
      return { value: { target, mouse, x, y, z, hand, sneaking }, size: targetSize + mouseSize + xSize + ySize + zSize + handSize + sneakingSize}
    },
    packet_generate_structure: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: levels, size: levelsSize } = (ctx.varint)(buffer, offset + locationSize)
      let { value: keepJigsaws, size: keepJigsawsSize } = (ctx.bool)(buffer, offset + locationSize + levelsSize)
      return { value: { location, levels, keepJigsaws }, size: locationSize + levelsSize + keepJigsawsSize}
    },
    packet_keep_alive: (buffer, offset) => {
      let { value: keepAliveId, size: keepAliveIdSize } = (ctx.i64)(buffer, offset)
      return { value: { keepAliveId }, size: keepAliveIdSize}
    },
    packet_lock_difficulty: (buffer, offset) => {
      let { value: locked, size: lockedSize } = (ctx.bool)(buffer, offset)
      return { value: { locked }, size: lockedSize}
    },
    packet_position: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + xSize + ySize + zSize)
      return { value: { x, y, z, onGround }, size: xSize + ySize + zSize + onGroundSize}
    },
    packet_position_look: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + xSize + ySize + zSize + yawSize + pitchSize)
      return { value: { x, y, z, yaw, pitch, onGround }, size: xSize + ySize + zSize + yawSize + pitchSize + onGroundSize}
    },
    packet_look: (buffer, offset) => {
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + yawSize)
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset + yawSize + pitchSize)
      return { value: { yaw, pitch, onGround }, size: yawSize + pitchSize + onGroundSize}
    },
    packet_flying: (buffer, offset) => {
      let { value: onGround, size: onGroundSize } = (ctx.bool)(buffer, offset)
      return { value: { onGround }, size: onGroundSize}
    },
    packet_vehicle_move: (buffer, offset) => {
      let { value: x, size: xSize } = (ctx.f64)(buffer, offset)
      let { value: y, size: ySize } = (ctx.f64)(buffer, offset + xSize)
      let { value: z, size: zSize } = (ctx.f64)(buffer, offset + xSize + ySize)
      let { value: yaw, size: yawSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize)
      let { value: pitch, size: pitchSize } = (ctx.f32)(buffer, offset + xSize + ySize + zSize + yawSize)
      return { value: { x, y, z, yaw, pitch }, size: xSize + ySize + zSize + yawSize + pitchSize}
    },
    packet_steer_boat: (buffer, offset) => {
      let { value: leftPaddle, size: leftPaddleSize } = (ctx.bool)(buffer, offset)
      let { value: rightPaddle, size: rightPaddleSize } = (ctx.bool)(buffer, offset + leftPaddleSize)
      return { value: { leftPaddle, rightPaddle }, size: leftPaddleSize + rightPaddleSize}
    },
    packet_craft_recipe_request: (buffer, offset) => {
      let { value: windowId, size: windowIdSize } = (ctx.i8)(buffer, offset)
      let { value: recipe, size: recipeSize } = (ctx.string)(buffer, offset + windowIdSize)
      let { value: makeAll, size: makeAllSize } = (ctx.bool)(buffer, offset + windowIdSize + recipeSize)
      return { value: { windowId, recipe, makeAll }, size: windowIdSize + recipeSize + makeAllSize}
    },
    packet_abilities: (buffer, offset) => {
      let { value: flags, size: flagsSize } = (ctx.i8)(buffer, offset)
      return { value: { flags }, size: flagsSize}
    },
    packet_block_dig: (buffer, offset) => {
      let { value: status, size: statusSize } = (ctx.varint)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + statusSize)
      let { value: face, size: faceSize } = (ctx.i8)(buffer, offset + statusSize + locationSize)
      let { value: sequence, size: sequenceSize } = (ctx.varint)(buffer, offset + statusSize + locationSize + faceSize)
      return { value: { status, location, face, sequence }, size: statusSize + locationSize + faceSize + sequenceSize}
    },
    packet_entity_action: (buffer, offset) => {
      let { value: entityId, size: entityIdSize } = (ctx.varint)(buffer, offset)
      let { value: actionId, size: actionIdSize } = (ctx.varint)(buffer, offset + entityIdSize)
      let { value: jumpBoost, size: jumpBoostSize } = (ctx.varint)(buffer, offset + entityIdSize + actionIdSize)
      return { value: { entityId, actionId, jumpBoost }, size: entityIdSize + actionIdSize + jumpBoostSize}
    },
    packet_steer_vehicle: (buffer, offset) => {
      let { value: sideways, size: sidewaysSize } = (ctx.f32)(buffer, offset)
      let { value: forward, size: forwardSize } = (ctx.f32)(buffer, offset + sidewaysSize)
      let { value: jump, size: jumpSize } = (ctx.u8)(buffer, offset + sidewaysSize + forwardSize)
      return { value: { sideways, forward, jump }, size: sidewaysSize + forwardSize + jumpSize}
    },
    packet_displayed_recipe: (buffer, offset) => {
      let { value: recipeId, size: recipeIdSize } = (ctx.string)(buffer, offset)
      return { value: { recipeId }, size: recipeIdSize}
    },
    packet_recipe_book: (buffer, offset) => {
      let { value: bookId, size: bookIdSize } = (ctx.varint)(buffer, offset)
      let { value: bookOpen, size: bookOpenSize } = (ctx.bool)(buffer, offset + bookIdSize)
      let { value: filterActive, size: filterActiveSize } = (ctx.bool)(buffer, offset + bookIdSize + bookOpenSize)
      return { value: { bookId, bookOpen, filterActive }, size: bookIdSize + bookOpenSize + filterActiveSize}
    },
    packet_resource_pack_receive: (buffer, offset) => {
      let { value: result, size: resultSize } = (ctx.varint)(buffer, offset)
      return { value: { result }, size: resultSize}
    },
    packet_held_item_slot: (buffer, offset) => {
      let { value: slotId, size: slotIdSize } = (ctx.i16)(buffer, offset)
      return { value: { slotId }, size: slotIdSize}
    },
    packet_set_creative_slot: (buffer, offset) => {
      let { value: slot, size: slotSize } = (ctx.i16)(buffer, offset)
      let { value: item, size: itemSize } = (ctx.slot)(buffer, offset + slotSize)
      return { value: { slot, item }, size: slotSize + itemSize}
    },
    packet_update_jigsaw_block: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: name, size: nameSize } = (ctx.string)(buffer, offset + locationSize)
      let { value: target, size: targetSize } = (ctx.string)(buffer, offset + locationSize + nameSize)
      let { value: pool, size: poolSize } = (ctx.string)(buffer, offset + locationSize + nameSize + targetSize)
      let { value: finalState, size: finalStateSize } = (ctx.string)(buffer, offset + locationSize + nameSize + targetSize + poolSize)
      let { value: jointType, size: jointTypeSize } = (ctx.string)(buffer, offset + locationSize + nameSize + targetSize + poolSize + finalStateSize)
      return { value: { location, name, target, pool, finalState, jointType }, size: locationSize + nameSize + targetSize + poolSize + finalStateSize + jointTypeSize}
    },
    packet_update_sign: (buffer, offset) => {
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset)
      let { value: text1, size: text1Size } = (ctx.string)(buffer, offset + locationSize)
      let { value: text2, size: text2Size } = (ctx.string)(buffer, offset + locationSize + text1Size)
      let { value: text3, size: text3Size } = (ctx.string)(buffer, offset + locationSize + text1Size + text2Size)
      let { value: text4, size: text4Size } = (ctx.string)(buffer, offset + locationSize + text1Size + text2Size + text3Size)
      return { value: { location, text1, text2, text3, text4 }, size: locationSize + text1Size + text2Size + text3Size + text4Size}
    },
    packet_arm_animation: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      return { value: { hand }, size: handSize}
    },
    packet_spectate: (buffer, offset) => {
      let { value: target, size: targetSize } = (ctx.UUID)(buffer, offset)
      return { value: { target }, size: targetSize}
    },
    packet_block_place: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      let { value: location, size: locationSize } = (ctx.position)(buffer, offset + handSize)
      let { value: direction, size: directionSize } = (ctx.varint)(buffer, offset + handSize + locationSize)
      let { value: cursorX, size: cursorXSize } = (ctx.f32)(buffer, offset + handSize + locationSize + directionSize)
      let { value: cursorY, size: cursorYSize } = (ctx.f32)(buffer, offset + handSize + locationSize + directionSize + cursorXSize)
      let { value: cursorZ, size: cursorZSize } = (ctx.f32)(buffer, offset + handSize + locationSize + directionSize + cursorXSize + cursorYSize)
      let { value: insideBlock, size: insideBlockSize } = (ctx.bool)(buffer, offset + handSize + locationSize + directionSize + cursorXSize + cursorYSize + cursorZSize)
      let { value: sequence, size: sequenceSize } = (ctx.varint)(buffer, offset + handSize + locationSize + directionSize + cursorXSize + cursorYSize + cursorZSize + insideBlockSize)
      return { value: { hand, location, direction, cursorX, cursorY, cursorZ, insideBlock, sequence }, size: handSize + locationSize + directionSize + cursorXSize + cursorYSize + cursorZSize + insideBlockSize + sequenceSize}
    },
    packet_use_item: (buffer, offset) => {
      let { value: hand, size: handSize } = (ctx.varint)(buffer, offset)
      let { value: sequence, size: sequenceSize } = (ctx.varint)(buffer, offset + handSize)
      return { value: { hand, sequence }, size: handSize + sequenceSize}
    },
    packet_advancement_tab: (buffer, offset) => {
      let { value: action, size: actionSize } = (ctx.varint)(buffer, offset)
      let { value: tabId, size: tabIdSize } = ((buffer, offset) => {
        switch (action) {
          case 0: return (ctx.string)(buffer, offset)
          case 1: return (ctx.void)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + actionSize)
      return { value: { action, tabId }, size: actionSize + tabIdSize}
    },
    packet_pong: (buffer, offset) => {
      let { value: id, size: idSize } = (ctx.i32)(buffer, offset)
      return { value: { id }, size: idSize}
    },
    packet_chat_session_update: (buffer, offset) => {
      let { value: sessionUUID, size: sessionUUIDSize } = (ctx.UUID)(buffer, offset)
      let { value: expireTime, size: expireTimeSize } = (ctx.i64)(buffer, offset + sessionUUIDSize)
      let { value: publicKey, size: publicKeySize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + sessionUUIDSize + expireTimeSize)
      let { value: signature, size: signatureSize } = ((buffer, offset) => {
        const { value: count, size: countSize } = (ctx.varint)(buffer, offset)
        offset += countSize
        if (offset + count > buffer.length) {
          throw new PartialReadError()
        }
        return { value: buffer.slice(offset, offset + count), size: count + countSize }
      })(buffer, offset + sessionUUIDSize + expireTimeSize + publicKeySize)
      return { value: { sessionUUID, expireTime, publicKey, signature }, size: sessionUUIDSize + expireTimeSize + publicKeySize + signatureSize}
    },
    packet: (buffer, offset) => {
      let { value: name, size: nameSize } = ((buffer, offset) => {
        const { value, size } = (ctx.varint)(buffer, offset)
        return { value: {"0":"teleport_confirm","1":"query_block_nbt","2":"set_difficulty","3":"message_acknowledgement","4":"chat_command","5":"chat_message","6":"chat_session_update","7":"client_command","8":"settings","9":"tab_complete","10":"enchant_item","11":"window_click","12":"close_window","13":"custom_payload","14":"edit_book","15":"query_entity_nbt","16":"use_entity","17":"generate_structure","18":"keep_alive","19":"lock_difficulty","20":"position","21":"position_look","22":"look","23":"flying","24":"vehicle_move","25":"steer_boat","26":"pick_item","27":"craft_recipe_request","28":"abilities","29":"block_dig","30":"entity_action","31":"steer_vehicle","32":"pong","33":"recipe_book","34":"displayed_recipe","35":"name_item","36":"resource_pack_receive","37":"advancement_tab","38":"select_trade","39":"set_beacon_effect","40":"held_item_slot","41":"update_command_block","42":"update_command_block_minecart","43":"set_creative_slot","44":"update_jigsaw_block","45":"update_structure_block","46":"update_sign","47":"arm_animation","48":"spectate","49":"block_place","50":"use_item"}[value] || value, size }
      })(buffer, offset)
      let { value: params, size: paramsSize } = ((buffer, offset) => {
        switch (name) {
          case "teleport_confirm": return (ctx.packet_teleport_confirm)(buffer, offset)
          case "query_block_nbt": return (ctx.packet_query_block_nbt)(buffer, offset)
          case "set_difficulty": return (ctx.packet_set_difficulty)(buffer, offset)
          case "message_acknowledgement": return (ctx.packet_message_acknowledgement)(buffer, offset)
          case "chat_command": return (ctx.packet_chat_command)(buffer, offset)
          case "chat_message": return (ctx.packet_chat_message)(buffer, offset)
          case "client_command": return (ctx.packet_client_command)(buffer, offset)
          case "settings": return (ctx.packet_settings)(buffer, offset)
          case "tab_complete": return (ctx.packet_tab_complete)(buffer, offset)
          case "enchant_item": return (ctx.packet_enchant_item)(buffer, offset)
          case "window_click": return (ctx.packet_window_click)(buffer, offset)
          case "close_window": return (ctx.packet_close_window)(buffer, offset)
          case "custom_payload": return (ctx.packet_custom_payload)(buffer, offset)
          case "edit_book": return (ctx.packet_edit_book)(buffer, offset)
          case "query_entity_nbt": return (ctx.packet_query_entity_nbt)(buffer, offset)
          case "use_entity": return (ctx.packet_use_entity)(buffer, offset)
          case "generate_structure": return (ctx.packet_generate_structure)(buffer, offset)
          case "keep_alive": return (ctx.packet_keep_alive)(buffer, offset)
          case "lock_difficulty": return (ctx.packet_lock_difficulty)(buffer, offset)
          case "position": return (ctx.packet_position)(buffer, offset)
          case "position_look": return (ctx.packet_position_look)(buffer, offset)
          case "look": return (ctx.packet_look)(buffer, offset)
          case "flying": return (ctx.packet_flying)(buffer, offset)
          case "vehicle_move": return (ctx.packet_vehicle_move)(buffer, offset)
          case "steer_boat": return (ctx.packet_steer_boat)(buffer, offset)
          case "pick_item": return (ctx.packet_pick_item)(buffer, offset)
          case "craft_recipe_request": return (ctx.packet_craft_recipe_request)(buffer, offset)
          case "abilities": return (ctx.packet_abilities)(buffer, offset)
          case "block_dig": return (ctx.packet_block_dig)(buffer, offset)
          case "entity_action": return (ctx.packet_entity_action)(buffer, offset)
          case "steer_vehicle": return (ctx.packet_steer_vehicle)(buffer, offset)
          case "pong": return (ctx.packet_pong)(buffer, offset)
          case "chat_session_update": return (ctx.packet_chat_session_update)(buffer, offset)
          case "recipe_book": return (ctx.packet_recipe_book)(buffer, offset)
          case "displayed_recipe": return (ctx.packet_displayed_recipe)(buffer, offset)
          case "name_item": return (ctx.packet_name_item)(buffer, offset)
          case "resource_pack_receive": return (ctx.packet_resource_pack_receive)(buffer, offset)
          case "advancement_tab": return (ctx.packet_advancement_tab)(buffer, offset)
          case "select_trade": return (ctx.packet_select_trade)(buffer, offset)
          case "set_beacon_effect": return (ctx.packet_set_beacon_effect)(buffer, offset)
          case "held_item_slot": return (ctx.packet_held_item_slot)(buffer, offset)
          case "update_command_block": return (ctx.packet_update_command_block)(buffer, offset)
          case "update_command_block_minecart": return (ctx.packet_update_command_block_minecart)(buffer, offset)
          case "set_creative_slot": return (ctx.packet_set_creative_slot)(buffer, offset)
          case "update_jigsaw_block": return (ctx.packet_update_jigsaw_block)(buffer, offset)
          case "update_structure_block": return (ctx.packet_update_structure_block)(buffer, offset)
          case "update_sign": return (ctx.packet_update_sign)(buffer, offset)
          case "arm_animation": return (ctx.packet_arm_animation)(buffer, offset)
          case "spectate": return (ctx.packet_spectate)(buffer, offset)
          case "block_place": return (ctx.packet_block_place)(buffer, offset)
          case "use_item": return (ctx.packet_use_item)(buffer, offset)
          default: return (ctx.void)(buffer, offset)
        }
      })(buffer, offset + nameSize)
      return { value: { name, params }, size: nameSize + paramsSize}
    }
  }
  return ctx
}